# 7. 배열과 문자열

## 1차원, 다차원 배열 선언 및 초기화

C++에서 배열(array)은 **같은 타입의 데이터를 연속된 메모리 공간에 저장하는 집합 자료형**이다.
 배열은 1차원, 2차원(행렬), 3차원 이상 다차원으로 선언할 수 있으며, **정적 크기**, **초기화 방식**, **접근 방법**에 따라 다르게 다룬다.

### 📌 1차원 배열 (1D Array)

#### ✅ 선언

```
int arr[5];          // 크기 5짜리 정수 배열
double scores[10];   // double 10개 저장
```

- 배열 크기는 **상수 정수**여야 함 (C++11부터는 `constexpr` 사용 가능)

#### ✅ 선언 + 초기화

```
int arr[5] = {1, 2, 3, 4, 5};       // 전체 초기화
int arr[5] = {1, 2};                // 나머지는 자동 0
int arr[]  = {10, 20, 30};          // 크기 생략 시 컴파일러가 자동 계산
```

- `{}`만 쓰면 모두 0으로 초기화:

```
int arr[4] = {};    // == {0, 0, 0, 0}
```

#### ✅ 접근 및 출력

```
for (int i = 0; i < 5; ++i)
    std::cout << arr[i] << " ";
```

### 📌 다차원 배열 (2D, 3D 등)

#### ✅ 2차원 배열 선언

```
int matrix[2][3];  // 2행 3열 배열
```

- 메모리 구조는 **행 우선(row-major order)**
   → `matrix[0][0]`, `matrix[0][1]`, ..., `matrix[1][2]`

#### ✅ 선언 + 초기화

```
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

- 한 줄로 초기화도 가능:

```
int matrix[2][3] = {1, 2, 3, 4, 5, 6};
```

- 초기값 부족 시 나머지는 0으로 채움

```
int matrix[2][3] = {{1}, {4}};  // == {{1,0,0}, {4,0,0}}
```

#### ✅ 2차원 배열 접근

```
for (int i = 0; i < 2; ++i)
    for (int j = 0; j < 3; ++j)
        std::cout << matrix[i][j] << " ";
```

#### ✅ 3차원 배열 선언 예

```
int cube[2][3][4];  // 2층 3행 4열 배열
```

- 접근: `cube[layer][row][col]`

### 📌 배열 크기 자동 유추

```
int arr[] = {1, 2, 3};             // size = 3
int matrix[][3] = {{1,2,3}, {4,5,6}}; // 첫 차원 생략 가능, 둘째는 반드시 명시
```

### 📌 C++ 표준 라이브러리 배열 (보너스)

```
#include <array>

std::array<int, 5> arr = {1, 2, 3, 4, 5};
```

- **정적 배열이지만 안전하고 기능 많음**
- `.size()`, `.at()`, `.begin()` 등 STL 메서드 사용 가능

### 📎 요약

| 배열 종류      | 선언 예                | 초기화 예                           |
| -------------- | ---------------------- | ----------------------------------- |
| 1차원 배열     | `int arr[5];`          | `{1, 2, 3, 4, 5}` 또는 `{}`         |
| 2차원 배열     | `int mat[2][3];`       | `{{1,2,3}, {4,5,6}}`                |
| 3차원 배열     | `int cube[2][3][4];`   | 초기화 가능하나 잘 쓰이진 않음      |
| 자동 크기 추론 | `int arr[] = {1,2,3};` | `int mat[][3] = {{1,2,3},{4,5,6}};` |

배열은 **고정 크기이며 컴파일 타임에 할당되는 연속 메모리 구조**다.
 동적으로 크기를 정하고 싶다면 `new[]` 또는 **`std::vector`**를 사용하는 것이 더 유연하고 현대적인 방식이다.

## C 스타일 문자열 (char 배열, null 종료)

C++에서는 문자열을 `std::string` 클래스로 다룰 수 있지만, **전통적인 C 스타일 문자열**은 여전히 **로우 레벨 데이터 처리, 시스템 프로그래밍, 레거시 코드 호환** 등에서 중요하게 사용된다.
 이 문자열은 **`char` 배열에 저장되며, 반드시 널 문자(`'\0'`)로 종료**되어야 한다.

### 📌 기본 개념

- **C 스타일 문자열** = `char` 타입 배열 + 마지막에 **null 문자** (`'\0'`)
- null 문자는 **문자열의 끝을 나타내는 마커**이며, 내부에는 포함되지 않음

```
char msg[] = "Hello";
```

- 위 선언은 다음과 같음:

```
char msg[] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

### 📌 선언 방식

```
char str1[6] = "Hello";     // 자동으로 '\0' 포함됨
char str2[]  = "World";     // 크기 생략 → 자동 계산 (6)
char str3[10] = {'H', 'i'}; // '\0' 없음 → C 문자열 아님!
```

> 문자열 상수로 초기화 시 **널 종료 문자 자동 추가됨**
>  그러나 문자 배열을 직접 초기화하면 반드시 `'\0'`을 명시해야 C 문자열로 인정됨

### 📌 출력 및 사용 예

```
char name[] = "Alice";
std::cout << name << "\n";  // 출력: Alice
```

- `<<` 연산자나 `printf("%s", name)` 등은 null 문자까지 출력

### 📌 문자 접근 및 수정

```
char greeting[] = "Hi!";
greeting[0] = 'B';
std::cout << greeting;  // 출력: Bi!
```

- 배열 요소는 일반 배열처럼 인덱스로 접근 가능
- 단, **문자열 상수는 읽기 전용 영역에 존재** → 수정하면 **UB (undefined behavior)** 발생

```
char* s = "Hi";   // ❌ 포인터로 문자열 상수 가리킴 (수정 불가)
s[0] = 'B';       // ❌ UB 발생
```

### 📌 문자열 관련 함수 (헤더: `<cstring>`)

| 함수 이름           | 설명                           |
| ------------------- | ------------------------------ |
| `strlen(s)`         | 문자열 길이 (`'\0'` 제외)      |
| `strcpy(dest, src)` | 문자열 복사                    |
| `strcat(dest, src)` | 문자열 이어 붙이기             |
| `strcmp(a, b)`      | 문자열 비교 (`0`이면 동일)     |
| `strchr(s, c)`      | 문자 `c`를 처음 찾은 위치 반환 |
| `strstr(s, sub)`    | 부분 문자열 위치 반환          |

예:

```
#include <cstring>

char a[20] = "Hello";
char b[] = "World";

strcat(a, b);       // a = "HelloWorld"
std::cout << a;     // 출력: HelloWorld
```

### 📌 주의 사항

- `strlen()`은 null 문자를 기준으로 **길이를 세지, 배열 전체 크기를 알지 못함**
- `strcpy`, `strcat` 등은 **버퍼 오버플로우 위험** → `strncpy`, `strncat` 사용 권장
- 문자열 비교는 `==`이 아니라 `strcmp()`로 수행해야 함

```
if (strcmp(a, b) == 0) {
    std::cout << "Equal strings\n";
}
```

### 📎 요약

| 특징         | 설명                                                |
| ------------ | --------------------------------------------------- |
| 종료 조건    | 반드시 `'\0'` (null 문자)로 종료                    |
| 저장 구조    | `char` 배열에 연속 저장                             |
| 상수 vs 배열 | `"abc"`는 `const char*`, 수정 불가                  |
| 크기 계산    | `strlen()`은 내용 길이, `sizeof()`는 전체 배열 크기 |
| 문자열 함수  | `<cstring>`에서 제공 (`strcpy`, `strcmp` 등)        |

### ✅ 정리

> **C 스타일 문자열은 “char 배열 + null 종료”라는 구조를 반드시 이해하고 다뤄야 한다.**
>  복사, 비교, 출력, 수정 시 **널 문자(`\0`) 누락은 버그의 핵심 원인**이며,
>  현대 C++에서는 가능하면 `std::string`을 사용하고,
>  **레거시나 로우레벨 코드에서는 `cstring` 함수 사용 시 버퍼 크기와 널 종료 여부를 반드시 확인해야 한다.**

## std::string 클래스

`std::string`은 C++ 표준 라이브러리에서 제공하는 **문자열 클래스**로,
 C 스타일 문자열(`char[]`)보다 **안전하고 강력한 기능**을 제공한다.
 메모리 관리가 자동이며, 다양한 연산자와 메서드를 통해 **직관적인 문자열 처리**가 가능하다.

### 📌 기본 선언과 초기화

```
#include <string>

std::string s1 = "Hello";
std::string s2("World");
std::string s3;                // 빈 문자열
std::string s4 = s1 + " " + s2;  // 연결
```

- `std::string`은 내부적으로 `char` 배열을 관리하지만, 동적 메모리를 사용함
- 복사, 비교, 연결 등이 자동으로 처리됨

### 📌 주요 멤버 함수 및 연산자

#### 🔹 길이 / 상태 확인

```
s.size();        // 문자열 길이 반환 (== length())
s.empty();       // 비어 있는지 확인
s.clear();       // 문자열 비우기
```

#### 🔹 접근 및 수정

```
s[0];            // 첫 글자
s.at(1);         // 1번 인덱스 문자 (범위 검사 포함)
s.front();       // 첫 글자 (s[0])
s.back();        // 마지막 글자
s[1] = 'a';      // 문자 수정 가능
```

#### 🔹 문자열 추가/삭제

```
s.append("!!!");   // 문자열 덧붙이기
s += " world";     // 연산자 오버로드로 추가
s.insert(0, "★");  // 앞에 삽입
s.erase(2, 3);     // 인덱스 2부터 3글자 삭제
s.pop_back();      // 마지막 문자 삭제
```

#### 🔹 검색 및 부분 문자열

```
s.find("el");       // 처음 등장하는 위치 (없으면 string::npos)
s.rfind("l");       // 뒤에서부터 찾기
s.substr(1, 3);     // 인덱스 1부터 3글자 추출
```

#### 🔹 비교

```
if (s1 == s2) { ... }
if (s1 < s2) { ... }      // 사전순 비교
s.compare(s2);            // == 0이면 동일
```

### 📌 입력과 출력

```
std::string name;
std::cin >> name;        // 공백 전까지만 입력됨

std::getline(std::cin, name);  // 한 줄 전체 입력
std::cout << name << "\n";
```

### 📌 반복과 순회

```
for (char c : s)
    std::cout << c << " ";

for (std::string::iterator it = s.begin(); it != s.end(); ++it)
    std::cout << *it;
```

#### 📌 변환 관련

```
std::string n = std::to_string(42);  // 숫자 → 문자열
int x = std::stoi("123");            // 문자열 → 정수
double d = std::stod("3.14");        // 문자열 → 실수
```

#### 📌 메모리 관리 (보충)

- `std::string`은 내부적으로 **동적 메모리 할당을 통해 크기를 조절**
- 프로그램이 직접 메모리 해제할 필요 없음
- **복사 생성자, 대입 연산자**, **이동 연산자(C++11)** 등 지원

### 📎 요약 표

| 기능      | 메서드 / 연산자                |
| --------- | ------------------------------ |
| 길이 확인 | `s.size()`, `s.length()`       |
| 비우기    | `s.clear()`                    |
| 추가      | `s.append()`, `+=`, `insert()` |
| 삭제      | `s.erase()`, `pop_back()`      |
| 부분 추출 | `s.substr(start, len)`         |
| 검색      | `s.find()`, `s.rfind()`        |
| 비교      | `==`, `!=`, `<`, `compare()`   |
| 변환      | `std::to_string()`, `stoi()`   |

### ✅ 정리

> `std::string`은 C 스타일 문자열보다 훨씬 안전하고 유연하다.
>  자동 메모리 관리, 다양한 연산자 오버로딩, 범위 검사 기능, STL 호환성 덕분에
>  **현대 C++에서는 문자열 처리의 표준 도구로 반드시 사용**해야 한다.
>
> **특히 문자열을 넘기거나 반환할 때는 `std::string`을 기본으로 사용하고, C 스타일 문자열은 제한된 저수준 상황에서만 쓰는 것이 좋다.**

## 문자열 관련 표준 함수

다음은 C++에서 자주 사용하는 **문자열 관련 표준 함수들**을 **C 스타일 문자열 함수**와 **C++ `std::string` 클래스 함수**로 구분하여 정리한 것이다. 문자열 처리 목적에 따라 두 가지 접근 방식 중 하나를 선택하거나 혼용할 수 있다.

### ✅ C 스타일 문자열 함수 (`<cstring>`)

헤더: `#include <cstring>`
 모두 `char*` 혹은 `const char*` 타입에 사용되며, 문자열은 반드시 `'\0'`으로 종료되어야 한다.

| 함수명                  | 설명                                        | 예시                             |
| ----------------------- | ------------------------------------------- | -------------------------------- |
| `strlen(const char*)`   | 문자열의 길이 반환 (`'\0'` 제외)            | `strlen("abc") → 3`              |
| `strcpy(dest, src)`     | 문자열 복사 (`src` → `dest`)                | `strcpy(d, "abc");`              |
| `strncpy(dest, src, n)` | 최대 `n`글자까지 복사                       | `strncpy(d, s, 10);`             |
| `strcat(dest, src)`     | 문자열 덧붙이기                             | `strcat(dest, "!!");`            |
| `strncat(dest, src, n)` | 최대 `n`글자까지만 덧붙임                   | `strncat(dest, src, 5);`         |
| `strcmp(a, b)`          | 문자열 비교 (`0`이면 같음)                  | `strcmp("abc", "abc") → 0`       |
| `strncmp(a, b, n)`      | 앞 `n`글자만 비교                           | `strncmp("abc", "abd", 2) → 0`   |
| `strchr(str, ch)`       | 문자 `ch`가 처음 나오는 위치 반환           | `strchr("hello", 'l') → "llo"`   |
| `strrchr(str, ch)`      | 문자 `ch`가 마지막으로 나오는 위치 반환     | `strrchr("hello", 'l') → "lo"`   |
| `strstr(str, sub)`      | 부분 문자열 찾기 (`sub`가 처음 나오는 위치) | `strstr("hello", "el") → "ello"` |
| `strtok(str, delim)`    | 문자열 분리 (토큰화), 상태 유지형 함수      | `strtok(str, ",");`              |

> ⚠️ 대부분의 함수는 **안전성 부족**으로 인해 `strncpy`, `strncat`처럼 크기를 제한하는 버전 사용을 권장한다.

### ✅ C++ `std::string` 클래스 함수 (`<string>`)

`std::string`은 C++에서 문자열을 객체로 다루는 고수준 클래스다. 메모리를 자동으로 관리하며 다양한 메서드를 제공한다.

| 메서드 / 연산자            | 설명                                         | 예시                         |
| -------------------------- | -------------------------------------------- | ---------------------------- |
| `s.size()` / `length()`    | 문자열 길이 반환                             | `s.length()`                 |
| `s.empty()`                | 비어 있는지 확인                             | `s.empty()`                  |
| `s.clear()`                | 문자열 초기화                                | `s.clear();`                 |
| `s[i]`, `s.at(i)`          | 문자 접근 (`at`은 범위 검사 포함)            | `s.at(2)`                    |
| `s.front()`, `back()`      | 첫/마지막 문자 접근                          | `s.front()`                  |
| `s.append(str)`            | 문자열 덧붙이기                              | `s.append("world");`         |
| `s += str`                 | 문자열 결합                                  | `s += "!";`                  |
| `s.insert(pos, str)`       | 특정 위치에 문자열 삽입                      | `s.insert(0, "Hi ");`        |
| `s.erase(pos, len)`        | 부분 문자열 삭제                             | `s.erase(1, 3);`             |
| `s.replace(pos, len, str)` | 부분 문자열 치환                             | `s.replace(0, 2, "Yo");`     |
| `s.find(str)`              | 부분 문자열 탐색 (앞에서부터)                | `s.find("abc")`              |
| `s.rfind(str)`             | 부분 문자열 탐색 (뒤에서부터)                | `s.rfind("abc")`             |
| `s.substr(pos, len)`       | 부분 문자열 추출                             | `s.substr(1, 3);`            |
| `s.compare(str)`           | 문자열 비교 (`==`, `<` 등의 연산자도 지원됨) | `if (s.compare("abc") == 0)` |
| `s.c_str()`                | `const char*` 반환 (C 함수와의 연동용)       | `printf("%s", s.c_str());`   |
| `std::to_string(val)`      | 숫자 → 문자열 변환                           | `std::to_string(42)`         |
| `std::stoi(str)`           | 문자열 → 정수 변환                           | `std::stoi("123")`           |
| `std::stod(str)`           | 문자열 → 실수 변환                           | `std::stod("3.14")`          |

### ✅ 선택 기준 요약

| 상황                          | 추천 방식              | 이유                                 |
| ----------------------------- | ---------------------- | ------------------------------------ |
| 레거시 C API와 연동할 때      | C 스타일 (`<cstring>`) | `char*` 기반 함수로만 동작함         |
| 일반 문자열 처리              | `std::string`          | 메모리 관리 자동, 안전하고 강력함    |
| 안전한 연산, 가변 크기 필요   | `std::string`          | 예외 처리, 복사/삽입/삭제 편리함     |
| 퍼포먼스가 극도로 중요한 경우 | C 스타일 (제한적)      | 낮은 오버헤드, 그러나 매우 주의 필요 |

### ✅ 결론

- **일반적으로는 `std::string` 사용이 절대 우선**
- **C 스타일 함수는 시스템 프로그래밍이나 C API 호환 시에만 사용**
- `std::string`은 객체로서 **직관적인 문법**, **자동 메모리 관리**, **안전성**이 탁월함

```
std::string name = "Alice";
name += " Kim";
std::cout << name.substr(0, 5);  // 출력: Alice
```