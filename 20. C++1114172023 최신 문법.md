# 20. C++11/14/17/20/23 ìµœì‹  ë¬¸ë²•

## auto í‚¤ì›Œë“œ, range-based for loop

### âœ… 1. `auto` í‚¤ì›Œë“œ

#### ğŸ“Œ ì •ì˜

`auto`ëŠ” **ì»´íŒŒì¼ëŸ¬ê°€ ë³€ìˆ˜ì˜ íƒ€ì…ì„ ìë™ìœ¼ë¡œ ì¶”ë¡ í•˜ë„ë¡ í•˜ëŠ” í‚¤ì›Œë“œ**ì´ë‹¤.
 íƒ€ì…ì´ ëª…í™•í•œ ì´ˆê¸°ê°’ì´ ì¡´ì¬í•  ë•Œ ì‚¬ìš©í•˜ë©°, íŠ¹íˆ ë³µì¡í•œ íƒ€ì…(ë°˜ë³µì ë“±)ì„ ê°„ê²°í•˜ê²Œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

```
auto x = 10;           // intë¡œ ì¶”ë¡ 
auto pi = 3.14;        // doubleë¡œ ì¶”ë¡ 
auto name = "Alice";   // const char*ë¡œ ì¶”ë¡ 
```

#### ğŸ“Œ STLì—ì„œì˜ í™œìš©

```
std::vector<int> v = {1, 2, 3, 4};

// ë°˜ë³µì íƒ€ì… ì§ì ‘ ì§€ì •
for (std::vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
    std::cout << *it << '\n';
}

// auto ì‚¬ìš©
for (auto it = v.begin(); it != v.end(); ++it) {
    std::cout << *it << '\n';
}
```

> ë³µì¡í•œ íƒ€ì…ì„ ëª…ì‹œí•˜ì§€ ì•Šì•„ë„ ë˜ë©°, **ìœ ì§€ë³´ìˆ˜ì„±ê³¼ ê°€ë…ì„± í–¥ìƒ**ì— ê¸°ì—¬

#### ğŸ“Œ ì£¼ì˜ì 

| ìƒí™©                 | `auto` íƒ€ì… ì¶”ë¡  ê²°ê³¼        |
| -------------------- | ---------------------------- |
| `auto x = 5;`        | `int`                        |
| `auto y = {1, 2};`   | `std::initializer_list<int>` |
| `const auto z = 42;` | `const int`                  |
| `auto* p = new int;` | `int*`                       |

â€» **ì°¸ì¡°/const ì—¬ë¶€ëŠ” ìë™ ì¶”ë¡ ë˜ì§€ ì•ŠìŒ** â†’ í•„ìš” ì‹œ `auto&`, `const auto&` ëª…ì‹œ

### âœ… 2. `range-based for loop` (ë²”ìœ„ ê¸°ë°˜ forë¬¸)

#### ğŸ“Œ ì •ì˜

C++11ë¶€í„° ë„ì…ëœ **ê°„ê²°í•œ ì»¨í…Œì´ë„ˆ ìˆœíšŒ ë¬¸ë²•**
 ê¸°ì¡´ì˜ `begin()`, `end()` ë°˜ë³µì ê¸°ë°˜ ì½”ë“œë¥¼ ì¶•ì•½í•œ ë¬¸ë²•ìœ¼ë¡œ, `auto`ì™€ í•¨ê»˜ ìì£¼ ì‚¬ìš©ë¨

```
std::vector<std::string> names = {"Tom", "Jerry", "Spike"};

for (const auto& name : names) {
    std::cout << name << '\n';
}
```

* `auto` â†’ íƒ€ì… ì¶”ë¡ 

* `&` â†’ ì°¸ì¡° ìˆœíšŒ (ë³µì‚¬ ë¹„ìš© ë°©ì§€)

* `const` â†’ ì½ê¸° ì „ìš©

#### ğŸ“Œ ë‚´ë¶€ ë™ì‘ ì›ë¦¬

```
for (T x : container)
```

ì€ ë‚´ë¶€ì ìœ¼ë¡œ ë‹¤ìŒê³¼ ê°™ì´ í•´ì„ë¨:

```
auto __begin = container.begin();
auto __end = container.end();
for (; __begin != __end; ++__begin) {
    T x = *__begin;
}
```

#### ğŸ“Œ ì˜ˆì œ: ê°’/ì°¸ì¡°/ì“°ê¸° êµ¬ë¶„

```
for (auto x : vec)          // ê°’ ë³µì‚¬ (ì½ê¸°ë§Œ)
for (auto& x : vec)         // ì°¸ì¡° (ì“°ê¸° ê°€ëŠ¥)
for (const auto& x : vec)   // const ì°¸ì¡° (ì½ê¸° ì „ìš©, ì¶”ì²œ)
```

### âœ… 3. ì‹¤ì „ ì˜ˆì œ ì¢…í•©

```
std::map<std::string, int> scores = {
    {"Math", 90}, {"English", 85}
};

// auto + range-for
for (const auto& [subject, score] : scores) {
    std::cout << subject << ": " << score << '\n';
}
```

> C++17ë¶€í„° **êµ¬ì¡° ë¶„í•´ ì„ ì–¸(structured bindings)** ì§€ì›

### âœ… ë¹„êµ ìš”ì•½

| ìš”ì†Œ              | ì„¤ëª…                 | ì˜ˆì‹œ                        |
| ----------------- | -------------------- | --------------------------- |
| `auto`            | ë³€ìˆ˜ íƒ€ì… ìë™ ì¶”ë¡   | `auto x = 10;`              |
| `auto&`           | ì°¸ì¡° ì¶”ë¡             | `auto& ref = obj;`          |
| `const auto&`     | ì½ê¸° ì „ìš© ì°¸ì¡°       | `for (const auto& x : vec)` |
| `range-based for` | ì»¨í…Œì´ë„ˆ ìˆœíšŒ ê°„ì†Œí™” | `for (auto x : vec)`        |

### ğŸ“Œ ì‚¬ìš© ì‹œ ìœ ì˜ì 

- `auto`ëŠ” **ì´ˆê¸°ê°’ì˜ íƒ€ì…ì— ì „ì ìœ¼ë¡œ ì˜ì¡´**í•˜ë¯€ë¡œ, ì˜ë„ì™€ ë‹¤ë¥¸ íƒ€ì…ì´ ì¶”ë¡ ë  ìˆ˜ ìˆìŒ
- `range-based for`ëŠ” **ì„ì˜ ìœ„ì¹˜ ì ‘ê·¼ì´ ë¶ˆê°€ëŠ¥í•œ ì»¨í…Œì´ë„ˆ**ì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥ (`std::list`, `std::set` ë“±)
- `unordered_map` ë“±ì—ì„œëŠ” ë°˜ë³µìì˜ íƒ€ì…ì´ ë§¤ìš° ë³µì¡í•˜ë¯€ë¡œ `auto` ì‚¬ìš©ì´ íŠ¹íˆ ìœ ìš©

### âœ… ê²°ë¡  ìš”ì•½

| í‚¤ì›Œë“œ            | ì£¼ìš” ëª©ì            | ì¥ì                       |
| ----------------- | ------------------- | ------------------------- |
| `auto`            | íƒ€ì… ì¶”ë¡            | ë³µì¡í•œ íƒ€ì… ìƒëµ, ê°„ê²°ì„±  |
| `range-based for` | ë°˜ë³µì ê¸°ë°˜ ìˆœíšŒ    | ì•ˆì „í•˜ê³  ê°„ë‹¨í•œ ë°˜ë³µ êµ¬ì¡° |
| `const auto&`     | ì½ê¸° ì „ìš© ì°¸ì¡° ìˆœíšŒ | ì„±ëŠ¥ ìµœì í™” + ë¶ˆë³€ì„± ë³´ì¥ |

## nullptr, enum class

### âœ… 1. `nullptr` â€“ ëª…í™•í•œ í¬ì¸í„° null í‘œí˜„

#### ğŸ“Œ ì •ì˜

`nullptr`ì€ C++11ì—ì„œ ìƒˆë¡­ê²Œ ë„ì…ëœ **ë„ í¬ì¸í„° ìƒìˆ˜(null pointer constant)**ì´ë©°,
 ê¸°ì¡´ì˜ `NULL` ë§¤í¬ë¡œ ë˜ëŠ” `0`ê³¼ì˜ ëª¨í˜¸í•¨ì„ ì œê±°í•œë‹¤.

#### ğŸ“Œ ì´ì „ ë°©ì‹ì˜ ë¬¸ì œì 

```
void func(int);
void func(char*);

func(0);   // ëª¨í˜¸: ì •ìˆ˜ 0ì¸ì§€, ë„ í¬ì¸í„°ì¸ì§€
```

> ìœ„ ì½”ë“œëŠ” `int` ë²„ì „ì„ í˜¸ì¶œí•˜ê²Œ ë˜ë©°, ê°œë°œìì˜ ì˜ë„ì™€ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ

#### ğŸ“Œ `nullptr`ì˜ í•´ê²° ë°©ì‹

```
func(nullptr);  // char* ë²„ì „ì´ ëª…í™•í•˜ê²Œ í˜¸ì¶œë¨
```

- `nullptr`ì˜ íƒ€ì…ì€ **`std::nullptr_t`**
- `0`, `NULL`ê³¼ ë‹¬ë¦¬ **í¬ì¸í„° ì „ìš© íƒ€ì…**

#### ğŸ“Œ ì˜ˆì œ

```
int* p1 = nullptr;     // ì•ˆì „í•œ null ì´ˆê¸°í™”
if (p1 == nullptr) {
    std::cout << "í¬ì¸í„°ëŠ” ë¹„ì–´ ìˆìŒ\n";
}
```

#### ğŸ“Œ ìš”ì•½

| í‘œí˜„      | C++98            | C++11 ì´í›„                      |
| --------- | ---------------- | ------------------------------- |
| `0`       | ê°€ëŠ¥ (int)       | ì‚¬ìš© ì§€ì–‘                       |
| `NULL`    | `#define NULL 0` | ì—¬ì „íˆ ì‚¬ìš© ê°€ëŠ¥, ê·¸ëŸ¬ë‚˜ ê¶Œì¥ X |
| `nullptr` | âŒ                | âœ… í¬ì¸í„° ì „ìš© null              |

### âœ… 2. `enum class` â€“ íƒ€ì… ì•ˆì „í•œ ì—´ê±°í˜•

#### ğŸ“Œ ì •ì˜

ê¸°ì¡´ì˜ `enum`ì€ **ì•”ì‹œì ìœ¼ë¡œ ì •ìˆ˜(int)ë¡œ ë³€í™˜**ë˜ê³ , **ìŠ¤ì½”í”„ ì—†ëŠ” ì „ì—­ ì´ë¦„ ì¶©ëŒ ë¬¸ì œ**ê°€ ìˆì—ˆë‹¤.

C++11ì˜ `enum class`ëŠ” ë‹¤ìŒì„ ë³´ì¥í•œë‹¤:

- **ìŠ¤ì½”í”„ë¥¼ ê°€ì§„ ì´ë¦„ ê³µê°„ ì œê³µ**
- **ì•”ì‹œì  ë³€í™˜ ë°©ì§€** â†’ íƒ€ì… ì•ˆì „
- **ëª…í™•í•œ ë²”ìœ„ ì§€ì •**

#### ğŸ“Œ ê¸°ì¡´ enumì˜ ë¬¸ì œì 

```
enum Color { Red, Green, Blue };
enum Traffic { Stop, Go, Red };  // âš ï¸ Red ì¤‘ë³µ ì •ì˜ ê°€ëŠ¥ì„±

int c = Red;     // intë¡œ ì•”ì‹œì  ë³€í™˜ í—ˆìš© â†’ ìœ„í—˜
```

#### ğŸ“Œ `enum class` ì‚¬ìš© ì˜ˆ

```
enum class Color { Red, Green, Blue };

Color c = Color::Red;     // ìŠ¤ì½”í”„ ëª…í™•
// int x = c;             // âŒ ì•”ì‹œì  ë³€í™˜ ë¶ˆê°€
```

- ê°’ ë¹„êµëŠ” `==`, `!=`ë¡œ ê°€ëŠ¥
- ì¶œë ¥í•˜ë ¤ë©´ ëª…ì‹œì  ë³€í™˜ í•„ìš” (`static_cast<int>` ë“±)

#### ğŸ“Œ ê°•ì œ í˜• ë³€í™˜ ì˜ˆ

```
enum class Direction { Up = 1, Down = 2 };
int raw = static_cast<int>(Direction::Down);  // 2
```

#### ğŸ“Œ ì‚¬ìš©ì ì •ì˜ ê¸°ë°˜ íƒ€ì… (ê¸°ë³¸: int)

```
enum class ErrorCode : uint8_t {
    OK = 0,
    NotFound = 1,
    Timeout = 2
};
```

- ì—´ê±°í˜•ì˜ ì €ì¥ í¬ê¸° ìµœì í™” ê°€ëŠ¥

#### ğŸ“Œ ë¹„êµ ìš”ì•½

| í•­ëª©        | `enum`           | `enum class`             |
| ----------- | ---------------- | ------------------------ |
| ì•”ì‹œì  ë³€í™˜ | O (intë¡œ)        | âŒ (ëª…ì‹œì  ë³€í™˜ í•„ìš”)     |
| ìŠ¤ì½”í”„      | ì—†ìŒ (ì „ì—­ ë…¸ì¶œ) | ìˆìŒ (`EnumType::Value`) |
| íƒ€ì… ì•ˆì „ì„± | ë‚®ìŒ             | ë†’ìŒ                     |
| ì‚¬ìš© ëª©ì    | ê°„ë‹¨í•œ ìƒìˆ˜ ì§‘í•© | ì¶©ëŒ ë°©ì§€, ì•ˆì „í•œ ì—´ê±°í˜• |

### âœ… ê²°ë¡  ìš”ì•½

| ê¸°ëŠ¥         | ì„¤ëª…                               | ë„ì… ë²„ì „ |
| ------------ | ---------------------------------- | --------- |
| `nullptr`    | null í¬ì¸í„°ë¥¼ ëª…í™•í•˜ê²Œ í‘œí˜„        | C++11     |
| `enum class` | ìŠ¤ì½”í”„ ê¸°ë°˜ ì—´ê±°í˜•, íƒ€ì… ì•ˆì „ í™•ë³´ | C++11     |

## ëŒë‹¤ í•¨ìˆ˜, ê°€ë³€ ëŒë‹¤, generic lambda

### âœ… 1. ëŒë‹¤ í•¨ìˆ˜ (Lambda Function)

#### ğŸ“Œ ì •ì˜

ëŒë‹¤ëŠ” **ìµëª… í•¨ìˆ˜ ê°ì²´ë¥¼ ê°„ê²°í•˜ê²Œ ìƒì„±**í•˜ëŠ” ë¬¸ë²•ì´ë‹¤.
 í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œë˜ë©°, **ì™¸ë¶€ ë³€ìˆ˜ë¥¼ ìº¡ì²˜í•˜ì—¬ ì‚¬ìš©**í•  ìˆ˜ ìˆë‹¤.

#### ğŸ“Œ ê¸°ë³¸ ë¬¸ë²•

```
[capture](parameter_list) -> return_type {
    function_body
}
```

> `-> return_type`ì€ ìƒëµ ê°€ëŠ¥í•˜ë©°, ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ìë™ ì¶”ë¡ ëœë‹¤.

#### ğŸ“Œ ì˜ˆì œ

```
auto add = [](int a, int b) {
    return a + b;
};

int sum = add(3, 4);  // 7
```

- `add`ëŠ” í•¨ìˆ˜ ê°ì²´ (í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œ ê°€ëŠ¥)
- `[]`ëŠ” ìº¡ì²˜ ë¦¬ìŠ¤íŠ¸ (ì™¸ë¶€ ë³€ìˆ˜ ì°¸ì¡° ê°€ëŠ¥)

### âœ… 2. ìº¡ì²˜ ë¦¬ìŠ¤íŠ¸ (Capture List)

ëŒë‹¤ëŠ” ì™¸ë¶€ ë³€ìˆ˜ë¥¼ ìº¡ì²˜í•  ìˆ˜ ìˆìœ¼ë©°, ìº¡ì²˜ ë°©ì‹ì€ ëª…ì‹œì ìœ¼ë¡œ ì œì–´ëœë‹¤.

| ë¬¸ë²•      | ì˜ë¯¸                           |
| --------- | ------------------------------ |
| `[=]`     | ì™¸ë¶€ ë³€ìˆ˜ ì „ì²´ **ê°’ ë³µì‚¬**     |
| `[&]`     | ì™¸ë¶€ ë³€ìˆ˜ ì „ì²´ **ì°¸ì¡°**        |
| `[x]`     | ë³€ìˆ˜ `x`ë§Œ ê°’ìœ¼ë¡œ ë³µì‚¬         |
| `[&x]`    | ë³€ìˆ˜ `x`ë§Œ ì°¸ì¡°                |
| `[=, &y]` | ë‚˜ë¨¸ì§€ëŠ” ë³µì‚¬, `y`ë§Œ ì°¸ì¡°      |
| `[this]`  | í˜„ì¬ í´ë˜ìŠ¤ì˜ this í¬ì¸í„° ìº¡ì²˜ |

#### ğŸ“Œ ìº¡ì²˜ ì˜ˆì‹œ

```
int a = 10, b = 20;

auto sum = [=]() { return a + b; };   // ê°’ ë³µì‚¬
auto diff = [&]() { return a - b; };  // ì°¸ì¡°
```

### âœ… 3. ê°€ë³€ ëŒë‹¤ (Mutable Lambda)

ê¸°ë³¸ì ìœ¼ë¡œ ê°’ìœ¼ë¡œ ìº¡ì²˜í•œ ë³€ìˆ˜ëŠ” **ëŒë‹¤ ë‚´ì—ì„œ ìˆ˜ì • ë¶ˆê°€**ì´ë‹¤.
 `mutable` í‚¤ì›Œë“œë¥¼ í†µí•´ ëŒë‹¤ ë‚´ **ë³µì‚¬ëœ ë³€ìˆ˜ì˜ ê°’ì„ ë³€ê²½í•  ìˆ˜ ìˆê²Œ í•¨** (ë‹¨, ì™¸ë¶€ì—ëŠ” ì˜í–¥ ì—†ìŒ)

#### ğŸ“Œ ì˜ˆì œ

```
int x = 5;

auto f = [x]() mutable {
    x += 10;         // OK: ë³µì‚¬ëœ xë¥¼ ìˆ˜ì •
    std::cout << x;  // 15
};

f();
std::cout << x;      // 5 (ì›ë³¸ì€ ê·¸ëŒ€ë¡œ)
```

- `mutable` ì—†ìœ¼ë©´ `x += 10;`ì€ ì»´íŒŒì¼ ì˜¤ë¥˜

### âœ… 4. ì œë„¤ë¦­ ëŒë‹¤ (Generic Lambda) â€“ C++14~

#### ğŸ“Œ ì •ì˜

ì œë„¤ë¦­ ëŒë‹¤ëŠ” **ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì— `auto` ì‚¬ìš© ê°€ëŠ¥**
 í…œí”Œë¦¿ì²˜ëŸ¼ ì‘ë™í•˜ì—¬ ë‹¤ì–‘í•œ íƒ€ì…ì— ëŒ€ì‘í•  ìˆ˜ ìˆë‹¤.

#### ğŸ“Œ ì˜ˆì œ

```
auto print = [](auto x) {
    std::cout << x << '\n';
};

print(10);           // int
print("Hello");      // const char*
print(3.14);         // double
```

> ë‚´ë¶€ì ìœ¼ë¡œëŠ” ì»´íŒŒì¼ëŸ¬ê°€ í…œí”Œë¦¿ í•¨ìˆ˜ ê°ì²´ë¡œ ë³€í™˜

#### ğŸ“Œ ë‹¤ì¤‘ ë§¤ê°œë³€ìˆ˜ ì œë„¤ë¦­

```
auto add = [](auto a, auto b) {
    return a + b;
};

std::cout << add(1, 2);         // 3
std::cout << add(1.5, 2.5);     // 4.0
std::cout << add(std::string("A"), "B");  // "AB"
```

#### ğŸ“Œ ì œë„¤ë¦­ + ìº¡ì²˜ + mutable ì¡°í•©

```
int x = 5;
auto f = [x](auto y) mutable {
    x += y;
    return x;
};

f(3);   // 8
f(10);  // 18 (ëŒë‹¤ ë‚´ë¶€ ë³µì‚¬ë³¸ë§Œ ë³€í™”)
```

### âœ… ìš”ì•½ ë¹„êµí‘œ

| ëŒë‹¤ ê¸°ëŠ¥      | ë¬¸ë²•/í‚¤ì›Œë“œ           | íŠ¹ì§•                     |
| -------------- | --------------------- | ------------------------ |
| ê¸°ë³¸ ëŒë‹¤      | `[...](...) {...}`    | í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œ            |
| ìº¡ì²˜           | `[=], [&], [x], [&x]` | ì™¸ë¶€ ë³€ìˆ˜ ì ‘ê·¼ ì œì–´      |
| ê°€ë³€ ëŒë‹¤      | `mutable`             | ê°’ ìº¡ì²˜ëœ ë³€ìˆ˜ ìˆ˜ì • ê°€ëŠ¥ |
| ì œë„¤ë¦­ ëŒë‹¤    | `auto` ë§¤ê°œë³€ìˆ˜       | ë‹¤ì–‘í•œ íƒ€ì… ëŒ€ì‘         |
| ë°˜í™˜ íƒ€ì… ëª…ì‹œ | `-> return_type`      | ë³µì¡í•œ ë°˜í™˜ ì‹œ ì‚¬ìš©      |

### âœ… C++ ë²„ì „ë³„ ëŒë‹¤ ê¸°ëŠ¥ ë³€í™”

| ê¸°ëŠ¥                           | C++11 | C++14 | C++17 | C++20 |
| ------------------------------ | ----- | ----- | ----- | ----- |
| ê¸°ë³¸ ëŒë‹¤                      | âœ…     | âœ…     | âœ…     | âœ…     |
| `mutable`                      | âœ…     | âœ…     | âœ…     | âœ…     |
| `auto` ë§¤ê°œë³€ìˆ˜ (ì œë„¤ë¦­)       | âŒ     | âœ…     | âœ…     | âœ…     |
| ìº¡ì²˜ ì´ˆê¸°í™” (`[x = expr]`)     | âŒ     | âŒ     | âœ…     | âœ…     |
| ëŒë‹¤ í…œí”Œë¦¿ (`[]<typename T>`) | âŒ     | âŒ     | âŒ     | âœ…     |

### âœ… ê²°ë¡  ìš”ì•½

| í‚¤ì›Œë“œ      | ì„¤ëª…                             |
| ----------- | -------------------------------- |
| ëŒë‹¤ í•¨ìˆ˜   | ìµëª… í•¨ìˆ˜ ê°ì²´ ìƒì„±              |
| ìº¡ì²˜        | ì™¸ë¶€ ë³€ìˆ˜ ì ‘ê·¼ (`=`, `&`, `[x]`) |
| `mutable`   | ë³µì‚¬ ìº¡ì²˜ ë³€ìˆ˜ ìˆ˜ì • í—ˆìš©         |
| ì œë„¤ë¦­ ëŒë‹¤ | `auto` ë§¤ê°œë³€ìˆ˜ë¡œ ë‹¤í˜•ì„± ì§€ì›    |

## ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°, move semantics, rvalue ì°¸ì¡°

### âœ… 1. ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° (Smart Pointer)

#### ğŸ“Œ ê°œìš”

**ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°**ëŠ” ì¼ë°˜ í¬ì¸í„°(`T*`)ì²˜ëŸ¼ ì‚¬ìš©í•  ìˆ˜ ìˆì§€ë§Œ, **ë©”ëª¨ë¦¬ì˜ ìë™ í•´ì œë¥¼ ì§€ì›**í•˜ëŠ” ê°ì²´ì´ë‹¤.
 C++11 ì´í›„ë¶€í„°ëŠ” `std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr`ì´ í‘œì¤€í™”ë˜ì—ˆë‹¤.

#### ğŸ“Œ ì¢…ë¥˜ ë° ìš”ì•½

| ì´ë¦„                 | ê¸°ëŠ¥            | ì†Œìœ ê¶Œ | ìë™ í•´ì œ | ì°¸ì¡° ìˆ˜        |
| -------------------- | --------------- | ------ | --------- | -------------- |
| `std::unique_ptr<T>` | ë‹¨ë… ì†Œìœ        | âœ…      | âœ…         | 1              |
| `std::shared_ptr<T>` | ê³µìœ  ì†Œìœ        | âœ…      | âœ…         | â‰¥1             |
| `std::weak_ptr<T>`   | shared_ptr ì°¸ì¡° | âŒ      | âŒ         | 0 (non-owning) |

#### ğŸ“Œ ì˜ˆì‹œ

```
#include <memory>

std::unique_ptr<int> up = std::make_unique<int>(10);
std::shared_ptr<int> sp = std::make_shared<int>(20);
std::weak_ptr<int> wp = sp;
```

- `up`ì€ ì†Œìœ ê¶Œì´ ë‹¨ë…ì´ë¯€ë¡œ ë³µì‚¬ ë¶ˆê°€, ì´ë™ë§Œ ê°€ëŠ¥
- `sp`ëŠ” ì°¸ì¡° ì¹´ìš´íŒ…ìœ¼ë¡œ ê³µìœ ë¨
- `wp`ëŠ” `sp`ì˜ ìƒëª… ì£¼ê¸°ë¥¼ ì¶”ì í•˜ë˜ ì†Œìœ í•˜ì§€ ì•ŠìŒ

#### ğŸ“Œ ìë™ ì†Œë©¸

ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ëŠ” **RAII(Resource Acquisition Is Initialization)** ì›ì¹™ì„ ë”°ë¦„:

- ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚˜ë©´ `delete` ìë™ í˜¸ì¶œ
- ì˜ˆì™¸ ë°œìƒ ì‹œì—ë„ ëˆ„ìˆ˜ ì—†ìŒ

### âœ… 2. rvalue ì°¸ì¡° (`T&&`) â€“ C++11

#### ğŸ“Œ ì •ì˜

C++11ë¶€í„° ë„ì…ëœ **ìš°ì¸¡ê°’ ì°¸ì¡°(rvalue reference)**ëŠ”
 **ì„ì‹œ ê°ì²´(temporary object)**ì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë¬¸ë²•ì´ë‹¤.

```
void f(int&& x);  // xëŠ” ìš°ì¸¡ê°’ ì°¸ì¡°
```

| êµ¬ë¶„  | ì˜ë¯¸                           |
| ----- | ------------------------------ |
| `T&`  | ì¢Œì¸¡ê°’ ì°¸ì¡° (lvalue reference) |
| `T&&` | ìš°ì¸¡ê°’ ì°¸ì¡° (rvalue reference) |

#### ğŸ“Œ ì‚¬ìš© ëª©ì 

- **ì„ì‹œ ê°ì²´ì— ìì›ì„ â€œë¹¼ì•—ëŠ”(move)â€ ìš©ë„**
- **ë³µì‚¬ë³´ë‹¤ ë¹ ë¥´ê²Œ ìì›ì„ ì´ì „**

#### ğŸ“Œ rvalue ì˜ˆì‹œ

```
int x = 10;
int&& r = 5;         // OK: rvalue ì°¸ì¡°
int&& r2 = x + 3;    // OK: ì„ì‹œ ê°’ ì°¸ì¡°
// int&& r3 = x;     // âŒ: xëŠ” lvalue
```

### âœ… 3. ì´ë™ ì‹œë©˜í‹± (Move Semantics)

#### ğŸ“Œ ì •ì˜

**ì´ë™ ì‹œë©˜í‹±(Move Semantics)**ì€ ê°ì²´ì˜ **ì†Œìœ  ìì›(ë©”ëª¨ë¦¬, í¬ì¸í„° ë“±)ì„ ë³µì‚¬í•˜ì§€ ì•Šê³  'ì´ë™'**ì‹œì¼œ
 **ì„±ëŠ¥ì„ í¬ê²Œ í–¥ìƒ**ì‹œí‚¤ëŠ” ê¸°ë²•ì´ë‹¤.
 C++11 ì´í›„ ë³µì‚¬ ì—°ì‚°ì ì™¸ì— **ì´ë™ ìƒì„±ì / ì´ë™ ëŒ€ì… ì—°ì‚°ì**ê°€ ë„ì…ë˜ì—ˆë‹¤.

#### ğŸ“Œ ì´ë™ ìƒì„±ì / ëŒ€ì… ì—°ì‚°ì

```
class Buffer {
    int* data;
    size_t size;
public:
    Buffer(size_t n) : size(n), data(new int[n]) {}
    ~Buffer() { delete[] data; }

    // ì´ë™ ìƒì„±ì
    Buffer(Buffer&& other) noexcept
        : size(other.size), data(other.data) {
        other.data = nullptr;
        other.size = 0;
    }

    // ì´ë™ ëŒ€ì… ì—°ì‚°ì
    Buffer& operator=(Buffer&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            size = other.size;
            other.data = nullptr;
        }
        return *this;
    }
};
```

- ì´ë™ ì´í›„ `other` ê°ì²´ëŠ” **ë¹„ì›Œì§„ ìƒíƒœ(null)ë¡œ ì´ˆê¸°í™”**ë˜ì–´ì•¼ í•¨
- `noexcept` ì§€ì •ì€ STLê³¼ í•¨ê»˜ ì‚¬ìš©í•  ë•Œ í•„ìˆ˜ì 

#### ğŸ“Œ std::move

`std::move()`ëŠ” **lvalueë¥¼ rvalueë¡œ ìºìŠ¤íŒ…**í•˜ì—¬
 ì´ë™ ìƒì„±ì/ëŒ€ì… ì—°ì‚°ìê°€ ì‚¬ìš©ë˜ë„ë¡ ìœ ë„í•œë‹¤.

```
Buffer a(10);
Buffer b = std::move(a);  // aì˜ ìì›ì„ bë¡œ ì´ë™ (aëŠ” ë¹„ì›Œì§)
```

> `std::move()`ëŠ” ì§„ì§œ â€œì´ë™â€ì´ ì•„ë‹ˆë¼ **ì´ë™ ê°€ëŠ¥í•¨ì„ ë‚˜íƒ€ë‚´ëŠ” ëª…ì‹œì  íŒíŠ¸**

### âœ… 4. ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ì™€ ì´ë™ ì‹œë©˜í‹±

- `std::unique_ptr`ì€ ë³µì‚¬ ë¶ˆê°€, **ì´ë™ë§Œ ê°€ëŠ¥**
- ì´ë™ ì—°ì‚°ì„ í†µí•´ ì†Œìœ ê¶Œì„ **ì´ì „**í•  ìˆ˜ ìˆìŒ

```
std::unique_ptr<int> p1 = std::make_unique<int>(42);
std::unique_ptr<int> p2 = std::move(p1);  // p1 â†’ p2ë¡œ ì´ë™

// ì´í›„ p1ì€ null ìƒíƒœ
```

- `shared_ptr`ì€ ë³µì‚¬ ê°€ëŠ¥ (ì°¸ì¡° ì¹´ìš´íŠ¸ ì¦ê°€), ì´ë™ ì‹œ ì°¸ì¡° ì¹´ìš´íŠ¸ ì´ì „

### âœ… ê²°ë¡  ìš”ì•½

| ê¸°ëŠ¥             | ì„¤ëª…                     | ì£¼ìš” ëª©ì              |
| ---------------- | ------------------------ | --------------------- |
| `unique_ptr`     | ë‹¨ë… ì†Œìœ , ë³µì‚¬ ë¶ˆê°€     | ìì› ì•ˆì „ ê´€ë¦¬        |
| `shared_ptr`     | ì°¸ì¡° ì¹´ìš´íŠ¸ ê¸°ë°˜ ê³µìœ     | ê³µë™ ì†Œìœ              |
| `weak_ptr`       | `shared_ptr` ë¹„ì†Œìœ  ì°¸ì¡° | ìˆœí™˜ ì°¸ì¡° ë°©ì§€        |
| `T&&`            | rvalue ì°¸ì¡°              | ì„ì‹œ ê°ì²´ ëŒ€ìƒ ìµœì í™” |
| `std::move`      | lvalue â†’ rvalueë¡œ ìºìŠ¤íŒ… | ì´ë™ ìœ ë„             |
| ì´ë™ ìƒì„±ì/ëŒ€ì… | ìì› ì´ì „                | ë³µì‚¬ ë¹„ìš© ì ˆê°        |

### âœ… ì‹¤ì „ íŒ

- ë³µì‚¬ë³´ë‹¤ ë¹„ì‹¼ ìì›ì´ ìˆëŠ” í´ë˜ìŠ¤ëŠ” ë°˜ë“œì‹œ ì´ë™ ìƒì„±ìë¥¼ ì •ì˜í•˜ì
- `unique_ptr` ì‚¬ìš© ì‹œ ì´ë™ ì‹œë©˜í‹± í•„ìˆ˜
- `vector.emplace_back(std::move(obj));`ìœ¼ë¡œ ì„±ëŠ¥ ìµœì í™” ê°€ëŠ¥
- STL ì»¨í…Œì´ë„ˆë“¤ì€ ê°€ëŠ¥í•œ í•œ ì´ë™ ì—°ì‚°ì„ ì‚¬ìš©í•˜ë„ë¡ êµ¬í˜„ë˜ì–´ ìˆìŒ

## constexpr, decltype, static_assert

### âœ… 1. `constexpr` â€“ ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜ ì§€ì •

#### ğŸ“Œ ì •ì˜

`constexpr`ì€ **"ì»´íŒŒì¼ íƒ€ì„ì— ê³„ì‚° ê°€ëŠ¥í•œ ìƒìˆ˜"**ë¥¼ ì§€ì •í•˜ëŠ” í‚¤ì›Œë“œë‹¤.
 ë³€ìˆ˜, í•¨ìˆ˜, ìƒì„±ì, ë©¤ë²„ í•¨ìˆ˜ ë“±ì— ë¶™ì„ ìˆ˜ ìˆìœ¼ë©°,
 í•´ë‹¹ í‘œí˜„ì´ **ì»´íŒŒì¼ ì‹œê°„ì— ë°˜ë“œì‹œ í‰ê°€ë˜ì–´ì•¼ í•¨**ì„ ì˜ë¯¸í•œë‹¤.

#### ğŸ“Œ ì‚¬ìš© ì˜ˆì‹œ

```
constexpr int square(int x) {
    return x * x;
}

constexpr int val = square(5);  // ì»´íŒŒì¼ íƒ€ì„ì— ê³„ì‚°ë¨
```

#### ğŸ“Œ ë³€ìˆ˜ì— ëŒ€í•œ ì‚¬ìš©

```
constexpr int size = 10;
int arr[size];  // ì •ì  ë°°ì—´ í¬ê¸°ë¡œ ì‚¬ìš© ê°€ëŠ¥
```

> `const`ëŠ” ëŸ°íƒ€ì„ ìƒìˆ˜ì¼ ìˆ˜ ìˆì§€ë§Œ, `constexpr`ì€ **ë°˜ë“œì‹œ ì»´íŒŒì¼ ì‹œ í‰ê°€ë˜ì–´ì•¼ í•¨**

#### ğŸ“Œ C++14 ì´í›„ ê°œì„ 

- C++11: `constexpr` í•¨ìˆ˜ëŠ” **í•œ ì¤„ return ë¬¸ë§Œ í—ˆìš©**
- C++14: `if`, `for`, `switch` ë“± í¬í•¨ ê°€ëŠ¥ â†’ ì œí•œ ì™„í™”

```
constexpr int factorial(int n) {
    int result = 1;
    for (int i = 2; i <= n; ++i)
        result *= i;
    return result;
}
```

### âœ… 2. `decltype` â€“ íƒ€ì… ì¶”ë¡  (Type Deduction)

#### ğŸ“Œ ì •ì˜

`decltype(expr)`ì€ í‘œí˜„ì‹ `expr`ì˜ **ì •í™•í•œ íƒ€ì…ì„ ì»´íŒŒì¼ëŸ¬ê°€ ì¶”ë¡ í•˜ì—¬ ê·¸ íƒ€ì…ì„ ê°€ì ¸ì˜¤ëŠ” í‚¤ì›Œë“œ**ì´ë‹¤.
 `auto`ê°€ **ê°’ì„ ì¶”ë¡ **í•˜ëŠ” ë°˜ë©´, `decltype`ì€ **íƒ€ì…ì„ ì¶”ë¡ **í•œë‹¤.

#### ğŸ“Œ ì˜ˆì œ

```
int x = 10;
decltype(x) y = 20;  // yëŠ” int íƒ€ì…

auto f = [](int a, int b) { return a + b; };
decltype(f(1, 2)) z = 42;  // zëŠ” int
```

#### ğŸ“Œ ì°¸ì¡°/const ìœ ì§€

```
int a = 5;
int& ra = a;

decltype(ra) x = a;  // xëŠ” int& (ì°¸ì¡° ìœ ì§€)
```

> `auto`ëŠ” ì°¸ì¡°/const ì œê±°í•˜ì§€ë§Œ `decltype`ì€ ìœ ì§€

#### ğŸ“Œ í•¨ìˆ˜ ë°˜í™˜ íƒ€ì… ì¶”ë¡  ì‹œ ì‚¬ìš©

```
template<typename T1, typename T2>
auto add(T1 a, T2 b) -> decltype(a + b) {
    return a + b;
}
```

- C++11: trailing return type í•„ìˆ˜
- C++14: `auto`ë§Œìœ¼ë¡œë„ return type ì¶”ë¡  ê°€ëŠ¥

### âœ… 3. `static_assert` â€“ ì»´íŒŒì¼ íƒ€ì„ ê²€ì¦

#### ğŸ“Œ ì •ì˜

`static_assert`ëŠ” **ì»´íŒŒì¼ íƒ€ì„ ì¡°ê±´ ê²€ì‚¬ ë„êµ¬**ë¡œ,
 ì¡°ê±´ì´ `false`ì´ë©´ **ì»´íŒŒì¼ ì—ëŸ¬ë¥¼ ë°œìƒì‹œí‚´**
 (ëŸ°íƒ€ì„ì´ ì•„ë‹Œ ì •ì ìœ¼ë¡œ í™•ì¸ë˜ëŠ” íŠ¹ì§•)

#### ğŸ“Œ ë¬¸ë²•

```
static_assert(condition, "ì—ëŸ¬ ë©”ì‹œì§€");
```

#### ğŸ“Œ ì˜ˆì œ

```
static_assert(sizeof(int) == 4, "intëŠ” 4ë°”ì´íŠ¸ì—¬ì•¼ í•¨");

template<typename T>
void process(T t) {
    static_assert(std::is_integral<T>::value, "ì •ìˆ˜í˜• íƒ€ì…ë§Œ í—ˆìš©");
}
```

- ì£¼ë¡œ **í…œí”Œë¦¿ ë‚´ë¶€ì—ì„œ íƒ€ì… ì œì•½ ì¡°ê±´ì„ ëª…ì‹œí•  ë•Œ** ì‚¬ìš©
- STLê³¼ ê²°í•© ì‹œ **SFINAEë³´ë‹¤ ê°„ë‹¨í•œ ì œì•½ ë°©ì‹**ìœ¼ë¡œ ìœ ìš©

### âœ… ìš”ì•½ ë¹„êµí‘œ

| í‚¤ì›Œë“œ          | ì„¤ëª…                  | ì£¼ìš©ë„               | ë„ì…  |
| --------------- | --------------------- | -------------------- | ----- |
| `constexpr`     | ì»´íŒŒì¼ íƒ€ì„ ìƒìˆ˜      | í•¨ìˆ˜, ë³€ìˆ˜           | C++11 |
| `decltype`      | íƒ€ì… ì¶”ë¡              | íƒ€ì… ëª…ì‹œ, í•¨ìˆ˜ ë°˜í™˜ | C++11 |
| `static_assert` | ì»´íŒŒì¼ íƒ€ì„ ì¡°ê±´ ê²€ì‚¬ | íƒ€ì… ì œì•½, ìƒìˆ˜ ê²€ì¦ | C++11 |

### âœ… ì‹¤ì „ ì¡°í•© ì˜ˆì‹œ

```
template<typename T, typename U>
constexpr auto max(T a, U b) {
    static_assert(std::is_arithmetic<T>::value && std::is_arithmetic<U>::value,
                  "ìˆ«ì íƒ€ì…ë§Œ í—ˆìš©ë©ë‹ˆë‹¤");
    return (a > b) ? a : b;
}

auto result = max(3.14, 2);               // double ë°˜í™˜
decltype(result) x = 5.0;                 // xëŠ” double
```

### âœ… C++14~20 ê°œì„  ì‚¬í•­ ìš”ì•½

| ê¸°ëŠ¥                        | C++11 | C++14  | C++17+ |
| --------------------------- | ----- | ------ | ------ |
| `constexpr` í•¨ìˆ˜ ë³¸ë¬¸ ì œí•œ  | O     | ì™„í™”ë¨ | ê°•í™”ë¨ |
| `decltype(auto)` ì§€ì›       | âŒ     | âœ…      | âœ…      |
| `static_assert` ë©”ì‹œì§€ ìƒëµ | âŒ     | âœ…      | âœ…      |

### âœ… ë§ˆë¬´ë¦¬ ì •ë¦¬

| ìƒí™©                               | ì‚¬ìš©í•  í‚¤ì›Œë“œ                |
| ---------------------------------- | ---------------------------- |
| **ì»´íŒŒì¼ íƒ€ì„ì— ê³„ì‚°**             | `constexpr`                  |
| **í‘œí˜„ì‹ì˜ íƒ€ì… ì¶”ë¡ **             | `decltype(expr)`             |
| **ì¡°ê±´ì´ í‹€ë¦¬ë©´ ì»´íŒŒì¼ ì˜¤ë¥˜ ë°œìƒ** | `static_assert(cond, "msg")` |

## if constexpr, structured bindings, std::optional, std::variant

### âœ… 1. `if constexpr` â€“ ì»´íŒŒì¼ íƒ€ì„ ë¶„ê¸°

#### ğŸ“Œ ì •ì˜

`if constexpr`ì€ **ì¡°ê±´ì´ ì»´íŒŒì¼ ì‹œê°„ì— ê²°ì •ë˜ëŠ” ê²½ìš°ì—ë§Œ ë¶„ê¸°ë¬¸ì„ í™œì„±í™”**ì‹œí‚¨ë‹¤.
 ì¡°ê±´ì´ ê±°ì§“ì´ë©´ **í•´ë‹¹ ë¶„ê¸°ì˜ ì½”ë“œëŠ” ì»´íŒŒì¼ ëŒ€ìƒì—ì„œ ì œê±°**ëœë‹¤.

#### ğŸ“Œ ì˜ˆì œ

```
template<typename T>
void print_type(T value) {
    if constexpr (std::is_integral<T>::value) {
        std::cout << "ì •ìˆ˜í˜•: " << value << '\n';
    } else {
        std::cout << "ì •ìˆ˜í˜• ì•„ë‹˜\n";
    }
}
```

- `if constexpr`ì„ ì‚¬ìš©í•˜ë©´ **ì»´íŒŒì¼ íƒ€ì„ ì¡°ê±´ ë¶„ê¸°**ê°€ ê°€ëŠ¥í•˜ë¯€ë¡œ,
   ë¶ˆí•„ìš”í•œ ì½”ë“œ ê²½ë¡œëŠ” ì»´íŒŒì¼ì¡°ì°¨ ë˜ì§€ ì•Šì•„ **SFINAEë³´ë‹¤ ëª…í™•í•˜ê³  ì•ˆì „**

### âœ… 2. êµ¬ì¡° ë¶„í•´ í• ë‹¹ (Structured Bindings)

#### ğŸ“Œ ì •ì˜

`structured bindings`ëŠ” **íŠœí”Œ, êµ¬ì¡°ì²´, ë°°ì—´ ë“±ì˜ ë³µí•© ìë£Œí˜•ì˜ ë©¤ë²„ë¥¼ í•œ ë²ˆì— ë¶„í•´í•´ì„œ ë³€ìˆ˜ë¡œ ë°›ëŠ” ë¬¸ë²•**ì´ë‹¤.

#### ğŸ“Œ ë¬¸ë²•

```
auto [a, b] = std::make_pair(1, 2);
```

- `a = 1`, `b = 2`ë¡œ ê°ê° ì´ˆê¸°í™”ë¨

#### ğŸ“Œ ì˜ˆì œ

```
std::map<std::string, int> scores = {{"math", 90}, {"eng", 80}};
for (const auto& [subject, score] : scores) {
    std::cout << subject << ": " << score << '\n';
}
```

- ë°˜ë³µì ê°’ì´ `std::pair<const Key, Value>`ì¸ ê²½ìš°ì—ë„ **ê°„ë‹¨í•˜ê²Œ ë¶„í•´ ê°€ëŠ¥**

#### ğŸ“Œ êµ¬ì¡°ì²´ì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥

```
struct Point { int x; int y; };
Point p{10, 20};
auto [x, y] = p;  // x = 10, y = 20
```

### âœ… 3. `std::optional<T>` â€“ ê°’ì´ ìˆì„ ìˆ˜ë„, ì—†ì„ ìˆ˜ë„ ìˆìŒ

#### ğŸ“Œ ì •ì˜

`std::optional<T>`ëŠ” **T íƒ€ì…ì˜ ê°’ì´ ìˆê±°ë‚˜ ì—†ìŒì„ ëª…ì‹œì ìœ¼ë¡œ í‘œí˜„**í•˜ëŠ” ì»¨í…Œì´ë„ˆë‹¤.
 **í¬ì¸í„° ì—†ì´ null ìƒíƒœë¥¼ í‘œí˜„**í•˜ë©°, ê°’ì˜ ìœ ë¬´ë¥¼ ì•ˆì „í•˜ê²Œ ë‹¤ë£° ìˆ˜ ìˆë‹¤.

#### ğŸ“Œ í—¤ë”

```
#include <optional>
```

#### ğŸ“Œ ì‚¬ìš© ì˜ˆì œ

```
std::optional<int> find_even(int x) {
    if (x % 2 == 0)
        return x;
    else
        return std::nullopt;
}

auto result = find_even(5);
if (result)
    std::cout << "ì§ìˆ˜: " << *result << '\n';
else
    std::cout << "ì—†ìŒ\n";
```

#### ğŸ“Œ ì£¼ìš” í•¨ìˆ˜

| í•¨ìˆ˜            | ì„¤ëª…                  |
| --------------- | --------------------- |
| `has_value()`   | ê°’ ì¡´ì¬ ì—¬ë¶€ í™•ì¸     |
| `value()`       | ê°’ ë°˜í™˜ (ì—†ìœ¼ë©´ ì˜ˆì™¸) |
| `operator*`     | ì—­ì°¸ì¡°í•˜ì—¬ ê°’ ì ‘ê·¼    |
| `value_or(def)` | ì—†ì„ ê²½ìš° ê¸°ë³¸ê°’ ë°˜í™˜ |

### âœ… 4. `std::variant<Ts...>` â€“ ì•ˆì „í•œ ë‹¤í˜•ì„± íƒ€ì…

#### ğŸ“Œ ì •ì˜

`std::variant`ëŠ” **ë‘˜ ì´ìƒì˜ íƒ€ì… ì¤‘ í•˜ë‚˜ë§Œ ê°€ì§ˆ ìˆ˜ ìˆëŠ” íƒ€ì… ì•ˆì „í•œ ìœ ë‹ˆì–¸**ì´ë‹¤.
 `union`ë³´ë‹¤ ì•ˆì „í•˜ë©°, **í˜„ì¬ ë³´ê´€ëœ íƒ€ì…ì„ ì»´íŒŒì¼ëŸ¬ê°€ ì¶”ì  ê°€ëŠ¥**í•˜ë‹¤.

#### ğŸ“Œ í—¤ë”

```
#include <variant>
```

#### ğŸ“Œ ê¸°ë³¸ ì˜ˆì œ

```
std::variant<int, std::string> data;
data = 10;
data = std::string("Hello");
```

#### ğŸ“Œ í˜„ì¬ íƒ€ì… í™•ì¸

```
if (std::holds_alternative<std::string>(data)) {
    std::cout << std::get<std::string>(data) << '\n';
}
```

- `std::get<T>(variant)`ì€ **T íƒ€ì…ì´ í˜„ì¬ ë³´ê´€ëœ íƒ€ì…ì¼ ë•Œë§Œ** ê°€ëŠ¥
- ì˜ëª»ëœ íƒ€ì… ì ‘ê·¼ ì‹œ `std::bad_variant_access` ì˜ˆì™¸ ë°œìƒ

#### ğŸ“Œ `std::visit` â€“ í•¨ìˆ˜ ë””ìŠ¤íŒ¨ì¹˜

```
std::variant<int, std::string> v = "Hello"s;

std::visit([](auto&& val) {
    std::cout << "ê°’: " << val << '\n';
}, v);
```

- **ëª¨ë“  íƒ€ì…ì— ëŒ€í•´ ëŒë‹¤ í•¨ìˆ˜ê°€ ìë™ìœ¼ë¡œ ë¶„ê¸°**
- **Generic lambda**ì™€ í•¨ê»˜ ì“°ë©´ ê°„ë‹¨íˆ êµ¬í˜„ ê°€ëŠ¥

### âœ… ë¹„êµ ìš”ì•½

| ê¸°ëŠ¥                  | ì„¤ëª…                           | ì˜ˆì‹œ              |
| --------------------- | ------------------------------ | ----------------- |
| `if constexpr`        | ì»´íŒŒì¼ íƒ€ì„ ë¶„ê¸°               | í…œí”Œë¦¿ ì¡°ê±´ ë¶„ê¸°  |
| `structured bindings` | ë³µí•© ê°ì²´ ë¶„í•´                 | `auto [x, y] = p` |
| `std::optional<T>`    | ê°’ì´ ì—†ì„ ìˆ˜ë„ ìˆìŒ            | null ëŒ€ì²´         |
| `std::variant<Ts...>` | íƒ€ì… ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒì ìœ¼ë¡œ ì €ì¥ | ì•ˆì „í•œ ìœ ë‹ˆì–¸     |

### âœ… ë§ˆë¬´ë¦¬ ì •ë¦¬

| í‚¤ì›Œë“œ / íƒ€ì…         | ì£¼ìš” ëª©ì                                 |
| --------------------- | ---------------------------------------- |
| `if constexpr`        | ì¡°ê±´ë¶€ ì»´íŒŒì¼ ë¶„ê¸°                       |
| êµ¬ì¡° ë¶„í•´ í• ë‹¹        | íŠœí”Œ/êµ¬ì¡°ì²´ë¥¼ ë³€ìˆ˜ë¡œ ë¶„í•´                |
| `std::optional<T>`    | "ê°’ì´ ìˆì„ ìˆ˜ë„ ì—†ìŒ" í‘œí˜„               |
| `std::variant<Ts...>` | ì—¬ëŸ¬ íƒ€ì… ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒ, íƒ€ì… ì•ˆì „ ë³´ì¥ |

## Concepts, Coroutines, Modules

### âœ… 1. Concepts â€“ í…œí”Œë¦¿ ì œì•½ ì¡°ê±´

#### ğŸ“Œ ê°œìš”

**Concepts**ëŠ” **í…œí”Œë¦¿ íƒ€ì… ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ ì œì•½ ì¡°ê±´ì„ ëª…ì‹œ**í•˜ëŠ” ê¸°ëŠ¥ì´ë‹¤.
 ê¸°ì¡´ì˜ SFINAE, `enable_if`, `type_traits` ê¸°ë°˜ ì¡°ê±´ì‹ì„ **ëª…í™•í•˜ê²Œ ëŒ€ì²´**í•œë‹¤.

#### ğŸ“Œ ì •ì˜ ë° ì˜ˆì œ

```
template<typename T>
concept Incrementable = requires(T x) {
    ++x;
    x++;
};

template<Incrementable T>
void increment_all(std::vector<T>& v) {
    for (auto& x : v)
        ++x;
}
```

- `Incrementable`ì€ **Tê°€ `++` ì—°ì‚°ì„ ì§€ì›í•˜ëŠ” íƒ€ì…ì„ì„ ëª…ì‹œ**
- `requires` í‘œí˜„ì‹ì€ ì»´íŒŒì¼ íƒ€ì„ì— **í˜•ì‹ ìœ íš¨ì„± ê²€ì‚¬**ë¥¼ ìˆ˜í–‰

#### ğŸ“Œ ê¸°ë³¸ ì œê³µ Concepts

| ì´ë¦„                         | ì¡°ê±´               |
| ---------------------------- | ------------------ |
| `std::integral`              | ì •ìˆ˜í˜• íƒ€ì…        |
| `std::floating_point`        | ë¶€ë™ì†Œìˆ˜ì  íƒ€ì…    |
| `std::same_as<T>`            | íƒ€ì… ì¼ì¹˜          |
| `std::derived_from<T>`       | ìƒì† ê´€ê³„          |
| `std::invocable<F, Args...>` | í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œ ê°€ëŠ¥ |

```
template<std::integral T>
void foo(T x) { /* ì •ìˆ˜ë§Œ í—ˆìš© */ }
```

#### ğŸ“Œ requires ì ˆ ì‚¬ìš© ë°©ì‹

```
template<typename T>
requires std::is_copy_constructible_v<T>
void process(const T& x);
```

> `requires` ì ˆì€ **í•¨ìˆ˜ ì„ ì–¸ ë’¤ì—ë„ ìœ„ì¹˜ ê°€ëŠ¥**

### âœ… 2. Coroutines â€“ í˜‘ë ¥í˜• í•¨ìˆ˜(ë¹„ë™ê¸° íë¦„)

#### ğŸ“Œ ê°œìš”

**Coroutine(ì½”ë£¨í‹´)**ì€ **í•¨ìˆ˜ ì‹¤í–‰ì„ ì¤‘ë‹¨í•˜ê³  ë‹¤ì‹œ ì´ì–´ì„œ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ í˜•íƒœ**ë‹¤.
 `co_yield`, `co_return`, `co_await` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ **ë¹„ë™ê¸° ì²˜ë¦¬, ì§€ì—° í‰ê°€, ë°˜ë³µì ìƒì„±** ë“±ì— ì‚¬ìš©ëœë‹¤.

#### ğŸ“Œ í‚¤ì›Œë“œ ìš”ì•½

| í‚¤ì›Œë“œ      | ì„¤ëª…                                    |
| ----------- | --------------------------------------- |
| `co_return` | ê°’ì„ ë°˜í™˜í•˜ë©° ì¢…ë£Œ                      |
| `co_yield`  | í˜„ì¬ ê°’ì„ ë°˜í™˜í•˜ê³  ì¼ì‹œ ì¤‘ë‹¨            |
| `co_await`  | ë¹„ë™ê¸° ê°ì²´ì˜ ì™„ë£Œë¥¼ ëŒ€ê¸°í•˜ê³  ì¼ì‹œ ì¤‘ë‹¨ |

#### ğŸ“Œ ì˜ˆì œ: generator

```
#include <coroutine>
#include <iostream>

template<typename T>
struct Generator {
    struct promise_type {
        T value;
        std::suspend_always yield_value(T val) {
            value = val;
            return {};
        }
        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        Generator get_return_object() {
            return Generator{std::coroutine_handle<promise_type>::from_promise(*this)};
        }
        void return_void() {}
        void unhandled_exception() {}
    };

    std::coroutine_handle<promise_type> handle;
    Generator(std::coroutine_handle<promise_type> h) : handle(h) {}
    ~Generator() { if (handle) handle.destroy(); }

    bool next() { return handle.resume(), !handle.done(); }
    T current_value() { return handle.promise().value; }
};

Generator<int> counter(int max) {
    for (int i = 0; i < max; ++i)
        co_yield i;
}

int main() {
    auto gen = counter(3);
    while (gen.next())
        std::cout << gen.current_value() << '\n';
}
```

#### ğŸ“Œ í™œìš© ë¶„ì•¼

- `std::generator<T>`: ì§€ì—° ë°˜ë³µì
- `co_await`: `std::future`, `asio` ê¸°ë°˜ ë¹„ë™ê¸° ë„¤íŠ¸ì›Œí¬
- ë²”ìš© ìƒíƒœê¸°ë°˜ íë¦„ ì œì–´

### âœ… 3. Modules â€“ ëª¨ë“ˆí™”ëœ ì½”ë“œ ì»´íŒŒì¼ ë‹¨ìœ„

#### ğŸ“Œ ê°œìš”

**Modules**ëŠ” ê¸°ì¡´ì˜ `#include` ê¸°ë°˜ í—¤ë” ì‹œìŠ¤í…œì„ ëŒ€ì²´í•˜ëŠ” **ìƒˆë¡œìš´ ì¸í„°í˜ì´ìŠ¤ ì„ ì–¸ ë°©ì‹**ì´ë‹¤.
 **ì¤‘ë³µ í¬í•¨ ë°©ì§€, ë¹ ë¥¸ ë¹Œë“œ, ëª…í™•í•œ ì˜ì¡´ì„±**ì„ ì œê³µí•œë‹¤.

#### ğŸ“Œ ê¸°ë³¸ êµ¬ì„±

**ëª¨ë“ˆ ì¸í„°í˜ì´ìŠ¤ íŒŒì¼ (`.ixx`)**

```
cppì½”ë“œ ë³µì‚¬export module math;

export int add(int a, int b) {
    return a + b;
}
```

**ì‚¬ìš© ì¸¡ íŒŒì¼**

```
import math;

int main() {
    std::cout << add(3, 4);
}
```

#### ğŸ“Œ í•µì‹¬ í‚¤ì›Œë“œ

| í‚¤ì›Œë“œ   | ì„¤ëª…                       |
| -------- | -------------------------- |
| `module` | ëª¨ë“ˆ ì •ì˜ ì‹œì‘             |
| `export` | ì™¸ë¶€ì— ë…¸ì¶œí•  í•¨ìˆ˜, í´ë˜ìŠ¤ |
| `import` | ëª¨ë“ˆ ê°€ì ¸ì˜¤ê¸°              |

#### ğŸ“Œ ì¥ì 

| í•­ëª©          | ê°œì„ ì                               |
| ------------- | ----------------------------------- |
| ë¹Œë“œ ì„±ëŠ¥     | `#include` ì œê±° â†’ íŒŒì‹± ì†ë„ ê°œì„     |
| ëª…í™•í•œ ì˜ì¡´ì„± | `import` ê¸°ë°˜                       |
| ì¬ì‚¬ìš©ì„±      | ì¤‘ë³µ ì •ì˜ ë°©ì§€, ë§í¬ ì¶©ëŒ ìµœì†Œí™”    |
| ë³´ì•ˆì„±        | ë‚´ë¶€ êµ¬í˜„ ìˆ¨ê¹€ ê°€ëŠ¥ (`export` ì œì™¸) |

#### ğŸ“Œ ì£¼ì˜ì‚¬í•­

- ëª¨ë“  ì»´íŒŒì¼ëŸ¬ê°€ ì•„ì§ ì™„ì „í•œ module ì§€ì›ì„ ê°–ì¶”ì§€ ì•ŠìŒ
- ë¹Œë“œ ì‹œìŠ¤í…œ(CMake ë“±) ì„¤ì • í•„ìš”
- `.cppm`, `.ixx`, `.mpp` í™•ì¥ìê°€ ì‚¬ìš©ë¨

### âœ… ë§ˆë¬´ë¦¬ ìš”ì•½

| ê¸°ëŠ¥         | ì„¤ëª…                              | ëª©ì                    |
| ------------ | --------------------------------- | ---------------------- |
| `concepts`   | í…œí”Œë¦¿ ì œì•½ì„ ëª…ì‹œì ìœ¼ë¡œ ì •ì˜     | íƒ€ì… ì•ˆì „ ê°•í™”         |
| `coroutines` | ì¤‘ë‹¨/ì¬ê°œ ê°€ëŠ¥í•œ í•¨ìˆ˜ íë¦„        | ë¹„ë™ê¸°, ë°˜ë³µê¸°         |
| `modules`    | `#include` ëŒ€ì²´, ì»´íŒŒì¼ ë‹¨ìœ„ ë¶„ë¦¬ | ë¹ ë¥¸ ë¹Œë“œ, ì˜ì¡´ì„± ê´€ë¦¬ |

