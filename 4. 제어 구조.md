# 4. 제어 구조

## 조건문 (if, if-else, switch)

C++의 조건문은 프로그램의 실행 흐름을 조건에 따라 분기시키는 핵심 구조다. `if`, `if-else`, `else if`, `switch`문을 통해 **조건에 따라 실행할 코드 블록을 선택**할 수 있다.
 모든 조건식은 `bool` 타입으로 평가되며, 0은 `false`, 0이 아닌 값은 `true`로 간주된다.

### 📌 `if` 문

**조건이 참일 경우에만 코드 블록을 실행**한다.

```
int age = 20;

if (age >= 18) {
    std::cout << "성인입니다.\n";
}
```

- 조건식에는 비교 연산자(`==`, `!=`, `<`, `>`, ...)와 논리 연산자(`&&`, `||`, `!`)가 사용됨
- 중괄호 `{}`는 생략 가능하지만, 단일 줄일 때만 사용하고 습관적으로 명시하는 것이 좋다

### 📌 `if-else` 문

**조건이 참일 경우와 거짓일 경우에 대해 각각 다른 코드 블록**을 실행한다.

```
if (score >= 60) {
    std::cout << "합격\n";
} else {
    std::cout << "불합격\n";
}
```

### 📌 `else if` 문

**여러 조건을 순차적으로 검사**하고, **첫 번째로 참인 조건에 해당하는 블록만 실행**한다.

```
if (score >= 90) {
    std::cout << "A\n";
} else if (score >= 80) {
    std::cout << "B\n";
} else if (score >= 70) {
    std::cout << "C\n";
} else {
    std::cout << "F\n";
}
```

### 📌 `switch` 문

**단일 정수/열거형 표현식의 결과에 따라 분기**할 수 있는 구조. `case`로 분기를 구성하며, `default`는 어느 조건도 만족하지 않을 때 실행된다.

```
int level = 2;

switch (level) {
    case 1:
        std::cout << "초급\n";
        break;
    case 2:
        std::cout << "중급\n";
        break;
    case 3:
        std::cout << "고급\n";
        break;
    default:
        std::cout << "알 수 없음\n";
}
```

- `break`를 생략하면 다음 case로 **fall-through** 된다.
- 조건식은 반드시 **정수형 또는 enum형 상수여야 함**
- `string`은 `switch` 조건으로 사용할 수 없음 (컴파일 에러)

### 📌 `switch` vs `if` 차이

| 항목      | `if`, `else if`, `else`        | `switch`                       |
| --------- | ------------------------------ | ------------------------------ |
| 조건 타입 | `bool` 결과를 내는 모든 조건식 | 정수형/열거형 상수 값만 가능   |
| 범위      | 다양한 조건 및 범위 가능       | 정확히 일치하는 값 비교만 가능 |
| 확장성    | 조건식 자유로움                | 키 값에 따라만 분기됨          |
| 가독성    | 복잡한 조건에 적합             | 단일 값 비교 시 간결함         |

### 📎 예제: `switch`로 요일 출력

```
int day = 3;

switch (day) {
    case 1: std::cout << "월요일"; break;
    case 2: std::cout << "화요일"; break;
    case 3: std::cout << "수요일"; break;
    case 4: std::cout << "목요일"; break;
    case 5: std::cout << "금요일"; break;
    default: std::cout << "주말";
}
```

### 📌 주의 사항

- `switch`에서 `case`는 중복될 수 없고, 반드시 **정수형 리터럴** 또는 **열거형 상수**여야 한다.
- `if constexpr` (C++17 이후): **컴파일 타임 조건 분기**에 사용되며, 템플릿 메타프로그래밍에서 유용하다.
- `break`를 빠뜨리면 다음 case로 계속 실행된다 (원하지 않는 fall-through 주의).

조건문은 **제어 흐름의 핵심**이며, 프로그램의 논리를 설계하는 데 가장 많이 쓰이는 구조다. 간단한 조건엔 `if`, 복잡한 다중 분기에는 `else if`, 값 기반 선택에는 `switch`, 컴파일 타임 분기에는 `if constexpr`을 사용하는 것이 이상적인 설계다.

## 반복문 (for, while, do-while)

반복문은 **조건이 참인 동안 특정 코드 블록을 반복 실행**하는 제어 구조다.
 C++에서는 세 가지 기본 반복문을 제공한다:

1. `for` — 반복 횟수가 정해진 경우
2. `while` — 조건 기반 반복
3. `do-while` — 최소 1회 실행 보장

### 📌 `for` 반복문

**반복 횟수가 명확한 경우**에 사용.
 구성:

```
for (초기식; 조건식; 증감식) {
    // 반복할 코드
}
```

예시:

```
for (int i = 0; i < 5; ++i) {
    std::cout << "i = " << i << "\n";
}
```

- 초기식: 한 번만 실행
- 조건식: 반복 여부 결정 (false가 되면 종료)
- 증감식: 각 반복 이후 실행

> 여러 제어변수도 쉼표 연산자를 사용하여 동시에 제어 가능

```
for (int i = 0, j = 10; i < j; ++i, --j) {
    std::cout << i << " + " << j << "\n";
}
```

### 📌 범위 기반 `for` (C++11 이후)

컨테이너 요소들을 순회할 때 사용.

```
std::vector<int> nums = {1, 2, 3, 4, 5};

for (int n : nums) {
    std::cout << n << " ";
}
```

- `const` 참조로 성능 최적화 가능: `for (const auto& x : container)`
- 수정이 필요한 경우 참조로 사용: `for (auto& x : container)`

### 📌 `while` 반복문

**조건이 참이면 계속 반복**
 조건 확인 → 반복 실행

```
int i = 0;
while (i < 5) {
    std::cout << i << "\n";
    ++i;
}
```

- 반복 횟수를 알 수 없거나, **조건에 따라 유동적인 반복**이 필요한 경우 적합
- 조건식이 처음부터 false면 **한 번도 실행되지 않을 수 있음**

### 📌 `do-while` 반복문

**최소 한 번은 실행됨**

```
int i = 0;
do {
    std::cout << i << "\n";
    ++i;
} while (i < 5);
```

- `while`과의 차이: 조건식이 **뒤에** 있기 때문에 무조건 첫 1회 실행
- 주로 **사용자 입력 → 검증 → 반복 요구** 등의 흐름에 적합

### 📌 루프 제어문

| 키워드     | 기능                                    |
| ---------- | --------------------------------------- |
| `break`    | 루프 즉시 종료                          |
| `continue` | 현재 반복을 건너뛰고 다음 반복으로 이동 |

예시:

```
for (int i = 0; i < 10; ++i) {
    if (i == 5) break;         // 0~4까지만 출력
    if (i % 2 == 0) continue;  // 짝수 건너뜀
    std::cout << i << "\n";    // 홀수만 출력
}
```

### 📎 반복문 비교 요약

| 반복문     | 조건 확인 위치 | 최소 실행 횟수 | 주 용도                         |
| ---------- | -------------- | -------------- | ------------------------------- |
| `for`      | 시작 시        | 0회 이상       | 반복 횟수 명확한 경우           |
| `while`    | 시작 시        | 0회 이상       | 조건 기반 반복                  |
| `do-while` | 끝에서         | 1회 이상       | 사용자 입력/검증 루프 등에 적합 |

### 📌 무한 루프

조건을 항상 true로 설정해 **무한 루프** 생성 가능:

```
while (true) {
    // 종료 조건은 내부에 작성
    if (종료조건) break;
}
```

C++20부터는 `ranges::views::iota` 등 **범위 기반 무한 시퀀스**도 등장

**반복문은 프로그램의 핵심 흐름 제어 수단이며, 조건, 반복 횟수, 루프 탈출 조건 등을 어떻게 설계하느냐에 따라 전체 알고리즘의 품질이 달라진다.**

모든 반복은 **종료 조건이 반드시 존재해야 하며**, 성능이 중요한 경우 **중첩 반복문, 컨테이너 접근 방식, 루프 불변식 최적화** 등을 함께 고려해야 한다.

## break, continue, goto 문

C++에서 `break`, `continue`, `goto`는 **흐름 제어문(flow control statement)**로, 반복문이나 조건문의 흐름을 **비정상적이거나 예외적으로 조작**할 때 사용된다.
 정상적인 구조 제어가 어려운 경우 유용하지만, **남용하면 가독성과 유지보수성에 해로울 수 있으므로 신중한 사용이 요구된다.**

### 📌 `break` 문

`break`는 **현재 반복문(for, while, do-while) 또는 switch문을 즉시 빠져나가는 명령**이다.

#### 사용 예시:

```
for (int i = 0; i < 10; ++i) {
    if (i == 5) break;
    std::cout << i << " ";
}
// 출력: 0 1 2 3 4
```

#### 특징:

- **가장 가까운 반복문 또는 switch 문만 종료**
- 중첩 루프에서는 **루프별로 하나씩만 빠져나감**

### 📌 `continue` 문

`continue`는 **현재 반복의 남은 부분을 건너뛰고, 다음 반복을 즉시 시작**하게 한다.

#### 사용 예시:

```
for (int i = 0; i < 5; ++i) {
    if (i == 2) continue;
    std::cout << i << " ";
}
// 출력: 0 1 3 4
```

#### 특징:

- `while`/`do-while`에서는 조건식으로 바로 이동
- `for`문에서는 증감식으로 이동 후 조건 평가

### 📌 `goto` 문 🚨 *(주의 요망)*

`goto`는 **임의의 레이블(label)로 프로그램 흐름을 직접 이동**시킨다.
 대부분의 경우 **구조적 프로그래밍(structured programming)** 원칙에 어긋나며, **사용은 거의 권장되지 않는다.**

#### 문법:

```
goto 레이블;

...

레이블:
    // 이동할 위치
```

#### 예시:

```
int x = 0;

loop_start:
if (x < 5) {
    std::cout << x << " ";
    ++x;
    goto loop_start;
}
```

- 출력: `0 1 2 3 4`
- 비슷한 결과를 얻을 수 있는 `while` 루프가 훨씬 가독성이 좋음

#### 일반적인 사용 사례:

- **에러 핸들링 (자원 정리)**
   드물게 복잡한 함수 내 자원 정리 시점으로 이동할 때 `goto cleanup:` 등으로 사용

### 📎 비교 요약

| 문장       | 용도                              | 사용 위치                  | 특징                            |
| ---------- | --------------------------------- | -------------------------- | ------------------------------- |
| `break`    | 반복문/`switch` 문 종료           | `for`, `while`, `switch`   | 현재 블록을 즉시 탈출           |
| `continue` | 현재 반복 건너뛰고 다음 반복 실행 | `for`, `while`, `do-while` | 아래 코드 건너뜀                |
| `goto`     | 코드 흐름을 임의 위치로 점프      | 전체 함수 내부 어디든 가능 | **비권장**, 구조 흐름 파괴 위험 |

### ✅ 모범 사용 예

- `break`는 검색 알고리즘 종료 지점 등에서 유용
- `continue`는 입력값 필터링 등에서 깔끔하게 사용 가능
- `goto`는 가능한 한 **대체 구조(if-return, loop-break, 함수 분할 등)**를 먼저 고려해야 한다

**요약하자면**, `break`와 `continue`는 구조적 프로그래밍 내에서 안전하게 사용할 수 있는 흐름 제어 수단이지만, `goto`는 거의 모든 상황에서 **가독성과 디버깅을 해치는 위험 요소**로 간주된다.
 현대 C++에서는 **명확한 루프 구조와 함수 분할을 통한 제어 흐름 구성이 가장 권장되는 방식**이다.

## 중첩 제어문

**중첩 제어문(nested control structures)**은 조건문, 반복문 등의 제어 구조가 **다른 제어 구조 안에 포함된 형태**를 말한다. 이를 통해 **복잡한 조건과 다단계 처리 로직을 구현**할 수 있다.
 C++에서는 `if`, `switch`, `for`, `while`, `do-while` 등의 제어문을 자유롭게 서로 안에 넣을 수 있으며, **중첩의 깊이에 제한은 없지만, 가독성과 유지보수 측면에서 제한하는 것이 바람직하다.**

### 📌 중첩 조건문 예제

```
int score = 85;

if (score >= 60) {
    if (score >= 90) {
        std::cout << "A\n";
    } else if (score >= 80) {
        std::cout << "B\n";
    } else {
        std::cout << "C\n";
    }
} else {
    std::cout << "F\n";
}
```

- `if` 블록 안에 또 다른 `if-else` 블록이 들어간 구조
- 들여쓰기와 중괄호 사용은 **명확하게 구분**되도록 작성해야 함

### 📌 중첩 반복문 예제

```
for (int i = 1; i <= 3; ++i) {
    for (int j = 1; j <= 2; ++j) {
        std::cout << "i = " << i << ", j = " << j << "\n";
    }
}
```

- 외부 반복이 3번, 내부 반복이 2번 실행 → 총 6번 출력
- 흔히 **2차원 배열 처리**, **표 출력**, **중복 조합 탐색** 등에 사용

### 📌 중첩 반복 + 조건문

```
for (int i = 0; i < 5; ++i) {
    if (i % 2 == 0) {
        std::cout << i << " is even\n";
    } else {
        std::cout << i << " is odd\n";
    }
}
```

- 반복 구조 안에 조건 분기를 넣어 다양한 조건별 처리 가능

### 📌 중첩 switch (주의)

C++에서 `switch` 문 안에 또 다른 `switch`를 중첩할 수 있다.

```
int x = 1, y = 2;

switch (x) {
    case 1:
        switch (y) {
            case 1: std::cout << "x=1, y=1\n"; break;
            case 2: std::cout << "x=1, y=2\n"; break;
        }
        break;
}
```

- `case` 충돌, `break` 누락 등 실수가 많아 **사용 시 주의 필요**

### 📎 중첩 제어문의 주의점

| 문제 상황            | 설명                                                   | 해결 방법                           |
| -------------------- | ------------------------------------------------------ | ----------------------------------- |
| 중복된 들여쓰기      | 깊어질수록 코드 가독성이 떨어짐                        | 함수 분할, 조건 추출                |
| `else` 매칭 오류     | 중괄호 미사용 시 `else`가 잘못된 `if`와 연결될 수 있음 | 항상 `{}` 명시 사용                 |
| 무한 루프 발생       | 내부 루프의 탈출 조건 누락 시 외부까지 멈추지 않음     | 정확한 `break`, `return` 설계 필요  |
| `goto`, `break` 혼동 | 여러 단계 루프에서 `break`가 어디에 적용되는지 혼동    | 중첩 구조 단순화 또는 레이블 명확화 |

### ✅ 중첩 제어문의 구조적 정리 방법

1. **각 제어문마다 명확한 역할을 부여**할 것
2. **함수 단위로 분할**하여 깊이 감소
3. 중첩 조건은 **가드 조건(early return)**을 통해 평평하게 만들기
4. 가능한 경우 **switch → map or polymorphism**으로 전환
5. 반복문 중첩 시, 각 반복이 다루는 **차원을 명확히 명명**

### 요약

- 중첩 제어문은 복잡한 상황을 세분화 처리할 수 있는 강력한 도구다.
- 하지만 깊어질수록 **가독성, 디버깅, 유지보수 난이도**가 상승하므로 구조적 설계가 매우 중요하다.
- **함수화, 조건 명확화, 루프 최소화**를 통해 중첩 제어문을 정돈된 코드로 유지하는 것이 핵심이다.