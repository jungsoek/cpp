# 5. 함수

## 함수 정의, 선언, 호출

C++에서 함수(function)는 **하나의 작업(기능)을 수행하는 코드 블록**이다. 함수를 사용하면 **코드를 재사용하고, 구조화하며, 유지보수성을 향상**시킬 수 있다.
 C++ 함수는 반드시 **정의(Definition)** 되어 있어야 하고, **선언(Declaration)** 을 통해 호출 전에 알려주거나, **정의와 선언을 분리하여 모듈화**할 수도 있다.

### 📌 1. 함수 정의 (Function Definition)

함수를 실제로 구현한 코드 블록이다.
 형식:

```
반환형 함수이름(매개변수목록) {
    // 함수 본문 (구현부)
}
```

예시:

```
int add(int a, int b) {
    return a + b;
}
```

- `int`: 반환형 (return type)
- `add`: 함수 이름
- `(int a, int b)`: 매개변수(parameter)
- `return a + b;`: 결과 반환

### 📌 2. 함수 선언 (Function Declaration, 또는 함수 프로토타입)

함수의 **시그니처만 알려주는 선언부**로, 컴파일러에게 함수의 존재를 미리 알리는 역할을 한다.
 보통 `.h` 헤더 파일에 선언만 두고, 정의는 `.cpp`에서 구현한다.

형식:

```
반환형 함수이름(매개변수목록);
```

예시:

```
int add(int, int);  // 세미콜론 필수
```

선언 없이 함수 정의를 **나중에 작성하면 컴파일 에러** 발생 가능 (특히 위에서 아래로 컴파일할 때)

### 📌 3. 함수 호출 (Function Call)

정의된 함수를 사용하려면, 이름을 호출하고 **인자(argument)** 를 전달한다.

```
int result = add(3, 5);  // 3과 5를 전달하고 결과는 8
```

함수 호출 과정:

1. 인자가 매개변수로 복사 또는 참조됨
2. 함수 본문 실행
3. `return`으로 값 반환 (void일 경우 생략 가능)
4. 호출한 지점으로 복귀

### 📌 예제: 선언 → 정의 → 호출

```
#include <iostream>

// 선언
int multiply(int x, int y);

int main() {
    int result = multiply(4, 5);  // 호출
    std::cout << "결과: " << result << "\n";
    return 0;
}

// 정의
int multiply(int x, int y) {
    return x * y;
}
```

출력:

```
결과: 20
```

### 📌 함수 요소 요약

| 구성 요소 | 예시                 | 설명                       |
| --------- | -------------------- | -------------------------- |
| 반환형    | `int`                | 함수가 반환하는 값의 타입  |
| 함수명    | `add`                | 호출 시 사용하는 식별자    |
| 매개변수  | `(int a, int b)`     | 인자(argument)를 받는 변수 |
| 함수 본문 | `{ return ...; }`    | 실제 동작이 구현되는 부분  |
| 선언부    | `int add(int, int);` | 정의 전 함수 정보 제공     |

### 📌 보충: 함수와 관련된 고급 기능 (요약)

| 기능               | 설명                                       | 버전       |
| ------------------ | ------------------------------------------ | ---------- |
| **기본 인자값**    | `int f(int x = 0)`                         | 모든 버전  |
| **오버로딩**       | 같은 이름, 다른 매개변수 시그니처          | 모든 버전  |
| **inline 함수**    | 컴파일러에게 인라인 확장 요청 (`inline`)   | 모든 버전  |
| **템플릿 함수**    | 다양한 타입에 대해 일반화 (`template`)     | C++98 이상 |
| **람다 함수**      | 익명 함수 표현식 (`[](){}`)                | C++11 이상 |
| **constexpr 함수** | 컴파일 타임 평가 가능한 함수 (`constexpr`) | C++11 이상 |

함수는 C++ 프로그램의 **구조적 구성의 핵심 단위**다. 잘 설계된 함수는 코드 중복을 줄이고, 로직을 명확히 하며, 확장성과 테스트 용이성을 극대화한다.
 **함수 선언은 인터페이스, 함수 정의는 구현, 함수 호출은 실행**의 역할을 가지며, 세 부분을 명확히 분리하면 모듈화와 유지보수에 큰 도움이 된다.

## 매개변수 전달 방식 (값, 참조, 포인터)

C++에서 함수에 인자를 전달하는 방식에는 세 가지가 있다. 각각은 **값을 복사하는가, 참조하는가, 주소를 사용하는가**에 따라 메모리와 동작에 차이가 생긴다.
 이해하지 못한 채 사용하면 **값 변경이 반영되지 않거나**, **불필요한 복사가 발생**할 수 있으므로, 목적에 맞는 전달 방식 선택이 중요하다.

### 📌 1. 값에 의한 전달 (Call by Value)

- **값을 복사해서 전달**
- 함수 내부에서 매개변수를 변경해도 **원본에 영향 없음**
- **기본 타입(int, double 등)**에서 안전하고 직관적

```
void foo(int x) {
    x = 100;
}

int main() {
    int a = 10;
    foo(a);
    std::cout << a << "\n";  // 결과: 10
}
```

- `x`는 `a`의 복사본이므로 `x`를 바꿔도 `a`는 그대로임
- 대용량 객체(예: `std::vector`)는 성능 손실 있음 → 참조 사용 권장

### 📌 2. 참조에 의한 전달 (Call by Reference)

- **원본 변수의 별칭(alias)을 전달**
- **복사 비용 없음**, 원본 변수의 값이 **실제로 변경됨**
- `&` 기호로 참조를 명시

```
void foo(int& x) {
    x = 100;
}

int main() {
    int a = 10;
    foo(a);
    std::cout << a << "\n";  // 결과: 100
}
```

- `int& x`는 `a`를 직접 참조 → 함수 내부에서 `x` 변경 = `a` 변경

#### 장점:

- 대형 객체 전달 시 **복사 비용 절감**
- 직접 수정 가능

#### 단점:

- **부작용(side effect)** 발생 가능성 있음
- 함수 호출 결과만 보고 어떤 값이 바뀌었는지 알기 어려움

### 📌 3. 포인터에 의한 전달 (Call by Pointer)

- **변수의 주소를 전달**
- 함수에서 포인터를 역참조(dereference)하여 값에 접근
- 수정 가능하며, 참조 방식과 달리 **NULL 검사, 동적 할당 등 포인터 관련 제어** 가능

```
void foo(int* x) {
    *x = 100;
}

int main() {
    int a = 10;
    foo(&a);
    std::cout << a << "\n";  // 결과: 100
}
```

- `foo(&a)`로 주소 전달 → `*x`로 실제 값 수정 가능

#### 차이점:

- 포인터는 값이 없을 수도 있음 (`nullptr`)
- 동적 메모리 관리가 필요한 경우에 필수
- 함수 내에서 `nullptr` 체크로 안전성 확보 가능

#### 📎 요약 비교표

| 전달 방식   | 문법 예시        | 원본 수정 가능 | 복사 발생 | NULL 전달 가능 | 주 사용처                        |
| ----------- | ---------------- | -------------- | --------- | -------------- | -------------------------------- |
| 값 전달     | `void f(int x)`  | ❌              | O         | ❌              | 안전한 기본형, 값만 쓰는 함수    |
| 참조 전달   | `void f(int& x)` | ✅              | X         | ❌              | 대형 객체, 직접 수정 필요 시     |
| 포인터 전달 | `void f(int* x)` | ✅              | X         | ✅              | 동적 메모리, 존재 여부 검사 필요 |

### 📌 상수 참조 (`const T&`)

복사 없이 읽기 전용으로 값을 전달하고자 할 때 사용.
 특히 **복사 비용이 큰 객체**를 **수정 없이 읽기만 할 경우** 매우 유용하다.

```
void printVector(const std::vector<int>& v) {
    for (int x : v) std::cout << x << " ";
}
```

- 복사 안 함
- 값 변경 불가 (`const`)
- 안전하고 성능 좋음

### 📌 함수 오버로딩과 전달 방식

C++은 전달 방식에 따라 함수를 오버로딩할 수 있다:

```
void update(int x);        // 값 전달
void update(int& x);       // 참조 전달
void update(const int& x); // 읽기 전용 참조 전달
```

각각의 목적과 사용 의도를 명확히 하기 위해 **전달 방식에 따라 함수를 설계**하는 것이 C++ 스타일이다.

### ✅ 정리

- 값 전달: **간단한 값(정수, 실수)**은 안전하게 사용
- 참조 전달: **수정 필요하거나 대형 객체**에 적합
- 포인터 전달: **동적 객체, NULL 가능성, 저수준 조작** 필요 시 사용
- `const` 참조: **읽기 전용 고성능 함수 인자 처리**

매개변수 전달 방식은 단순한 문법 차이를 넘어서, **성능, 안정성, 코드 설계의 품질**을 결정하는 중요한 요소다.

## 함수 오버로딩

**함수 오버로딩**은 C++에서 동일한 이름의 함수를 **매개변수의 타입, 개수, 순서**에 따라 여러 개 정의할 수 있게 해주는 기능이다.
 즉, **함수 이름은 같지만** 각각 **다른 작업을 수행하거나 다른 타입을 처리**하도록 만드는 **다형성(polymorphism)**의 한 형태다.

### 📌 기본 개념

```
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

std::string add(std::string a, std::string b) {
    return a + b;
}
```

- 같은 이름 `add`를 여러 번 정의했지만, **매개변수의 타입이 다르므로 모두 유효**
- 함수 호출 시 **컴파일러가 인자의 타입에 따라 올바른 버전 자동 선택**

### 📌 오버로딩 규칙

함수 오버로딩은 다음 조건 중 하나라도 다르면 성립한다:

| 오버로딩 기준        | 예시                                         |
| -------------------- | -------------------------------------------- |
| 인자의 **개수** 다름 | `void f(int)` vs `void f(int, int)`          |
| 인자의 **타입** 다름 | `void f(int)` vs `void f(double)`            |
| 인자의 **순서** 다름 | `void f(int, float)` vs `void f(float, int)` |

> 단, **반환형만 다르다 하여 오버로딩은 불가능**하다.

```
int func(int x);
double func(int x);  // ❌ 오류: 반환형만 다르면 안 됨
```

### 📌 함수 호출과 오버로딩 결정 과정

- **정확히 일치하는 타입 우선**
- 필요시 **암시적 형 변환(implicit conversion)** 고려
- 애매하면 **오버로딩 모호성(ambiguity)** 발생 → 컴파일 오류

```
void print(int x);
void print(double x);

print(3);     // → int 버전 호출
print(3.14);  // → double 버전 호출
```

```
void f(int);
void f(float);

// ambiguous
f('a');  // ❌ char → int or float 모두 가능 → 모호함
```

### 📌 기본 인자와의 조합 시 주의

```
void f(int x, int y = 0);
void f(int x);

// f(10); 호출 시 어떤 f인지 모호함 → 컴파일 오류
```

**기본 인자(default argument)**와 오버로딩을 함께 사용할 때는, **중복된 형태가 생기지 않도록 명확히 구분**해야 한다.

### 📌 참조/포인터와의 오버로딩

```
void show(int x);
void show(const int& x);
```

- 이 두 함수는 **실제로 같은 시그니처로 간주**될 수 있음 → **중복 선언 오류 발생 가능**
- `const` vs `non-const` 참조/포인터는 구분 가능하지만 주의 요함

### 📌 오버로딩 + 템플릿 예시

```
void print(int x) {
    std::cout << "정수: " << x << "\n";
}

template <typename T>
void print(T x) {
    std::cout << "템플릿: " << x << "\n";
}

print(5);        // 일반 함수가 우선
print(3.14);     // 템플릿 함수 사용됨
```

템플릿과 오버로딩을 혼용하면 **명시적으로 특화하거나 우선순위를 조정**할 수 있다.

### 📎 요약

| 항목                   | 설명                                          |
| ---------------------- | --------------------------------------------- |
| 오버로딩 기준          | 인자 개수, 타입, 순서 중 하나라도 다르면 가능 |
| 불가능한 예            | 반환형만 다른 경우                            |
| 암시적 변환 주의       | 모호성(ambiguity) 발생 가능                   |
| 기본 인자 사용 시 주의 | 중복된 호출 시그니처 발생 가능                |
| 템플릿과 혼용 가능     | 일반 함수가 우선, 필요 시 명시적 특화 가능    |

함수 오버로딩은 **동일한 개념의 여러 연산을 하나의 이름으로 통일**할 수 있게 해주며, API를 직관적이고 유연하게 만들어주는 강력한 도구다.
 단, 오버로딩이 많아질수록 **함수 선택 기준이 애매해지고 모호성 문제가 발생**할 수 있으므로, 사용 시 **명확한 의도와 일관된 설계 원칙**이 필요하다.

## 기본 매개변수

**기본 매개변수(default arguments)**는 함수 호출 시 **인자를 생략할 수 있게 해주는 기능**이다.
 함수를 정의할 때 매개변수에 기본값을 지정해두면, 호출 시 해당 인자를 생략하면 **기본값이 자동으로 사용**된다.
 C++는 이를 통해 **함수 오버로딩 수를 줄이고**, **더 간결한 인터페이스**를 제공할 수 있다.

### 📌 기본 문법

```
반환형 함수이름(타입 매개변수 = 기본값);
```

예시:

```
void greet(std::string name = "Guest") {
    std::cout << "Hello, " << name << "!\n";
}

int main() {
    greet("Alice");  // 출력: Hello, Alice!
    greet();         // 출력: Hello, Guest!
}
```

### 📌 여러 매개변수에서의 기본값

기본값은 **오른쪽에서부터 순서대로만 지정**할 수 있다.

```
void log(std::string msg, int level = 1, bool newline = true);
```

> ❌ 아래와 같은 형태는 컴파일 에러

```
// 잘못된 선언: 중간 생략은 허용되지 않음
void log(std::string msg = "msg", int level, bool newline = true);  // ❌
```

### 📌 함수 선언과 정의 분리 시 기본값은 한 곳에만

기본값은 **선언부 또는 정의부 중 하나에만 작성**해야 한다. 일반적으로 **선언부(헤더)에 작성**하는 것이 관례다.

```
// 선언부 (보통 .h)
void show(int x = 100);

// 정의부 (보통 .cpp)
void show(int x) {
    std::cout << x << "\n";
}
```

> ❌ 둘 다 기본값을 지정하면 중복 오류 발생

### 📌 오버로딩과의 관계

기본 매개변수는 함수 오버로딩을 **간결하게 대체**할 수 있다.

```
// 오버로딩 방식
void drawCircle(int radius) { drawCircle(radius, "black"); }
void drawCircle(int radius, std::string color);

// 기본 매개변수 방식
void drawCircle(int radius, std::string color = "black");
```

- 코드가 간결해지고, 유지보수가 쉬움
- 하지만, **과도한 기본 인자 사용 시 호출 명확성이 떨어질 수 있음**

### 📎 예제: 모든 매개변수에 기본값 지정

```
void configure(int mode = 0, int retries = 3, bool verbose = false) {
    std::cout << "mode=" << mode
              << ", retries=" << retries
              << ", verbose=" << verbose << "\n";
}

int main() {
    configure();                      // 모두 기본값 사용
    configure(1);                     // retries, verbose는 기본값
    configure(2, 5);                  // verbose는 기본값
    configure(3, 5, true);            // 모든 인자 직접 지정
}
```

### 📌 주의사항

| 주의점                             | 설명                                               |
| ---------------------------------- | -------------------------------------------------- |
| 중간 매개변수 생략 불가            | 오른쪽부터 순차적으로만 생략 가능                  |
| 선언과 정의 양쪽에 기본값 금지     | 한 번만 지정해야 함 (보통 선언부에 작성)           |
| 함수 포인터에는 사용 불가          | 함수 시그니처가 정확히 일치해야 함                 |
| 모호한 오버로딩과 충돌 가능성 있음 | 기본값이 오버로딩 시그니처를 중복되게 만들 수 있음 |

### ✅ 요약

- 기본 매개변수는 **함수 호출을 더 간결하게** 만들어주는 기능
- 기본값은 **오른쪽부터 순차적으로 지정**
- 선언과 정의 분리 시, **기본값은 선언부에만**
- 함수 오버로딩을 **대체하거나 간소화**하는 데 유용
- **과도한 사용은 가독성과 명확성 저하** 위험

C++에서 기본 인자는 함수 인터페이스를 유연하게 만들 수 있는 강력한 도구지만, 항상 **호출의 명확성과 의도 전달**을 고려한 설계가 중요하다.

## 반환값 및 void 함수

C++에서 함수는 작업을 수행한 뒤 **결과를 반환할 수도 있고**, 단순히 작업만 수행하고 **아무 값도 반환하지 않을 수도 있다.**
 함수의 반환형(return type)은 함수가 **어떤 값을 결과로 되돌려줄 것인지**를 명시한다.

### 📌 1. 반환값이 있는 함수

- 함수는 **`return` 키워드**를 통해 호출자에게 값을 반환할 수 있다.
- 반환형은 함수 이름 앞에 명시하며, 반환되는 값의 **자료형과 일치해야 한다.**

#### ✅ 예시: 정수 반환

```
int square(int x) {
    return x * x;
}
```

#### ✅ 예시: 문자열 반환

```
std::string greet(std::string name) {
    return "Hello, " + name;
}
```

#### ✅ 사용:

```
int result = square(5);               // 25
std::cout << greet("Alice") << "\n";  // Hello, Alice
```

#### ✅ 반환형과 리턴값 불일치 → 컴파일 오류

```
int getValue() {
    return "hello";  // ❌ 오류: string을 int로 반환 불가
}
```

### 📌 2. `void` 함수 (반환값 없음)

- `void`는 **"아무 것도 반환하지 않음"**을 의미하는 **특수한 반환형**
- 함수는 단순히 **명령을 수행만 하고**, 호출자에게 값을 전달하지 않는다

#### ✅ 예시:

```
cpp코드 복사void printHello() {
    std::cout << "Hello\n";
}
```

#### ✅ 사용:

```
printHello();  // 출력만 수행, 값 없음
```

- `void` 함수에는 `return;`만 사용할 수 있고, **값을 반환하면 오류**

```
void foo() {
    return;     // OK
    // return 1;  // ❌ 오류
}
```

### 📌 3. 여러 자료형 반환 예시

| 반환형        | 예시 함수                           |
| ------------- | ----------------------------------- |
| `int`         | `int add(int a, int b)`             |
| `double`      | `double divide(double a, double b)` |
| `bool`        | `bool isEven(int x)`                |
| `std::string` | `std::string greet(std::string)`    |
| `void`        | `void log(std::string)`             |

### 📌 4. 참조나 포인터로 반환 (심화)

함수에서 **참조(`&`) 또는 포인터(`\*`)로 반환**할 수 있다. 이 경우, **호출자는 원본 객체를 직접 수정**할 수 있게 된다.

### ✅ 참조 반환

```
int& accessElement(std::vector<int>& v, int i) {
    return v[i];
}
```

- 사용: `accessElement(vec, 2) = 100;`

#### ✅ 주의:

- **지역 변수의 참조 또는 주소를 반환하면 안 됨**

```
int& dangerous() {
    int temp = 42;
    return temp;  // ❌ dangling reference
}
```

### 📌 5. `return` 없는 함수는 기본 반환값 없음

```
void f() {
    std::cout << "실행 중\n";
}

int main() {
    auto result = f();  // result는 void → 아무 값 없음
}
```

### 📎 요약 비교

| 구분         | 설명                         | 예시                     |
| ------------ | ---------------------------- | ------------------------ |
| `int f()`    | 정수 반환                    | `return 42;`             |
| `double f()` | 실수 반환                    | `return 3.14;`           |
| `bool f()`   | 참/거짓 판단 결과 반환       | `return true;`           |
| `string f()` | 문자열 반환                  | `return "hello";`        |
| `void f()`   | 아무 것도 반환하지 않음      | `return;` 또는 생략 가능 |
| `T& f()`     | 참조로 반환 → 직접 수정 가능 | `return vec[i];`         |
| `T* f()`     | 포인터로 반환 → 널 검사 가능 | `return &x;`             |

함수의 반환값은 **함수 호출 이후 어떤 정보를 되돌려줄 것인지 결정하는 핵심 요소**다.
 `void` 함수는 **순수한 실행 목적**, 반환형 함수는 **데이터 전달 목적**으로 사용되며,
 C++의 다양한 타입 시스템과 결합해 매우 유연한 함수 설계를 가능하게 한다.

## inline 함수

`inline` 함수는 **함수 호출 시 성능 손실을 줄이기 위해**, 컴파일러에게 해당 함수를 **호출문 대신 함수 본문 코드로 치환하도록 제안하는 키워드**다.
 즉, **함수 호출이 아니라 함수 코드 자체를 "직접 복붙"하는 방식**으로 처리되어 **호출 오버헤드 없이 빠르게 실행**되는 것이 목적이다.

### 📌 기본 문법

```
inline 반환형 함수이름(매개변수목록) {
    // 본문
}
```

예시:

```
inline int square(int x) {
    return x * x;
}
```

호출 시:

```
int result = square(5);  // → 컴파일 시: int result = 5 * 5;
```

### 📌 특징 요약

| 항목                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| 목적                | 함수 호출 오버헤드 제거                                      |
| 적용 대상           | **작고 단순한 함수** (1~2줄 정도가 일반적)                   |
| 반환 타입 제한 없음 | `void`, `int`, `std::string` 등 모두 사용 가능               |
| 반드시 치환됨 아님  | **컴파일러의 판단에 따라 무시될 수 있음**                    |
| 정의와 선언의 위치  | 보통 **헤더 파일** 안에 정의 포함해야 제대로 인라인 처리됨   |
| 디버깅 영향         | 인라인 치환된 코드는 **함수 호출 스택이 없어서** 디버깅이 어려움 |

### 📌 예제

```
#include <iostream>

inline int add(int a, int b) {
    return a + b;
}

int main() {
    std::cout << add(3, 4) << "\n";  // 출력: 7
}
```

컴파일러는 `add(3, 4)`를 → `3 + 4`로 대체함으로써 함수 호출 없이 직접 연산 수행

### 📌 언제 사용하나?

**사용에 적합한 경우:**

- 단순한 산술 연산 함수 (`max`, `min`, `clamp`, `swap`)
- 조건 분기 없는 코드 (분기 예측 손실 없음)
- 자주 호출되는 성능 민감 코드
- 템플릿 함수 정의 (C++ 표준 요구사항)

**지양해야 할 경우:**

- 본문이 긴 함수 (`for`, `if`, I/O 포함)
- 재귀 함수 (절대 인라인 안 됨)
- 디버깅이 필요한 복잡 함수
- 함수의 크기 증가로 인해 바이너리 코드가 과도하게 커질 우려가 있을 때

### 📌 `inline`과 헤더파일

```
// math_utils.h
inline int cube(int x) {
    return x * x * x;
}
```

- **정의와 선언을 같은 파일에 두지 않으면**, 링크 오류 발생 가능 (`multiple definition`)
- 따라서 **`inline` 함수는 반드시 헤더파일(.h)에 정의와 함께 존재**해야 함

### 📌 C++17 이후: `inline` 변수 & 함수 정의

C++17부터는 **전역 변수와 함수 정의에도 `inline` 키워드**를 허용함으로써
 **ODR(One Definition Rule)** 위반 없이 **헤더에 함수 정의 포함 가능**

```
// header.h
inline int multiply(int a, int b) {
    return a * b;
}
```

### 📎 요약

| 항목             | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| 키워드           | `inline`                                                     |
| 목적             | 함수 호출 오버헤드 제거                                      |
| 정의 위치        | 헤더 파일 내부에서 정의 필요                                 |
| 사용 조건        | 간단하고 자주 호출되는 함수에 적합                           |
| 주의사항         | 복잡한 함수에 사용 시 성능 저하 또는 디버깅 어려움 발생 가능 |
| 무조건 치환 아님 | **컴파일러가 상황에 따라 무시 가능 (최적화 판단 기준)**      |

**결론**: `inline` 함수는 성능 최적화를 위한 유용한 도구지만, **“짧고 자주 쓰이며 호출 오버헤드가 무의미한 함수”에만 사용**해야 하며,
 코드 크기 증가와 디버깅 난이도 상승에 주의해야 한다.
 템플릿 함수 정의 시에는 거의 필수적으로 사용된다.

## 함수 포인터

**함수 포인터**는 함수의 **주소(시작 위치)를 저장하는 포인터**다.
 C++에서는 함수도 메모리에 저장되므로, 특정 함수의 주소를 포인터에 저장하고 이를 통해 **함수를 동적으로 호출**할 수 있다.

함수 포인터는 다음과 같은 상황에서 매우 유용하다:

- **콜백 함수(callback)** 구현
- **함수 테이블, 전략 패턴** 구현
- **동적 함수 선택 또는 분기** 필요 시

### 📌 기본 문법

```
반환형 (*포인터이름)(매개변수목록);
```

예시:

```
int add(int a, int b) {
    return a + b;
}

int (*fp)(int, int);  // 함수 포인터 선언
fp = add;             // 함수 주소 저장
int result = fp(3, 4);  // 함수 호출 → 7
```

또는 한 줄로:

```
int (*fp)(int, int) = add;
```

### 📌 함수 포인터 선언 구조

```
// 함수 선언
int operation(int, int);

// 함수 포인터
int (*funcptr)(int, int);
```

- `(*funcptr)` : `funcptr`가 포인터라는 의미
- `(int, int)` : 함수의 매개변수 시그니처
- `int` : 반환형

### 📌 호출 방식 비교

```
int result1 = add(5, 3);    // 일반 호출
int result2 = (*fp)(5, 3);  // 함수 포인터로 호출
int result3 = fp(5, 3);     // 괄호 생략 가능
```

### 📌 배열을 이용한 함수 포인터 테이블

```
int add(int a, int b)  { return a + b; }
int sub(int a, int b)  { return a - b; }
int mul(int a, int b)  { return a * b; }

int (*ops[])(int, int) = { add, sub, mul };

int main() {
    int a = 10, b = 5;
    for (int i = 0; i < 3; ++i)
        std::cout << ops[i](a, b) << "\n";  // 15, 5, 50
}
```

- `ops`는 함수 포인터 배열
- 동적으로 함수 선택 가능

### 📌 함수 포인터를 인자로 전달 (콜백 패턴)

```
void runOperation(int x, int y, int (*op)(int, int)) {
    std::cout << "결과: " << op(x, y) << "\n";
}

int add(int a, int b) {
    return a + b;
}

int main() {
    runOperation(4, 5, add);  // 출력: 결과: 9
}
```

- `runOperation`은 동적으로 어떤 함수든 받아서 실행 가능

### 📌 typedef / using 으로 함수 포인터 간결하게

```
typedef int (*OpFunc)(int, int);
// 또는 (C++11 이상)
using OpFunc = int(*)(int, int);

OpFunc f = add;
```

- 코드 가독성 향상
- 특히 템플릿과 결합할 때 유리

### 📌 `std::function` vs 함수 포인터

C++11 이상에서는 **`std::function`**을 통해 더 유연하고 객체지향적인 함수 래핑이 가능함

```
#include <functional>

std::function<int(int, int)> op = add;
op(10, 20);  // 30
```

- 함수 포인터보다 **람다, 멤버함수, 함수 객체 등과 호환 가능**
- 단점: 함수 포인터보다 **약간 느리고 메모리 사용 큼**

### 📎 요약

| 항목               | 설명                                   |
| ------------------ | -------------------------------------- |
| 선언 문법          | `반환형 (*이름)(매개변수목록)`         |
| 사용 목적          | 함수 주소 저장 및 동적 호출            |
| 호출 문법          | `fp(a, b)` 또는 `(*fp)(a, b)`          |
| 함수 배열          | 여러 함수 중 선택적으로 호출 가능      |
| 콜백 함수          | 함수 포인터를 인자로 전달 가능         |
| typedef/using      | 복잡한 선언을 간단하게 표현            |
| std::function 대체 | 함수 포인터를 더 확장성 있게 포장 가능 |

**함수 포인터는 저수준이지만 매우 강력한 기능**으로, 동적 실행 제어가 필요한 알고리즘, 이벤트 시스템, 플러그인 아키텍처에서 중요한 역할을 한다.
 다만 C++11 이후에는 가능한 경우 `std::function`, `lambda`, `functor` 등을 사용하는 것이 더 안전하고 유연하다.