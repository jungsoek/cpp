# 27. ì‘ìš© ë¶„ì•¼ë³„ C++ í™œìš©

## ê²Œì„ ì—”ì§„ ê°œë°œ (ê²Œì„ ë£¨í”„, ECS êµ¬ì¡°)

### 1. ğŸ¯ ê²Œì„ ì—”ì§„ì´ë€?

> **ê²Œì„ ì—”ì§„(Game Engine)**ì€ ë Œë”ë§, ë¬¼ë¦¬, ì˜¤ë””ì˜¤, ì…ë ¥, ê²Œì„ ë¡œì§ ë“±ì„ ì²˜ë¦¬í•˜ëŠ” **í”„ë ˆì„ì›Œí¬ì´ì í”Œë«í¼**ì´ì•¼.

> ê²Œì„ì€ â€œ**ìƒíƒœë¥¼ ê³„ì†í•´ì„œ ì—…ë°ì´íŠ¸í•˜ê³  í™”ë©´ì— ë Œë”ë§**â€í•˜ëŠ” ë°˜ë³µì ì¸ ì‘ì—….
>  â†’ ì´ê±¸ **ë£¨í”„ êµ¬ì¡° + ë°ì´í„° ì¤‘ì‹¬ ì„¤ê³„(ECS)**ë¡œ ì²˜ë¦¬í•˜ëŠ” ê²Œ í•µì‹¬.

### 2. ğŸ” ê²Œì„ ë£¨í”„(Game Loop)

#### êµ¬ì¡° ìš”ì•½

```
while (ê²Œì„ ì‹¤í–‰ ì¤‘) {
    ì…ë ¥ ì²˜ë¦¬
    ë¬¼ë¦¬/ë¡œì§ ì—…ë°ì´íŠ¸
    ë Œë”ë§
}
```

#### C++ ì˜ˆì‹œ (ê¸°ë³¸ êµ¬ì¡°)

```
bool running = true;
while (running) {
    processInput();
    update(deltaTime);
    render();
}
```

#### ì‹œê°„ ê´€ë¦¬ ì¶”ê°€

```
auto now = std::chrono::high_resolution_clock::now();
auto last = now;

while (running) {
    now = std::chrono::high_resolution_clock::now();
    float deltaTime = std::chrono::duration<float>(now - last).count();
    last = now;

    processInput();
    update(deltaTime);
    render();
}
```

### 3. ğŸ§  ê³ ì • ì—…ë°ì´íŠ¸ vs ê°€ë³€ ì—…ë°ì´íŠ¸

| ë°©ì‹              | ì„¤ëª…                                     |
| ----------------- | ---------------------------------------- |
| **ê°€ë³€ ì—…ë°ì´íŠ¸** | ë§¤ í”„ë ˆì„ `deltaTime` ì‚¬ìš© (ì¼ë°˜ì )      |
| **ê³ ì • ì—…ë°ì´íŠ¸** | ì¼ì • ì‹œê°„ ë‹¨ìœ„ë¡œ ë¬¼ë¦¬ ê³„ì‚° (`dt = 1/60`) |

```
const float fixedDelta = 1.0f / 60.0f;
float accumulator = 0.0f;

while (running) {
    float deltaTime = ...;

    accumulator += deltaTime;
    while (accumulator >= fixedDelta) {
        updatePhysics(fixedDelta);
        accumulator -= fixedDelta;
    }

    render();  // ë Œë”ë§ì€ ë§¤ í”„ë ˆì„ ìˆ˜í–‰
}
```

### 4. ğŸ§¬ ECS êµ¬ì¡°(Entity-Component-System)

#### í•µì‹¬ ì•„ì´ë””ì–´:

- **Entity**: ê³ ìœ  IDë§Œ ê°€ì§„ ê°ì²´ (ë°ì´í„° ì—†ìŒ)
- **Component**: ì†ì„± ë°ì´í„° (ìœ„ì¹˜, ì†ë„, ì²´ë ¥ ë“±)
- **System**: ì»´í¬ë„ŒíŠ¸ ì¡°í•©ì„ ë³´ê³  **í–‰ë™/ë¡œì§ ì‹¤í–‰**

â†’ ì™„ì „í•œ ë°ì´í„° ì¤‘ì‹¬ ì„¤ê³„ (OOP â†’ Data-Driven)

#### ì˜ˆì‹œ êµ¬ì„±

```
using Entity = std::uint32_t;

struct Position { float x, y; };
struct Velocity { float dx, dy; };

std::unordered_map<Entity, Position> positions;
std::unordered_map<Entity, Velocity> velocities;
```

```
void MovementSystem(float dt) {
    for (auto& [e, vel] : velocities) {
        if (positions.contains(e)) {
            positions[e].x += vel.dx * dt;
            positions[e].y += vel.dy * dt;
        }
    }
}
```

#### ì¥ì 

| í•­ëª©     | ì„¤ëª…                             |
| -------- | -------------------------------- |
| ì„±ëŠ¥     | SoA ë°©ì‹ìœ¼ë¡œ ìºì‹œ ìµœì í™”         |
| ìœ ì—°ì„±   | Entityì— ì›í•˜ëŠ” Componentë§Œ ë¶™ì„ |
| ìœ ì§€ë³´ìˆ˜ | ê³„ì¸µ êµ¬ì¡° ì—†ì´ ê´€ê³„ ë¶„ë¦¬ë¨       |

### 5. âš™ï¸ ì‹¤ì „: ë¯¸ë‹ˆ ECS ì˜ˆì œ

```
struct Transform { float x, y; };
struct Health { int hp; };

std::unordered_map<Entity, Transform> transforms;
std::unordered_map<Entity, Health> healths;

void HealthSystem() {
    for (auto& [e, h] : healths) {
        if (h.hp <= 0)
            std::cout << "Entity " << e << " is dead.\n";
    }
}
```

### 6. ğŸ”§ ECS êµ¬í˜„ ì „ëµ

| êµ¬ì„± ìš”ì†Œ      | êµ¬í˜„ ë°©ì‹                                                  |
| -------------- | ---------------------------------------------------------- |
| Entity ìƒì„±    | ê°„ë‹¨í•œ ì •ìˆ˜ ID                                             |
| Component ì €ì¥ | `std::unordered_map<Entity, Component>` ë˜ëŠ” `std::vector` |
| System ì‹¤í–‰    | í•„ìš”í•œ Component ìŒì„ ê°€ì§„ Entityë§Œ ì²˜ë¦¬                   |
| Archetype ë°©ì‹ | ê³ ê¸‰ ECS ì—”ì§„ (ex: EnTT)ì—ì„œ ì‚¬ìš©                          |

### 7. ğŸ® ì „ì²´ í†µí•© íë¦„

```
int main() {
    init();
    auto last = std::chrono::high_resolution_clock::now();

    while (!quit) {
        auto now = std::chrono::high_resolution_clock::now();
        float dt = std::chrono::duration<float>(now - last).count();
        last = now;

        processInput();
        movementSystem(dt);
        render();
    }

    shutdown();
}
```

### 8. ğŸ›  ë¼ì´ë¸ŒëŸ¬ë¦¬ ì˜ˆì‹œ

| ë¼ì´ë¸ŒëŸ¬ë¦¬                                   | ì„¤ëª…                                          |
| -------------------------------------------- | --------------------------------------------- |
| **[EnTT](https://github.com/skypjack/entt)** | í˜„ëŒ€ì  ECS êµ¬í˜„, ìºì‹œ ìµœì í™”                  |
| **Flecs**                                    | ë¹ ë¥´ê³  ìœ ì—°í•œ C/C++ ECS                       |
| **SFML / SDL2**                              | ê·¸ë˜í”½/ì…ë ¥/ì˜¤ë””ì˜¤ + ECS ì§ì ‘ êµ¬í˜„í•˜ê¸°ì— ì í•© |

### âœ… ìš”ì•½

| í•­ëª©      | ì„¤ëª…                                 |
| --------- | ------------------------------------ |
| ê²Œì„ ë£¨í”„ | ì…ë ¥ â†’ ì—…ë°ì´íŠ¸ â†’ ë Œë” ë°˜ë³µ          |
| ì‹œê°„ ê´€ë¦¬ | `deltaTime` or `fixedDelta`ë¡œ update |
| Entity    | ë‹¨ìˆœ ID                              |
| Component | êµ¬ì¡°ì²´ë¡œ ì†ì„± ì •ì˜                   |
| System    | ê´€ë ¨ Component ì¡°í•© ê¸°ë°˜ ë¡œì§ ì‹¤í–‰   |
| ì¥ì       | ì„±ëŠ¥ ìµœì í™”, í™•ì¥ì„±, ìœ ì§€ë³´ìˆ˜ ìš°ìˆ˜   |

## ë„¤íŠ¸ì›Œí¬ ì„œë²„/í´ë¼ì´ì–¸íŠ¸ ê°œë°œ

### 1. ğŸ¯ ê¸°ë³¸ ê°œë… ìš”ì•½

| ìš©ì–´                   | ì„¤ëª…                                                     |
| ---------------------- | -------------------------------------------------------- |
| **ì„œë²„(Server)**       | í´ë¼ì´ì–¸íŠ¸ì˜ ì—°ê²°ì„ **ìˆ˜ì‹ **í•˜ê³  ìš”ì²­ì„ ì²˜ë¦¬             |
| **í´ë¼ì´ì–¸íŠ¸(Client)** | ì„œë²„ì— **ì ‘ì†**í•´ì„œ ìš”ì²­ì„ ë³´ëƒ„                          |
| **TCP**                | ì—°ê²° ì§€í–¥, ì‹ ë¢°ì„± ë³´ì¥, íë¦„ ì œì–´ (3-way handshake)      |
| **ì†Œì¼“(Socket)**       | ë„¤íŠ¸ì›Œí¬ I/Oë¥¼ ìœ„í•œ ì¶”ìƒ í•¸ë“¤ (file descriptorì²˜ëŸ¼ ì‚¬ìš©) |

### 2. ğŸ§± í•„ìš”í•œ í—¤ë” ë° í•¨ìˆ˜ (POSIX ê¸°ì¤€)

```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <cstring>
#include <iostream>
```

| í•¨ìˆ˜                | ì„¤ëª…                        |
| ------------------- | --------------------------- |
| `socket()`          | ì†Œì¼“ ìƒì„±                   |
| `bind()`            | IP/í¬íŠ¸ í• ë‹¹ (ì„œë²„)         |
| `listen()`          | ì—°ê²° ìˆ˜ì‹  ëŒ€ê¸° ì‹œì‘ (ì„œë²„)  |
| `accept()`          | í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìˆ˜ë½ (ì„œë²„) |
| `connect()`         | ì„œë²„ì— ì ‘ì† (í´ë¼ì´ì–¸íŠ¸)    |
| `send()` / `recv()` | ë°ì´í„° ì†¡ìˆ˜ì‹                |
| `close()`           | ì†Œì¼“ ì¢…ë£Œ                   |

### 3. ğŸ–¥ ì„œë²„ ì½”ë“œ (TCP)

```
// tcp_server.cpp
int main() {
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in serv_addr{};
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(8080);               // í¬íŠ¸ 8080
    serv_addr.sin_addr.s_addr = INADDR_ANY;         // ëª¨ë“  IP ìˆ˜ì‹ 

    bind(server_fd, (sockaddr*)&serv_addr, sizeof(serv_addr));
    listen(server_fd, SOMAXCONN);                   // ìµœëŒ€ ëŒ€ê¸° í

    std::cout << "Waiting for connection...\n";

    sockaddr_in client_addr{};
    socklen_t client_len = sizeof(client_addr);
    int client_fd = accept(server_fd, (sockaddr*)&client_addr, &client_len);

    char buffer[1024] = {};
    read(client_fd, buffer, 1024);
    std::cout << "Client says: " << buffer << "\n";

    std::string response = "Hello from server!";
    send(client_fd, response.c_str(), response.size(), 0);

    close(client_fd);
    close(server_fd);
}
```

### 4. ğŸ§‘â€ğŸ’» í´ë¼ì´ì–¸íŠ¸ ì½”ë“œ (TCP)

```
// tcp_client.cpp
int main() {
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in serv_addr{};
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(8080);
    inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr);

    connect(sock, (sockaddr*)&serv_addr, sizeof(serv_addr));

    std::string msg = "Hello Server!";
    send(sock, msg.c_str(), msg.size(), 0);

    char buffer[1024] = {};
    read(sock, buffer, 1024);
    std::cout << "Server reply: " << buffer << "\n";

    close(sock);
}
```

### 5. ğŸ§ª ë¹Œë“œ & ì‹¤í–‰

```
g++ tcp_server.cpp -o server
g++ tcp_client.cpp -o client

./server    # í„°ë¯¸ë„ 1
./client    # í„°ë¯¸ë„ 2
```

### 6. ğŸ§  ì‹¤ì „ ê³ ë ¤ ìš”ì†Œ

| í•­ëª©                 | ì„¤ëª…                                                         |
| -------------------- | ------------------------------------------------------------ |
| ë©€í‹° í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬ | `fork()`, `pthread`, `select()`, `epoll`                     |
| íŒ¨í‚· ê²½ê³„ ì²˜ë¦¬       | TCPëŠ” ìŠ¤íŠ¸ë¦¼ ê¸°ë°˜ì´ë¯€ë¡œ ë©”ì‹œì§€ êµ¬ë¶„ í•„ìš” (`length prefix` ë“±) |
| ì˜¤ë¥˜ ì²˜ë¦¬            | ê° ì‹œìŠ¤í…œ ì½œì˜ ë°˜í™˜ê°’ ì²´í¬ í•„ìˆ˜                              |
| ë¸”ë¡œí‚¹ vs ë…¼ë¸”ë¡œí‚¹   | `fcntl()`ìœ¼ë¡œ `O_NONBLOCK` ì„¤ì • ê°€ëŠ¥                         |
| ë³´ì•ˆ                 | `TLS/SSL` ì•”í˜¸í™” ì ìš© (OpenSSL ì—°ë™)                         |

### 7. ğŸ”„ ë©€í‹° í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬: `select()` ì˜ˆì‹œ

```
fd_set read_fds;
FD_ZERO(&read_fds);
FD_SET(server_fd, &read_fds);

int max_fd = server_fd;
select(max_fd + 1, &read_fds, NULL, NULL, NULL);

if (FD_ISSET(server_fd, &read_fds)) {
    int new_fd = accept(server_fd, ...);
}
```

> ë˜ëŠ” `epoll`, `poll` ê°™ì€ ê³ ì„±ëŠ¥ ì´ë²¤íŠ¸ ê¸°ë°˜ APIë„ ì‚¬ìš© ê°€ëŠ¥

### 8. ğŸ“¦ ëŒ€ì²´ ë¼ì´ë¸ŒëŸ¬ë¦¬

| ë¼ì´ë¸ŒëŸ¬ë¦¬     | ì„¤ëª…                                          |
| -------------- | --------------------------------------------- |
| **Boost.Asio** | ê³ ì„±ëŠ¥ ë„¤íŠ¸ì›Œí¬ ë¹„ë™ê¸° ì²˜ë¦¬ (ë©€í‹°í”Œë«í¼)      |
| **libuv**      | Node.js ê¸°ë°˜ ì´ë²¤íŠ¸ ë£¨í”„ ì—”ì§„                 |
| **POCO**       | ë„¤íŠ¸ì›Œí¬ + HTTP + ì§ë ¬í™” ë“± í¬í•¨ëœ í”„ë ˆì„ì›Œí¬ |
| **QT Network** | GUI ê¸°ë°˜ ì•±ì˜ TCP/IP í†µì‹  í¬í•¨                |

### 9. âœ… ìš”ì•½ ì •ë¦¬

| í•­ëª©                               | ì„¤ëª…                                      |
| ---------------------------------- | ----------------------------------------- |
| `socket()`                         | ì†Œì¼“ ìƒì„±                                 |
| `bind()` / `listen()` / `accept()` | ì„œë²„ ì¸¡ ì—°ê²° ìˆ˜ì‹  ì²˜ë¦¬                    |
| `connect()`                        | í´ë¼ì´ì–¸íŠ¸ ì—°ê²°                           |
| `send()` / `recv()`                | ë°”ì´íŠ¸ ê¸°ë°˜ ì†¡ìˆ˜ì‹                         |
| ë³‘ë ¬ ì²˜ë¦¬                          | ìŠ¤ë ˆë“œ / select / epoll                   |
| í™•ì¥                               | SSL, ë¹„ë™ê¸° ì²˜ë¦¬, ë©”ì‹œì§€ í”„ë¡œí† ì½œ êµ¬í˜„ ë“± |

## GUI ì• í”Œë¦¬ì¼€ì´ì…˜ (Qt, wxWidgets)

### 1. ğŸ¯ ë‘ í”„ë ˆì„ì›Œí¬ ê°œìš” ë¹„êµ

| í•­ëª©        | Qt                                  | wxWidgets                               |
| ----------- | ----------------------------------- | --------------------------------------- |
| ì„¤ë¦½        | Qt Company (ì›: Trolltech)          | ì»¤ë®¤ë‹ˆí‹° ê¸°ë°˜                           |
| ë¼ì´ì„ ìŠ¤    | GPL/LGPL + ìƒìš©                     | wxWindows License (LGPLê³¼ ìœ ì‚¬)         |
| íˆ´í‚· ìŠ¤íƒ€ì¼ | ìì²´ ë Œë”ë§ (í¬ë¡œìŠ¤ í”Œë«í¼ UI í†µì¼) | OS ë„¤ì´í‹°ë¸Œ ìœ„ì ¯ ì‚¬ìš©                   |
| í”Œë«í¼ ì§€ì› | Windows, macOS, Linux, Android, iOS | Windows, macOS, Linux                   |
| IDE         | Qt Creator                          | Xcode, Visual Studio ë“± (ë³„ë„ IDE ì—†ìŒ) |
| ë¹Œë“œ ì‹œìŠ¤í…œ | CMake, QMake                        | CMake                                   |

### 2. ğŸ§° ì„¤ì¹˜ ë°©ë²•

#### Qt (Linux ê¸°ì¤€)

```
sudo apt install qtbase5-dev qtcreator
```

#### wxWidgets (Linux ê¸°ì¤€)

```
sudo apt install libwxgtk3.0-dev
```

> ìœˆë„ìš°ëŠ” Qt ê³µì‹ ì„¤ì¹˜ í”„ë¡œê·¸ë¨ ë˜ëŠ” [wxWidgets GitHub](https://github.com/wxWidgets/wxWidgets) ì°¸ê³ 

### 3. âœï¸ Qt ê¸°ë³¸ ì˜ˆì œ (Hello World)

```
// main.cpp
#include <QApplication>
#include <QPushButton>

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    QPushButton button("Hello, Qt!");
    button.resize(200, 100);
    button.show();

    return app.exec();
}
```

#### CMakeLists.txt

```
cmake_minimum_required(VERSION 3.14)
project(HelloQt)

find_package(Qt5 COMPONENTS Widgets REQUIRED)

add_executable(main main.cpp)
target_link_libraries(main Qt5::Widgets)
```

```
cmake -Bbuild -H.
cmake --build build
./build/main
```

### 4. âœï¸ wxWidgets ê¸°ë³¸ ì˜ˆì œ (Hello World)

```
// main.cpp
#include <wx/wx.h>

class MyApp : public wxApp {
public:
    virtual bool OnInit() override;
};

class MyFrame : public wxFrame {
public:
    MyFrame() : wxFrame(nullptr, wxID_ANY, "Hello wxWidgets", wxDefaultPosition, wxSize(300, 200)) {
        new wxButton(this, wxID_ANY, "Click Me", wxPoint(10, 10));
    }
};

IMPLEMENT_APP(MyApp)

bool MyApp::OnInit() {
    MyFrame* frame = new MyFrame();
    frame->Show(true);
    return true;
}
```

#### CMakeLists.txt

```
cmake_minimum_required(VERSION 3.14)
project(HelloWx)

find_package(wxWidgets REQUIRED COMPONENTS core base)

include(${wxWidgets_USE_FILE})
add_executable(main main.cpp)
target_link_libraries(main ${wxWidgets_LIBRARIES})
```

### 5. ğŸ§  í•µì‹¬ ê°œë… ë¹„êµ

| ê¸°ëŠ¥                | Qt                                                  | wxWidgets                      |
| ------------------- | --------------------------------------------------- | ------------------------------ |
| ì‹œê·¸ë„/ìŠ¬ë¡¯         | `connect(sender, SIGNAL(...), receiver, SLOT(...))` | ì´ë²¤íŠ¸ í…Œì´ë¸” ì‚¬ìš©             |
| ìœ„ì ¯ ë°°ì¹˜           | QHBoxLayout, QVBoxLayout, QGridLayout               | `wxBoxSizer`, `wxGridSizer` ë“± |
| ìŠ¤íƒ€ì¼ ì»¤ìŠ¤í„°ë§ˆì´ì§• | QSS (CSS ìœ ì‚¬)                                      | ê¸°ë³¸ ì œê³µ ìœ„ì ¯ ìŠ¤íƒ€ì¼ë§Œ ê°€ëŠ¥   |
| 2D/3D ê·¸ë˜í”½        | QPainter, QGraphicsView, Qt3D                       | wxDC, OpenGL ì§ì ‘ ì‚¬ìš©         |
| ë„¤ì´í‹°ë¸Œ ë£©         | âŒ (ë™ì¼í•œ UI ì œê³µ)                                  | âœ… OSì— ë”°ë¼ ìì—°ìŠ¤ëŸ½ê²Œ ë³€í•¨    |

### 6. ğŸ’¡ ê³ ê¸‰ ê¸°ëŠ¥ë“¤

| ê¸°ëŠ¥            | Qt                            | wxWidgets        |
| --------------- | ----------------------------- | ---------------- |
| ë©€í‹°ì“°ë ˆë”©      | QThread                       | wxThread         |
| íŒŒì¼ ë‹¤ì´ì–¼ë¡œê·¸ | QFileDialog                   | wxFileDialog     |
| ë„¤íŠ¸ì›Œí¬        | QtNetwork (HTTP, TCP ë“± ë‚´ì¥) | wxSocket ë“±      |
| OpenGL ì—°ë™     | `QOpenGLWidget`               | `wxGLCanvas`     |
| ë””ìì´ë„ˆ íˆ´     | âœ… Qt Designer (Drag&Drop)     | âŒ ì§ì ‘ ì‘ì„± í•„ìš” |

### 7. ğŸ§ª ì‹¤ì „ í™œìš© ì˜ˆì‹œ

| ì˜ˆì œ        | Qt                              | wxWidgets                          |
| ----------- | ------------------------------- | ---------------------------------- |
| í¼ ê¸°ë°˜ ì•±  | Qt Designer UI íŒŒì¼ + C++ ì—°ê²°  | í´ë˜ìŠ¤ë¡œ Frame/Panel êµ¬ì„±          |
| ì±„íŒ… ì•±     | `QTcpSocket`, `QWebSocket`      | `wxSocketClient`, `wxSocketServer` |
| ì´ë¯¸ì§€ ë·°ì–´ | `QPixmap`, `QImage`, `QPainter` | `wxBitmap`, `wxImage`, `wxDC`      |
| ê²Œì„ íˆ´     | QGraphicsScene / ImGui ì—°ë™     | wxGLCanvas + ì§ì ‘ êµ¬í˜„             |

### âœ… ìš”ì•½ ì •ë¦¬

| í•­ëª©          | Qt                                        | wxWidgets                                |
| ------------- | ----------------------------------------- | ---------------------------------------- |
| ì„±ìˆ™ë„        | ë§¤ìš° ì„±ìˆ™ (ìƒìš© í™œìš©ë„ ë†’ìŒ)              | ê²½ëŸ‰, ì˜¤í”ˆì†ŒìŠ¤ ì¹œí™”ì                     |
| ì§„ì…ì¥ë²½      | ì¤‘ê¸‰ (ë¹Œë“œ ì‹œìŠ¤í…œ, ì‹œê·¸ë„/ìŠ¬ë¡¯ í•™ìŠµ í•„ìš”) | ê°„ë‹¨í•œ í”„ë ˆì„ êµ¬ì¡°ë¡œ ì‹œì‘ ì‰¬ì›€           |
| ìƒìš© ì•± ê°œë°œ  | âœ… ë§¤ìš° í™œë°œ                               | âš ï¸ ìƒëŒ€ì ìœ¼ë¡œ ì ìŒ                        |
| GUI íˆ´í‚· ê°•ë„ | ë§¤ìš° í’ë¶€                                 | ìµœì†Œí•œì˜ ê¸°ëŠ¥ + ë„¤ì´í‹°ë¸Œ ê°ì„±            |
| ì¶”ì²œ ëŒ€ìƒ     | ì•±/íˆ´ ì œì‘, ì»¤ìŠ¤í…€ UI í•„ìš”                | ê°„ë‹¨í•œ ìœ í‹¸ë¦¬í‹° GUI, ìµœì†Œ ì¢…ì†ì„± ì¶”êµ¬ ì‹œ |

## ë¨¸ì‹ ëŸ¬ë‹/ì˜ìƒì²˜ë¦¬ (OpenCV, TensorRT)

### 1. ğŸ¯ ê°œìš” ë¹„êµ

| í•­ëª©      | OpenCV                           | TensorRT                               |
| --------- | -------------------------------- | -------------------------------------- |
| ëª©ì       | ì»´í“¨í„° ë¹„ì „ / ì´ë¯¸ì§€ ì²˜ë¦¬        | ê³ ì† ë”¥ëŸ¬ë‹ ì¶”ë¡                        |
| ì–¸ì–´ ì§€ì› | C++, Python, Java ë“±             | C++, Python                            |
| GPU ì§€ì›  | CUDA ê¸°ë°˜ ì¼ë¶€ ëª¨ë“ˆ ì§€ì›         | âœ… NVIDIA GPU ì „ìš©                      |
| íŠ¹ì§•      | ë‹¤ì–‘í•œ ì´ë¯¸ì§€ ì²˜ë¦¬ ì•Œê³ ë¦¬ì¦˜ ë‚´ì¥ | ë”¥ëŸ¬ë‹ ëª¨ë¸ ìµœì í™” ë° ì¶”ë¡  ê°€ì†        |
| ìš©ë„      | ì–¼êµ´ ì¸ì‹, ê°ì²´ ì¶”ì , í•„í„° ë“±    | YOLO, ResNet, MobileNet ì¶”ë¡  ì†ë„ ê°œì„  |

### 2. ğŸ“¦ ì„¤ì¹˜ ë°©ë²•

#### OpenCV (Ubuntu)

```
sudo apt install libopencv-dev
```

#### TensorRT (Ubuntu NVIDIA GPU í•„ìˆ˜)

- NVIDIA ê³µì‹ TensorRT SDK ì„¤ì¹˜ (https://developer.nvidia.com/tensorrt)
- ë˜ëŠ” Docker ì´ë¯¸ì§€ ì‚¬ìš© ê¶Œì¥

### 3. âœï¸ OpenCV ê¸°ë³¸ ì˜ˆì œ: ì´ë¯¸ì§€ ì½ê¸° & í•„í„° ì ìš©

```
#include <opencv2/opencv.hpp>

int main() {
    cv::Mat img = cv::imread("sample.jpg");
    if (img.empty()) return -1;

    cv::Mat gray, blurred;
    cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);
    cv::GaussianBlur(gray, blurred, cv::Size(5,5), 0);

    cv::imshow("Blurred", blurred);
    cv::waitKey(0);
}
```

#### ì»´íŒŒì¼

```
g++ main.cpp -o app `pkg-config --cflags --libs opencv4`
```

### 4. ğŸ§  OpenCV ì£¼ìš” ê¸°ëŠ¥ë“¤

| ê¸°ëŠ¥             | ì˜ˆì‹œ í•¨ìˆ˜                                       |
| ---------------- | ----------------------------------------------- |
| ì´ë¯¸ì§€ ì…ì¶œë ¥    | `imread`, `imwrite`, `imshow`                   |
| ìƒ‰ìƒ ë³€í™˜        | `cvtColor()`                                    |
| ë¸”ëŸ¬/í•„í„°        | `GaussianBlur`, `medianBlur`, `bilateralFilter` |
| ìœ¤ê³½ì„  ê²€ì¶œ      | `Canny`, `findContours`                         |
| ê°ì²´ ê²€ì¶œ        | `HaarCascade`, `DNN ëª¨ë“ˆ`                       |
| ì˜ìƒ ì¶”ì         | `calcOpticalFlowPyrLK`                          |
| ë”¥ëŸ¬ë‹ ëª¨ë¸ ì¶”ë¡  | `cv::dnn::Net` (`readNetFromONNX` ë“±)           |

### 5. âœï¸ OpenCV + DNN: ONNX ëª¨ë¸ ì¶”ë¡  ì˜ˆì œ

```
#include <opencv2/opencv.hpp>
#include <opencv2/dnn.hpp>

int main() {
    auto net = cv::dnn::readNetFromONNX("model.onnx");
    net.setPreferableBackend(cv::dnn::DNN_BACKEND_CUDA);  // GPU ì‚¬ìš©
    net.setPreferableTarget(cv::dnn::DNN_TARGET_CUDA);

    cv::Mat img = cv::imread("input.jpg");
    cv::Mat blob = cv::dnn::blobFromImage(img, 1.0/255.0, {224,224}, {}, true);
    net.setInput(blob);

    cv::Mat output = net.forward();
    std::cout << "Output shape: " << output.size << std::endl;
}
```

### 6. ğŸš€ TensorRTë€?

> TensorRTëŠ” NVIDIA GPUì—ì„œ **ë”¥ëŸ¬ë‹ ì¶”ë¡ ì„ ìµœì í™”/ê°€ì†**í•˜ê¸° ìœ„í•œ í”„ë ˆì„ì›Œí¬.

- **ONNX â†’ TensorRT ì—”ì§„ìœ¼ë¡œ ë³€í™˜**
- INT8 / FP16 ì–‘ìí™”, ë ˆì´ì–´ í“¨ì „, Tensor Fusion ì§€ì›
- ë§¤ìš° ë¹ ë¥¸ ì¶”ë¡  ê°€ëŠ¥ (YOLO, ResNet ë“±)

### 7. ğŸ“¦ TensorRT ì¶”ë¡  ê¸°ë³¸ íë¦„

1. ONNX ëª¨ë¸ ì¤€ë¹„ (`model.onnx`)
2. TensorRT ë¹Œë”ë¡œ `.engine` ìƒì„±
3. ì—”ì§„ ë¡œë“œ í›„ ì…ë ¥/ì¶œë ¥ ë²„í¼ ê´€ë¦¬
4. ì¶”ë¡  ì‹¤í–‰

### 8. âœï¸ TensorRT ì˜ˆì œ: ONNX â†’ ì¶”ë¡  (C++)

```
// ê°„ë‹¨í™”ëœ ì¶”ë¡  ì˜ˆ (ì„¸ë¶€ êµ¬ì¡°ëŠ” ë³µì¡ â†’ ì‹¤ì „ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬í™” ê¶Œì¥)
#include "NvInfer.h"
#include "NvOnnxParser.h"

using namespace nvinfer1;

class Logger : public ILogger {
    void log(Severity severity, const char* msg) noexcept override {
        if (severity <= Severity::kWARNING) std::cout << msg << std::endl;
    }
};

int main() {
    Logger logger;
    IBuilder* builder = createInferBuilder(logger);
    auto network = builder->createNetworkV2(0);
    auto parser = nvonnxparser::createParser(*network, logger);

    parser->parseFromFile("model.onnx", 1);
    auto config = builder->createBuilderConfig();
    config->setFlag(BuilderFlag::kFP16);
    auto engine = builder->buildEngineWithConfig(*network, *config);
    
    // ì—”ì§„ ì €ì¥ í›„ ì¬ì‚¬ìš© ê°€ëŠ¥ (serialize -> save)

    // Inference ì‹œì—ëŠ” execution context ìƒì„± í›„ ì…ë ¥/ì¶œë ¥ ë°”ì¸ë”©
}
```

### 9. ğŸ§  TensorRT íŠ¹ì§• ë° íŒ

| í•­ëª©      | ì„¤ëª…                                  |
| --------- | ------------------------------------- |
| ì‚¬ìš© ì–¸ì–´ | C++, Python                           |
| GPU í•„ìˆ˜  | NVIDIA GPU, CUDA â‰¥ 11                 |
| ì…ë ¥ í˜•ì‹ | ONNX (.onnx)                          |
| ìµœì í™”    | INT8, FP16, ë ˆì´ì–´ í“¨ì „               |
| í™œìš© ì˜ˆ   | YOLOv5, BERT, MobileNet, EfficientNet |

### 10. âœ… OpenCV vs TensorRT ìš”ì•½ ë¹„êµ

| í•­ëª©      | OpenCV                       | TensorRT               |
| --------- | ---------------------------- | ---------------------- |
| ëª©ì       | ì´ë¯¸ì§€ ì²˜ë¦¬, ë¹„ì „ ë¶„ì„       | ê³ ì† ì¶”ë¡  ìµœì í™”       |
| íŠ¹ì§•      | DNN ë‚´ì¥ ëª¨ë“ˆ ì¡´ì¬           | GPU ìµœì í™”ëœ ì—”ì§„ ì‚¬ìš© |
| GPU í™œìš©  | ì¼ë¶€ CUDA ì§€ì›               | í•„ìˆ˜                   |
| ì…ë ¥      | ì´ë¯¸ì§€/ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼         | ONNX â†’ ì—”ì§„            |
| í•™ìŠµ ê¸°ëŠ¥ | âŒ (ì¶”ë¡  ì „ìš©)                | âŒ (ì¶”ë¡  ì „ìš©)          |
| ê¶Œì¥ ìš©ë„ | í•„í„°ë§, ì‹œê°í™”, ê°ì²´ ì¶”ì  ë“± | YOLO, ResNet ê³ ì† ì¶”ë¡  |

## ë¡œë´‡ ì œì–´ ë° ROS2 ì—°ë™

### 1. ğŸ¯ ì „ì²´ êµ¬ì¡° ê°œìš”

> ë¡œë´‡ ì œì–´ ì‹œìŠ¤í…œì€ **í•˜ë“œì›¨ì–´ ì œì–´ ê³„ì¸µ + ì¸ì‹/ê³„íš ê³„ì¸µ + ROS 2 í†µì‹  ê³„ì¸µ**ìœ¼ë¡œ êµ¬ì„±ë¼.

#### ê¸°ë³¸ ì•„í‚¤í…ì²˜

```
[ì„¼ì„œ/ëª¨í„° ë“œë¼ì´ë²„]
        â†‘
[í•˜ë“œì›¨ì–´ ì¸í„°í˜ì´ìŠ¤ (Serial, I2C, CAN, GPIO)]
        â†‘
[ë¡œìš°ë ˆë²¨ ì œì–´ ëª¨ë“ˆ (PID, PWM, ëª¨í„° ë“œë¼ì´ë²„)]
        â†‘
[ROS 2 ë…¸ë“œ (cmd_vel, joint_states, odom, sensor_msgs)]
        â†‘
[rviz / nav2 / SLAM / perception]
```

### 2. ğŸ§© ROS 2 ì—°ë™ ë°©ì‹ í•µì‹¬ êµ¬ì„±

| êµ¬ì„± ìš”ì†Œ           | ì„¤ëª…                                             |
| ------------------- | ------------------------------------------------ |
| í•˜ë“œì›¨ì–´ ì¸í„°í˜ì´ìŠ¤ | `ros2_control`, `custom driver`, `serial node`   |
| ëª…ë ¹ ì…ë ¥           | `cmd_vel`, `trajectory_msgs`, `joint_trajectory` |
| ìƒíƒœ í”¼ë“œë°±         | `joint_states`, `odom`, `sensor_msgs`            |
| ì—°ë™ ë°©ì‹           | topic pub/sub, service, action, parameter        |

### 3. ğŸ”Œ ì˜ˆì œ: ëª¨í„° ì œì–´ ROS 2 ë…¸ë“œ (ì‹œë¦¬ì–¼ ì œì–´ ê¸°ë°˜)

#### 1) ì‹œë¦¬ì–¼ì„ í†µí•œ PWM ëª…ë ¹ ì „ë‹¬

```
#include <rclcpp/rclcpp.hpp>
#include <geometry_msgs/msg/twist.hpp>
#include <serial/serial.h>

class MotorDriver : public rclcpp::Node {
public:
    MotorDriver() : Node("motor_driver") {
        serial_.setPort("/dev/ttyUSB0");
        serial_.setBaudrate(115200);
        serial_.open();

        sub_ = this->create_subscription<geometry_msgs::msg::Twist>(
            "cmd_vel", 10,
            [this](const geometry_msgs::msg::Twist::SharedPtr msg) {
                double left = msg->linear.x - msg->angular.z;
                double right = msg->linear.x + msg->angular.z;
                std::string cmd = "L" + std::to_string(int(left * 255)) +
                                  "R" + std::to_string(int(right * 255)) + "\n";
                serial_.write(cmd);
            });
    }

private:
    rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr sub_;
    serial::Serial serial_;
};
```

```
ros2 run your_pkg motor_driver
```

### 4. âš™ï¸ ì„¼ì„œ ë°ì´í„° â†’ ROS 2 í† í”½ ë°œí–‰

```
sensor_msgs::msg::Imu imu_msg;
imu_msg.orientation.x = qx;
imu_msg.linear_acceleration.x = ax;
imu_pub_->publish(imu_msg);
```

### 5. ğŸ§  `ros2_control`ì„ ì´ìš©í•œ í•˜ë“œì›¨ì–´ ì¶”ìƒí™”

```
[controller_manager]
       â†“
[ros2_control_interface]
       â†“
[custom RobotHardware interface]
       â†” ì‹¤ì œ í•˜ë“œì›¨ì–´
```

â†’ ì˜ˆ: `JointStateHandle`, `JointCommandHandle`ë¡œ ëª¨í„° ìƒíƒœì™€ ëª…ë ¹ ê´€ë¦¬

### 6. ğŸš— ROS 2 ì œì–´ íë¦„ ì˜ˆì‹œ (ì´ë™ë¡œë´‡)

| ëª…ë ¹ íë¦„                       | ë©”ì‹œì§€                         |
| ------------------------------- | ------------------------------ |
| `/cmd_vel` â†’ ëª¨í„° ì œì–´          | `geometry_msgs::msg::Twist`    |
| ì—”ì½”ë” â†’ `/odom`                | `nav_msgs::msg::Odometry`      |
| IMU â†’ `/imu/data`               | `sensor_msgs::msg::Imu`        |
| `/joint_states` â†’ rviz          | `sensor_msgs::msg::JointState` |
| `/tf` í”„ë ˆì„ â†’ odom â†’ base_link | ì¢Œí‘œê³„ íŠ¸ë¦¬ ê´€ë¦¬               |

### 7. ğŸ§ª ì‹¤ì „ í”„ë¡œì íŠ¸ ì˜ˆì‹œ: 2ë¥œ ì°¨ ROS 2 ì—°ë™

```
[ë””ë°”ì´ìŠ¤] â†’ STM32, Arduino, Jetson, Pi
[í†µì‹ ]     â†’ Serial / CAN / TCP
[ë…¸ë“œ]     â†’ motor_node, imu_node, odom_node
[í†µí•©]     â†’ URDF + rviz + nav2 + tf2 + joy_teleop
```

### 8. ğŸ›  ì œì–´ê¸° ì¢…ë¥˜ (`ros2_controllers`)

| ì»¨íŠ¸ë¡¤ëŸ¬                      | ì„¤ëª…                       |
| ----------------------------- | -------------------------- |
| `diff_drive_controller`       | 2ë¥œ ì´ë™ ë¡œë´‡              |
| `joint_trajectory_controller` | ê´€ì ˆ ì œì–´ ë¡œë´‡             |
| `forward_command_controller`  | ê¸°ë³¸ ìœ„ì¹˜/ì†ë„ ëª…ë ¹ ì»¨íŠ¸ë¡¤ |
| `imu_sensor_broadcaster`      | IMU í† í”½ ë¸Œë¡œë“œìºìŠ¤í„°      |

### 9. ğŸ§  ì‹œìŠ¤í…œ ì„¤ê³„ ì‹œ ê³ ë ¤ ìš”ì†Œ

| í•­ëª©                   | ì„¤ëª…                                              |
| ---------------------- | ------------------------------------------------- |
| ì œì–´ ì£¼ê¸°              | ROS ë£¨í”„ ì£¼ê¸° (50~100 Hz) vs í•˜ë“œì›¨ì–´ ì‹¤ì‹œê°„ ë£¨í”„ |
| ë°ì´í„° ìœ ì‹¤            | ì‹œë¦¬ì–¼/ì„¼ì„œ íŒŒì‹± ì‹œ CRC/íŒ¨í‚· ì²˜ë¦¬                 |
| ì¢Œí‘œê³„ ê´€ë¦¬            | `base_link`, `odom`, `map` í”„ë ˆì„ ì—°ê²° (`tf2`)    |
| í† í”½ vs ì„œë¹„ìŠ¤ vs ì•¡ì…˜ | ì£¼ê¸° vs ìš”ì²­/ì‘ë‹µ vs ì¥ê¸° ì œì–´ì˜ ì„ íƒ             |

### âœ… ìš”ì•½ ì •ë¦¬

| êµ¬ì„± ìš”ì†Œ     | ì—­í•                                                |
| ------------- | -------------------------------------------------- |
| ROS 2 Node    | ëª¨í„° ì œì–´, ì„¼ì„œ ìˆ˜ì‹ , ì£¼í–‰ ëª…ë ¹ ì²˜ë¦¬               |
| í•˜ë“œì›¨ì–´ ì—°ë™ | Serial/CAN â†’ ëª¨í„°/ì„¼ì„œ ì—°ê²°                        |
| ë©”ì‹œì§€ íƒ€ì…   | `cmd_vel`, `joint_states`, `odom`, `imu`           |
| ê³ ê¸‰ êµ¬ì¡°     | `ros2_control`, `controller_manager`, `rqt`, `tf2` |
| ì¶”ì²œ ì¡°í•©     | Jetson + ROS 2 + Teensy/STM32 + CAN or Serial      |