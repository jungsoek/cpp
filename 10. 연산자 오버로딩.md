# 10. 연산자 오버로딩

## 멤버 함수 / 비멤버 함수 방식

C++에서 함수를 설계할 때, **클래스 내부에 포함할지(멤버 함수)** 또는 **외부에서 독립적으로 정의할지(비멤버 함수)**를 결정하는 것은 중요한 설계 선택이다.
 이 선택은 **캡슐화, 책임 분리, 인터페이스 명확성** 등과 직결된다.

### ✅ 멤버 함수 (Member Function)

#### 📌 개념

- 클래스 내부에 정의되어, **해당 클래스 객체에 종속되는 함수**
- 객체의 **멤버 변수에 직접 접근 가능**
- `this` 포인터를 암묵적으로 받음

#### 📌 예시

```
class Vector2D {
    double x, y;

public:
    Vector2D(double x, double y) : x(x), y(y) {}

    double length() const {
        return std::sqrt(x * x + y * y);
    }
};
```

```
Vector2D v(3, 4);
std::cout << v.length();  // 출력: 5
```

#### 📌 특징

| 항목             | 설명                                |
| ---------------- | ----------------------------------- |
| 클래스 내부 선언 | 예 (`class` 블록 안에서 선언)       |
| `this` 사용 가능 | 예 (객체 자신을 가리킴)             |
| 멤버 변수 접근   | 직접 가능 (`x`, `y` 등)             |
| 객체 필요 여부   | 객체가 있어야 호출 가능 (`obj.f()`) |

### ✅ 비멤버 함수 (Non-member Function)

#### 📌 개념

- 클래스 외부에 정의된 일반 함수
- 객체를 **인자로 받아서** 동작함
- 클래스에 직접 속하지 않음

#### 📌 예시

```
class Vector2D {
public:
    double x, y;
    Vector2D(double x, double y) : x(x), y(y) {}
};

double length(const Vector2D& v) {
    return std::sqrt(v.x * v.x + v.y * v.y);
}
cpp코드 복사Vector2D v(3, 4);
std::cout << length(v);  // 출력: 5
```

#### 📌 특징

| 항목             | 설명                                            |
| ---------------- | ----------------------------------------------- |
| 클래스 외부 정의 | 예 (`class` 바깥에서 정의)                      |
| `this` 사용      | 불가                                            |
| 멤버 접근        | `public` 멤버만 접근 가능 (`v.x` 등)            |
| 객체 필요 여부   | 객체를 인자로 명시적으로 전달해야 함 (`f(obj)`) |

### 📌 언제 멤버 함수로 만들까?

| 상황                                              | 멤버 함수로 만들기 적절 |
| ------------------------------------------------- | ----------------------- |
| 해당 함수가 객체의 **내부 상태를 직접 참조**할 때 | ✅                       |
| 해당 동작이 **객체의 책임인 동작**일 때           | ✅                       |
| `private` 멤버에 접근해야 할 때                   | ✅                       |

### 📌 언제 비멤버 함수로 만들까?

| 상황                                                    | 비멤버 함수로 만들기 적절 |
| ------------------------------------------------------- | ------------------------- |
| 해당 함수가 **객체 외부에서 객체를 조작**하는 경우      | ✅                         |
| 두 개 이상의 객체를 비교/결합/출력하는 동작일 경우      | ✅                         |
| 클래스 책임이 아닌 일반 알고리즘이나 도우미 함수인 경우 | ✅                         |

### 📌 예: 연산자 오버로딩의 경우

- `+`, `==`, `<<` 등의 **연산자는 비멤버 함수로 구현하는 것이 일반적**

```
class Vector2D {
public:
    double x, y;
    Vector2D(double x, double y) : x(x), y(y) {}
};

Vector2D operator+(const Vector2D& a, const Vector2D& b) {
    return Vector2D(a.x + b.x, a.y + b.y);
}
```

### 📎 요약 비교표

| 구분              | 멤버 함수               | 비멤버 함수                          |
| ----------------- | ----------------------- | ------------------------------------ |
| 정의 위치         | 클래스 내부             | 클래스 외부                          |
| this 사용         | 가능                    | 불가능                               |
| private 멤버 접근 | 가능                    | ❌ 불가능 (친구 함수로 선언해야 가능) |
| 적합한 상황       | 내부 상태를 다루는 기능 | 외부 조작 또는 일반 유틸리티 함수    |
| 재사용성          | 객체에 종속됨           | 범용 알고리즘으로 재사용 가능        |

### ✅ 결론

> 멤버 함수는 **객체의 책임을 수행하는 함수**,
>  비멤버 함수는 **객체 외부에서 정의된 일반 기능 또는 보조 연산 함수**라고 이해하면 좋다.
>
> 객체 지향 설계에서 가장 중요한 기준은
>  **"이 함수는 이 객체가 책임져야 할 일인가?"**를 묻는 것부터 시작이다.
>  **그렇다면 멤버 함수**, 아니라면 **비멤버로 밖에 두는 것이 깔끔한 설계**다.

## 산술, 비교, 대입, 증감, 함수 호출 연산자

C++에서는 연산자를 클래스에 맞게 **오버로딩(overload)**할 수 있다.
 즉, **사용자 정의 타입(클래스)**에 대해 `+`, `==`, `=`, `++`, `()` 등의 연산자 동작을 **재정의**할 수 있다는 뜻이다.

아래는 **산술, 비교, 대입, 증감, 함수 호출 연산자**의 오버로딩에 대한 핵심 개념과 예시 정리다.

### ✅ 1. 산술 연산자 (`+`, `-`, `*`, `/` 등)

```
class Vector {
public:
    double x, y;

    Vector(double x, double y) : x(x), y(y) {}

    Vector operator+(const Vector& rhs) const {
        return Vector(x + rhs.x, y + rhs.y);
    }
};
cpp코드 복사Vector a(1, 2), b(3, 4);
Vector c = a + b;  // operator+ 호출
```

- 일반적으로 **비멤버 함수**로도 구현 가능
- **리턴 값은 새로운 객체**로 반환하는 것이 일반적

### ✅ 2. 비교 연산자 (`==`, `!=`, `<`, `>`, `<=`, `>=`)

```
class Point {
    int x, y;

public:
    Point(int x, int y) : x(x), y(y) {}

    bool operator==(const Point& rhs) const {
        return x == rhs.x && y == rhs.y;
    }

    bool operator!=(const Point& rhs) const {
        return !(*this == rhs);
    }
};
```

- `==`만 정의하고, `!=`은 **그 부정**으로 정의 가능
- C++20부터는 `<=>`(우주선 연산자)로 통합 가능

### ✅ 3. 대입 연산자 (`=`)

```
class Person {
    std::string name;
    int age;

public:
    Person& operator=(const Person& rhs) {
        if (this != &rhs) { // 자기 대입 방지
            name = rhs.name;
            age = rhs.age;
        }
        return *this;
    }
};
```

- **자기 자신으로부터 대입 방지** (`if (this != &rhs)`)
- 반드시 **참조를 반환**해야 `a = b = c` 형태의 연쇄 대입 가능
- 디폴트로 컴파일러가 생성해주지만, **직접 자원 관리 시 필수 구현**

### ✅ 4. 증감 연산자 (`++`, `--`)

#### 📌 전위(prefix): `++a`, `--a`

```
class Counter {
    int value;

public:
    Counter(int v = 0) : value(v) {}

    Counter& operator++() {   // 전위 증가
        ++value;
        return *this;
    }
};
```

#### 📌 후위(postfix): `a++`, `a--`

```
Counter operator++(int) {  // 후위 증가
    Counter temp = *this;
    ++value;
    return temp;
}
```

- 후위 연산자는 **int를 매개변수로 받아야 구분 가능**
- 전위는 참조 반환, 후위는 **값 복사 반환**

### ✅ 5. 함수 호출 연산자 (`()`)

```
class Adder {
    int base;

public:
    Adder(int base) : base(base) {}

    int operator()(int x) const {
        return base + x;
    }
};
cpp코드 복사Adder add5(5);
int result = add5(3);  // 결과: 8
```

- 객체를 **함수처럼 호출 가능하게 만드는 연산자**
- **펑터(functor)** 또는 **함수 객체(function object)** 패턴 구현 시 사용

### 📎 정리 표

| 연산자    | 설명                         | 오버로딩 방식                  |
| --------- | ---------------------------- | ------------------------------ |
| `+ - * /` | 산술 연산자                  | 보통 값 반환                   |
| `== !=`   | 비교 연산자                  | bool 반환                      |
| `=`       | 대입 연산자                  | 자기 대입 방지, 참조 반환      |
| `++ --`   | 증감 연산자 (전위/후위 구분) | 전위: 참조 반환, 후위: 값 반환 |
| `()`      | 함수 호출                    | 파라미터 자유롭게 설계 가능    |

### ✅ 결론

> C++의 연산자 오버로딩은 사용자 정의 타입을 **기본 자료형처럼 직관적으로 사용할 수 있게 해주는 도구**다.
>  특히 연산자 오버로딩은 **벡터, 행렬, 복소수, 스마트 포인터, 함수 객체** 등의 구현에 핵심적으로 사용된다.
>
> 다만, **과도한 오버로딩은 가독성을 해칠 수 있으므로**,
>  연산자 의미가 **논리적으로 자연스럽고 명확한 경우에만** 사용하는 것이 바람직하다.

## 입출력 연산자 오버로딩

C++에서는 **표준 입출력 스트림**(`std::ostream`, `std::istream`)을 통해
 사용자 정의 타입을 직관적으로 출력하거나 입력받을 수 있도록,
 **`<<`(출력), `>>`(입력) 연산자를 오버로딩**할 수 있다.

이 연산자들은 반드시 **비멤버 함수** 또는 **friend 함수**로 정의해야 하며,
 보통 `std::ostream` 또는 `std::istream`에 대한 **참조를 반환**하는 형식으로 작성된다.

### ✅ 출력 연산자 `<<` 오버로딩

#### 📌 기본 형식

```
std::ostream& operator<<(std::ostream& os, const ClassName& obj);
```

- `std::cout << obj;` → 이 함수가 호출됨

#### 📌 예시

```
class Point {
    int x, y;

public:
    Point(int x, int y) : x(x), y(y) {}

    friend std::ostream& operator<<(std::ostream& os, const Point& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};
```

```
Point pt(3, 4);
std::cout << pt;  // 출력: (3, 4)
```

> **`friend` 키워드**는 `p.x`, `p.y`에 접근하기 위한 권한을 부여

### ✅ 입력 연산자 `>>` 오버로딩

#### 📌 기본 형식

```
std::istream& operator>>(std::istream& is, ClassName& obj);
```

- `std::cin >> obj;` → 이 함수가 호출됨

#### 📌 예시

```
class Student {
    std::string name;
    int score;

public:
    friend std::istream& operator>>(std::istream& is, Student& s) {
        return is >> s.name >> s.score;
    }

    friend std::ostream& operator<<(std::ostream& os, const Student& s) {
        return os << s.name << ": " << s.score;
    }
};
```

```
Student s;
std::cin >> s;        // 사용자로부터 입력 받기
std::cout << s;       // 출력: 이름: 점수
```

### 📌 반환은 반드시 `ostream&`, `istream&` 참조

- 스트림 연산자는 **연속적인 사용**을 허용해야 하므로
   반드시 **참조를 반환**해야 한다

```
std::cout << a << b << c;  // 연쇄 가능해야 함
```

### 📎 요약

| 연산자 | 함수 시그니처 형태                                  | 목적                      |
| ------ | --------------------------------------------------- | ------------------------- |
| `<<`   | `std::ostream& operator<<(std::ostream&, const T&)` | 객체를 출력 스트림에 쓰기 |
| `>>`   | `std::istream& operator>>(std::istream&, T&)`       | 입력 스트림에서 객체 읽기 |

### ✅ 결론

> `<<`와 `>>` 오버로딩을 통해 **사용자 정의 객체를 std::cout / std::cin과 직관적으로 연결**할 수 있다.
>  이 방식은 특히 **디버깅, 로깅, 사용자 인터페이스 입력**에서 유용하며,
>  연산자 오버로딩 중에서도 **가장 자주 사용되는 패턴** 중 하나이다.

**즉, 객체를 기본 타입처럼 다루게 해주는 C++의 표현력 강화 도구 중 핵심이다.**

## 연산자 오버로딩의 주의점

연산자 오버로딩은 **C++의 강력한 표현력**을 제공하지만,
 잘못 사용하면 **코드의 의미가 불명확**해지고 **유지보수성이 저하**될 수 있다.
 아래는 연산자 오버로딩을 사용할 때 반드시 고려해야 할 **주의점과 원칙들**이다.

### 📌 1. 의미에 맞게 오버로딩할 것

> **연산자의 직관적인 의미를 훼손하지 말라**

- `+`는 값을 더하고, `==`는 비교해야 한다.
- 예: `Vector + Vector` → 두 벡터의 덧셈
    `Matrix * Matrix` → 행렬 곱
- `+`를 이용해 파일을 병합하거나, `==`를 로그 출력으로 쓰는 건 **비논리적**

✅ 좋은 예:

```
Point operator+(const Point& rhs) const;
```

❌ 나쁜 예:

```
bool operator+(const User& rhs);  // "친구 요청 전송"? → 비직관적
```

### 📌 2. 멤버 함수 vs 비멤버 함수 구분

| 연산자 종류      | 일반적으로 사용하는 방식                       |
| ---------------- | ---------------------------------------------- |
| 대입(`=`)        | 멤버 함수                                      |
| 산술(`+`, `-`)   | 비멤버 또는 friend 함수                        |
| 비교(`==`, `<`)  | 비멤버 또는 friend 함수                        |
| `<<`, `>>`       | 반드시 비멤버 함수 (`ostream`, `istream` 요구) |
| `[]`, `()`, `->` | 반드시 멤버 함수로만 정의 가능                 |

### 📌 3. 연산자 우선순위와 결합법칙은 변경 불가

- 오버로딩은 **연산자 의미**만 바꿀 수 있음
- 연산자의 **우선순위**, **결합 방향**, **평가 순서**는 **언어에 내장된 규칙** 그대로 유지됨

```
a + b * c  // b * c가 먼저 계산됨 (기본 연산자 우선순위)
```

> 따라서 **오버로딩된 연산자라도 괄호로 의도 명확화 필요**

### 📌 4. 부작용 없는 연산자는 `const` 멤버 함수로

```
class Vector {
public:
    Vector operator+(const Vector& rhs) const;  // ✅ 상태 변경 없음
};
```

- `const`를 붙이지 않으면 **읽기 전용 객체에서 사용 불가**

### 📌 5. 대입 연산자는 자기 대입 방지, 참조 반환 필수

```
MyClass& operator=(const MyClass& rhs) {
    if (this != &rhs) {
        // 복사 작업
    }
    return *this;
}
```

- **자기 대입 방지** (`if (this != &rhs)`)
- **반환형은 반드시 참조** → `a = b = c` 가능해야 함

### 📌 6. 후위 증감 연산자에는 `int` 명시

```
Counter operator++(int);    // 후위: dummy int
Counter& operator++();     // 전위
```

- 둘 다 오버로딩할 경우 **명확히 구분 필요**

### 📌 7. 너무 많은 연산자를 오버로딩하지 말 것

- **필요한 경우만 제한적으로** 사용해야 함
- 과도한 오버로딩은 **코드의 의미를 모호하게 만들고**, 디버깅을 어렵게 함

### 📌 8. 논리 연산자(`&&`, `||`, `!`)는 주의 깊게 사용

- `&&`, `||`는 **단락 평가(short-circuiting)**가 기본 동작인데,
   오버로딩 시에는 **이 특성이 유지되지 않음**

```
if (obj1 && obj2)  // 실제론 둘 다 평가됨
```

> 이 때문에 **논리 연산자는 일반적으로 오버로딩하지 않는 것이 바람직**

### ✅ 요약 정리표

| 주의점                    | 설명                                            |
| ------------------------- | ----------------------------------------------- |
| 의미를 지킬 것            | 연산자의 본래 의미를 훼손하지 말 것             |
| 적절한 함수 유형 선택     | 멤버/비멤버 구분 (특히 `<<`, `>>`는 비멤버로)   |
| 우선순위 및 결합법칙 유지 | 오버로딩으로 바꿀 수 없음 → 괄호로 제어         |
| const 정확히 명시         | 읽기 전용 함수는 `const` 붙일 것                |
| 대입 연산자 주의          | 자기 대입 확인 + 참조 반환                      |
| 후위 연산자 구분          | `int` 매개변수로 전후위 구분                    |
| 남용 금지                 | 모든 연산자 오버로딩은 오히려 해악이 될 수 있음 |
| 논리 연산자 피할 것       | `&&`, `                                         |

### ✅ 결론

> 연산자 오버로딩은 **사용자 정의 타입을 자연스럽게 사용할 수 있게 해주는 강력한 도구**지만,
>  반드시 **논리적 일관성과 문맥적 명료성**을 유지해야 한다.
>
> 📌 **“이 연산자의 오버로딩이 정말 직관적인가?”**
>  📌 **“기존 연산자의 의미를 어기지 않았는가?”**
>
> 이 두 질문을 항상 염두에 두고, 필요한 경우에만 신중하게 사용해야 한다.