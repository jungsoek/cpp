# 23. ë””ìì¸ íŒ¨í„´ê³¼ C++

## Singleton, Factory, Strategy, Observer, Adapter ë“±

### ğŸ¯ 1. Singleton íŒ¨í„´

#### ê°œë…

- ì‹œìŠ¤í…œ ì „ì²´ì—ì„œ **ë‹¨ í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤ë§Œ ì¡´ì¬**í•˜ë„ë¡ ë³´ì¥
- ì „ì—­ ì ‘ê·¼ ì§€ì ì„ ì œê³µ

#### êµ¬ì¡°

```
Client â†’ Singleton (static instance ì œê³µ)
```

#### ì˜ˆì œ ì½”ë“œ

```
class Logger {
private:
    Logger() {}
    static Logger* instance;

public:
    static Logger* getInstance() {
        if (!instance)
            instance = new Logger();
        return instance;
    }

    void log(const std::string& msg) {
        std::cout << "[LOG] " << msg << "\n";
    }
};

Logger* Logger::instance = nullptr;
```

#### ì‚¬ìš© ì˜ˆ

- ì „ì—­ ì„¤ì • ê´€ë¦¬
- ë¡œê¹… ì‹œìŠ¤í…œ
- DB ì—°ê²° ê´€ë¦¬ì

#### ì£¼ì˜ì 

- ìŠ¤ë ˆë“œ ì•ˆì „í•˜ê²Œ êµ¬í˜„í•˜ë ¤ë©´ `mutex` í•„ìš”
- `static` ì´ˆê¸°í™” ìˆœì„œ ë¬¸ì œ ì£¼ì˜

### ğŸ­ 2. Factory íŒ¨í„´

#### ê°œë…

- ê°ì²´ ìƒì„±ì„ ì„œë¸Œí´ë˜ìŠ¤ì—ê²Œ ìœ„ì„
- ìƒì„± ë¡œì§ì„ ìº¡ìŠí™”í•˜ì—¬ **í´ë¼ì´ì–¸íŠ¸ì™€ ì œí’ˆ í´ë˜ìŠ¤ë¥¼ ë¶„ë¦¬**

#### êµ¬ì¡°

```
Client â†’ Factory â†’ Product (Interface)
                   â†³ ProductA
                   â†³ ProductB
```

#### ì˜ˆì œ ì½”ë“œ

```
class Shape {
public:
    virtual void draw() = 0;
};

class Circle : public Shape {
public:
    void draw() override { std::cout << "Circle\n"; }
};

class Square : public Shape {
public:
    void draw() override { std::cout << "Square\n"; }
};

class ShapeFactory {
public:
    static Shape* createShape(const std::string& type) {
        if (type == "circle") return new Circle();
        else if (type == "square") return new Square();
        return nullptr;
    }
};
```

#### ì‚¬ìš© ì˜ˆ

- GUI ìœ„ì ¯ ìƒì„±ê¸°
- íŒŒì„œ(parser)ì—ì„œ ë…¸ë“œ íƒ€ì… ê²°ì •
- í”ŒëŸ¬ê·¸ì¸ ë¡œë”©

### ğŸ§  3. Strategy íŒ¨í„´

#### ê°œë…

- ì•Œê³ ë¦¬ì¦˜ êµ°ì„ ì •ì˜í•˜ê³  ê°ê° ìº¡ìŠí™”í•˜ì—¬ **ìƒí˜¸ êµì²´ ê°€ëŠ¥**í•˜ë„ë¡ ë§Œë“¬
- ëŸ°íƒ€ì„ì— ì „ëµì„ êµì²´ ê°€ëŠ¥

#### êµ¬ì¡°

```
Context â†’ Strategy (Interface)
                â†³ ConcreteStrategyA
                â†³ ConcreteStrategyB
```

#### ì˜ˆì œ ì½”ë“œ

```
class SortStrategy {
public:
    virtual void sort(std::vector<int>& v) = 0;
};

class BubbleSort : public SortStrategy {
public:
    void sort(std::vector<int>& v) override { std::cout << "Bubble sort\n"; }
};

class QuickSort : public SortStrategy {
public:
    void sort(std::vector<int>& v) override { std::cout << "Quick sort\n"; }
};

class SortContext {
    SortStrategy* strategy;
public:
    SortContext(SortStrategy* s) : strategy(s) {}
    void execute(std::vector<int>& v) {
        strategy->sort(v);
    }
};
```

#### ì‚¬ìš© ì˜ˆ

- ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ì„ íƒ
- ê²½ë¡œ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ ì„ íƒ (A*, Dijkstra ë“±)
- ê²Œì„ AI ì „ëµ ì „í™˜

### ğŸ‘ 4. Observer íŒ¨í„´

#### ê°œë…

- ê°ì²´ ìƒíƒœ ë³€í™” ì‹œ **ì¢…ì† ê°ì²´(ì˜µì €ë²„)**ì—ê²Œ ìë™ í†µì§€
- **1:N** ì˜ì¡´ì„±

#### êµ¬ì¡°

```
Subject â†’ Observer (Interface)
         â†³ ConcreteObserver1
         â†³ ConcreteObserver2
```

#### ì˜ˆì œ ì½”ë“œ

```
class Observer {
public:
    virtual void update(int value) = 0;
};

class Subject {
    std::vector<Observer*> observers;
    int state;
public:
    void attach(Observer* obs) {
        observers.push_back(obs);
    }

    void setState(int val) {
        state = val;
        for (auto o : observers) o->update(state);
    }
};

class ConcreteObserver : public Observer {
    std::string name;
public:
    ConcreteObserver(std::string n) : name(n) {}
    void update(int value) override {
        std::cout << name << " updated: " << value << "\n";
    }
};
```

#### ì‚¬ìš© ì˜ˆ

- GUI ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ
- ê²Œì„ ìƒíƒœ ë³€í™” ì•Œë¦¼
- ë‰´ìŠ¤/ì£¼ì‹ êµ¬ë… ì‹œìŠ¤í…œ

### ğŸ”Œ 5. Adapter íŒ¨í„´

#### ê°œë…

- **í˜¸í™˜ë˜ì§€ ì•ŠëŠ” ì¸í„°í˜ì´ìŠ¤**ë¥¼ ë§ì¶°ì¤Œ
- ê¸°ì¡´ ì½”ë“œ ì¬ì‚¬ìš©ì„ ìœ„í•œ **ì¤‘ê°„ ë³€í™˜ê¸°**

#### êµ¬ì¡°

```
Client â†’ Adapter â†’ Adaptee
```

#### ì˜ˆì œ ì½”ë“œ

```
class OldPrinter {
public:
    void oldPrint() { std::cout << "Old printing\n"; }
};

class Printer {
public:
    virtual void print() = 0;
};

class PrinterAdapter : public Printer {
    OldPrinter* adaptee;
public:
    PrinterAdapter(OldPrinter* o) : adaptee(o) {}
    void print() override {
        adaptee->oldPrint();
    }
};
```

#### ì‚¬ìš© ì˜ˆ

- ë ˆê±°ì‹œ ì‹œìŠ¤í…œê³¼ì˜ ì—°ê²°
- ì™¸ë¶€ API â†” ë‚´ë¶€ í´ë˜ìŠ¤ í†µí•©
- C++ â†” C í˜¸í™˜ ê³„ì¸µ

### âœ… 5ê°œ íŒ¨í„´ ìš”ì•½ ë¹„êµ

| íŒ¨í„´          | ëª©ì                     | ì‚¬ìš© ì‹œì                        |
| ------------- | ----------------------- | ------------------------------- |
| **Singleton** | ë‹¨ì¼ ì¸ìŠ¤í„´ìŠ¤ ì „ì—­ ê³µìœ  | ì „ì—­ ìƒíƒœ ê´€ë¦¬                  |
| **Factory**   | ê°ì²´ ìƒì„± ìœ„ì„          | ê°ì²´ ìƒì„± ë‹¤ì–‘ì„± í•„ìš” ì‹œ        |
| **Strategy**  | ì•Œê³ ë¦¬ì¦˜ ìº¡ìŠí™”         | ì•Œê³ ë¦¬ì¦˜ êµì²´ ìœ ì—°ì„± í•„ìš” ì‹œ    |
| **Observer**  | ìƒíƒœ ë³€í™” í†µì§€          | ì´ë²¤íŠ¸ ê¸°ë°˜ êµ¬ì¡°                |
| **Adapter**   | ì¸í„°í˜ì´ìŠ¤ í˜¸í™˜         | ë ˆê±°ì‹œ ì½”ë“œ ë˜ëŠ” ì™¸ë¶€ ëª¨ë“ˆ í†µí•© |

## CRTP(Curiously Recurring Template Pattern)

### 1. ğŸ¯ ì •ì˜

> CRTPëŠ” í´ë˜ìŠ¤ê°€ **ìê¸° ìì‹ ì„ í…œí”Œë¦¿ ì¸ìë¡œ ê°–ëŠ” ê¸°ë°˜ í´ë˜ìŠ¤ì— ìƒì†**í•˜ëŠ” íŒ¨í„´ì´ì•¼.

```
template <typename Derived>
class Base {
    // ...
};

class Derived : public Base<Derived> {
    // ...
};
```

ì´ë¦„ì²˜ëŸ¼ "ê¸°ë¬˜í•˜ê²Œ ìê¸° ìì‹ ì„ í…œí”Œë¦¿ ì¸ìë¡œ ë„˜ê²¨ì£¼ëŠ” íŒ¨í„´"ì´ê¸° ë•Œë¬¸ì— **Curiously Recurring**ì´ë¼ëŠ” ë³„ëª…ì´ ë¶™ì—ˆë‹¤.

### 2. ğŸ§© êµ¬ì¡° ì˜ˆì‹œ

```
template <typename Derived>
class Base {
public:
    void interface() {
        static_cast<Derived*>(this)->implementation();
    }
};

class Derived : public Base<Derived> {
public:
    void implementation() {
        std::cout << "Derived::implementation()\n";
    }
};
int main() {
    Derived d;
    d.interface();  // â†’ Derived::implementation() í˜¸ì¶œ
}
```

```
int main() {
    Derived d;
    d.interface();  // â†’ Derived::implementation() í˜¸ì¶œ
}
```

> âœ… í•µì‹¬: `Base<Derived>` ë‚´ë¶€ì—ì„œ `static_cast<Derived*>(this)`ë¥¼ ì‚¬ìš©í•´
>  **ì •ì  ë°”ì¸ë”©ì„ í™œìš©í•œ ë‹¤í˜•ì„±**ì„ êµ¬í˜„í•œë‹¤ëŠ” ê²ƒ.

### 3. ğŸ§  CRTPì˜ ì£¼ìš” ëª©ì 

| ëª©ì                   | ì„¤ëª…                                            |
| --------------------- | ----------------------------------------------- |
| ì •ì  ë‹¤í˜•ì„±           | ê°€ìƒ í•¨ìˆ˜ ì—†ì´ ë‹¤í˜•ì„± êµ¬í˜„ (ì„±ëŠ¥ í–¥ìƒ)          |
| ì½”ë“œ ì¬ì‚¬ìš©           | í…œí”Œë¦¿ ê¸°ë°˜ ë² ì´ìŠ¤ í´ë˜ìŠ¤ì—ì„œ ê³µí†µ ë¡œì§ ì²˜ë¦¬    |
| ì»´íŒŒì¼ íƒ€ì„ ê¸°ëŠ¥ í™•ì¥ | ì»´íŒŒì¼ ì‹œì ì— ê¸°ëŠ¥ ê²°ì • (zero-cost abstraction) |
| ì •ì±… ê¸°ë°˜ ì„¤ê³„        | ìœ ì—°í•˜ê²Œ ê¸°ëŠ¥ ì¡°í•© ê°€ëŠ¥ (Policy-based design)   |

### 4. ğŸ“Œ ì¼ë°˜ ê°€ìƒ í•¨ìˆ˜ vs CRTP

#### ğŸ” ì „í†µì ì¸ ê°€ìƒ í•¨ìˆ˜

```
class Base {
public:
    virtual void func() = 0;
};

class Derived : public Base {
public:
    void func() override { std::cout << "Derived\n"; }
};
```

- ëŸ°íƒ€ì„ ê°€ìƒ í˜¸ì¶œ (vtable)
- ì„±ëŠ¥ ì €í•˜ ê°€ëŠ¥

#### âš¡ CRTP ë°©ì‹

```
template <typename Derived>
class Base {
public:
    void func() {
        static_cast<Derived*>(this)->func_impl();
    }
};

class Derived : public Base<Derived> {
public:
    void func_impl() {
        std::cout << "Derived (CRTP)\n";
    }
};
```

- ì •ì  ë””ìŠ¤íŒ¨ì¹˜
- **ì¸ë¼ì¸ ìµœì í™” ê°€ëŠ¥**, **vtable ì—†ìŒ**

### 5. ğŸ§ª ì‹¤ì „ ì˜ˆì œ: ë©”ì„œë“œ ì¶”ì ê¸°

```
template <typename Derived>
class Tracker {
public:
    void call() {
        std::cout << "[TRACE] ";
        static_cast<Derived*>(this)->callImpl();
    }
};

class Logic : public Tracker<Logic> {
public:
    void callImpl() {
        std::cout << "Logic executed\n";
    }
};

int main() {
    Logic l;
    l.call();
}
```

### 6. ğŸ— ì •ì±… ê¸°ë°˜ ì„¤ê³„ ì˜ˆì‹œ (Policy-based Design)

```
template <typename T>
class AddPolicy {
public:
    static T apply(T a, T b) { return a + b; }
};

template <typename T>
class MultiplyPolicy {
public:
    static T apply(T a, T b) { return a * b; }
};

template <typename T, template<typename> class Policy>
class Calculator {
public:
    T compute(T a, T b) {
        return Policy<T>::apply(a, b);
    }
};
```

```
Calculator<int, AddPolicy> adder;
Calculator<int, MultiplyPolicy> multiplier;

std::cout << adder.compute(3, 4) << "\n";        // 7
std::cout << multiplier.compute(3, 4) << "\n";   // 12
```

- CRTPë¥¼ í™œìš©í•˜ë©´ `Policy<T>` ë‚´ë¶€ì— CRTP ê¸°ë°˜ ì œì•½ë„ ë„£ì„ ìˆ˜ ìˆì–´
- ì˜ˆ: ë©”ì„œë“œ ìœ ë¬´ í™•ì¸, ì œì•½ëœ ë©”íƒ€í”„ë¡œê·¸ë˜ë°

### 7. ğŸ§® ì¥ì  ìš”ì•½

| ì¥ì                 | ì„¤ëª…                              |
| ------------------- | --------------------------------- |
| ì„±ëŠ¥ ìµœì í™”         | ì •ì  ë°”ì¸ë”©ìœ¼ë¡œ virtual call ì œê±° |
| ì¸ë¼ì¸í™” ê°€ëŠ¥       | ìµœì í™”ì— ìœ ë¦¬                     |
| ì½”ë“œ ì¬ì‚¬ìš©         | ë² ì´ìŠ¤ í…œí”Œë¦¿ìœ¼ë¡œ ë¡œì§ ê³µìœ        |
| ë©”íƒ€í”„ë¡œê·¸ë˜ë° ì í•© | ì»´íŒŒì¼ íƒ€ì„ ë¡œì§ êµ¬í˜„ ê°€ëŠ¥        |

### 8. âš ï¸ ì£¼ì˜ì‚¬í•­

- **í…œí”Œë¦¿ ì˜¤ë¥˜ ë©”ì‹œì§€ ë””ë²„ê¹…ì´ ì–´ë µë‹¤**
- **ì½”ë“œê°€ ì½ê¸° ì–´ë µë‹¤**, íŠ¹íˆ ë‹¤ë¥¸ ì‚¬ëŒì—ê²Œ
- **ë‹¤ì¤‘ ìƒì† ì‹œ ì¶©ëŒ ìœ„í—˜** ìˆìœ¼ë‹ˆ ì¡°ì‹¬

### 9. ğŸ“ ì‹¤ì œ ì ìš© ì˜ˆ

- STL `std::iterator` (C++17 ì´ì „ê¹Œì§€)
- `Eigen`, `Boost`, `LLVM`, `fmtlib` ë“± ìˆ˜ë§ì€ ê³ ì„±ëŠ¥ ë¼ì´ë¸ŒëŸ¬ë¦¬
- ìƒíƒœ ê¸°ê³„, ìˆ˜ì¹˜ ê³„ì‚°, ì»¤ìŠ¤í…€ ì»¨í…Œì´ë„ˆ êµ¬í˜„

### âœ… ìš”ì•½

- CRTPëŠ” í´ë˜ìŠ¤ ìì‹ ì„ í…œí”Œë¦¿ ì¸ìë¡œ ë¶€ëª¨ì—ê²Œ ë„˜ê²¨ì£¼ëŠ” "ê¸°ë¬˜í•œ" íŒ¨í„´
- ì •ì  ë‹¤í˜•ì„±, ì •ì±… ê¸°ë°˜ ì„¤ê³„, ì»´íŒŒì¼ íƒ€ì„ ë©”íƒ€í”„ë¡œê·¸ë˜ë°ì— ë§¤ìš° ìœ ë¦¬
- ìµìˆ™í•´ì§€ë©´ C++ ë©”íƒ€í”„ë¡œê·¸ë˜ë° ì„¸ê³„ê°€ **ì •ë§ ê°•ë ¥í•˜ê²Œ í™•ì¥ë¨**

## Policy-based design

### 1. ğŸ¯ ê°œë…

**Policy-based Design**ì€ í´ë˜ìŠ¤ì˜ ë™ì‘ì„ í•˜ë‚˜ì˜ **"ì •ì±…(Policy)" í´ë˜ìŠ¤**ë¡œ ë¶„ë¦¬í•˜ê³ ,
 í…œí”Œë¦¿ì„ ì´ìš©í•´ **ìœ ì—°í•˜ê²Œ ê¸°ëŠ¥ì„ ì¡°í•©**í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì„¤ê³„ ê¸°ë²•ì´ì•¼.

> í•µì‹¬ ì•„ì´ë””ì–´ëŠ”:
>  â í´ë˜ìŠ¤ì˜ êµ¬í˜„ì„ ëŸ°íƒ€ì„ì´ ì•„ë‹Œ ì»´íŒŒì¼íƒ€ì„ì— ì„ íƒ ê°€ëŠ¥í•˜ê²Œ ë§Œë“¤ì â

```
template <typename Policy>
class Host {
    Policy policy;
public:
    void doStuff() {
        policy.execute();
    }
};
```

### 2. âš™ï¸ ì „í†µì ì¸ ìƒì† ë°©ì‹ vs ì •ì±… ê¸°ë°˜ ì„¤ê³„

| êµ¬ë¶„             | ì „í†µ OOP (ìƒì† ê¸°ë°˜) | ì •ì±… ê¸°ë°˜ ì„¤ê³„ (Policy-based) |
| ---------------- | -------------------- | ----------------------------- |
| ë™ì‘ ì„ íƒ ì‹œì    | ëŸ°íƒ€ì„ (virtual)     | ì»´íŒŒì¼íƒ€ì„ (í…œí”Œë¦¿)           |
| ë‹¤í˜•ì„± êµ¬í˜„ ë°©ì‹ | ê°€ìƒ í•¨ìˆ˜, vtable    | CRTP, ì •ì  ë°”ì¸ë”©             |
| ì„±ëŠ¥             | ëŠë¦´ ìˆ˜ ìˆìŒ         | ë¹ ë¦„ (ì¸ë¼ì¸ ê°€ëŠ¥)            |
| í™•ì¥ ë°©ì‹        | í´ë˜ìŠ¤ ìƒì†          | í…œí”Œë¦¿ ì¸ì ì¡°í•©              |

### 3. âœ… ê¸°ë³¸ êµ¬ì¡° ì˜ˆì‹œ

```
// ì •ì±… í´ë˜ìŠ¤ 1
class AddPolicy {
public:
    int operation(int a, int b) const {
        return a + b;
    }
};

// ì •ì±… í´ë˜ìŠ¤ 2
class MultiplyPolicy {
public:
    int operation(int a, int b) const {
        return a * b;
    }
};

// í˜¸ìŠ¤íŠ¸ í´ë˜ìŠ¤
template <typename Policy>
class Calculator {
    Policy policy;
public:
    int compute(int a, int b) const {
        return policy.operation(a, b);
    }
};
```

#### ğŸ“Œ ì‚¬ìš©

```
Calculator<AddPolicy> adder;
Calculator<MultiplyPolicy> multiplier;

std::cout << adder.compute(2, 3) << "\n";       // 5
std::cout << multiplier.compute(2, 3) << "\n";  // 6
```

### 4. ğŸ§± CRTP + Policy ì ìš© ì˜ˆì‹œ

```
template <typename Derived>
class PrintPolicy {
public:
    void print() {
        static_cast<Derived*>(this)->doPrint();
    }
};

class MyObject : public PrintPolicy<MyObject> {
public:
    void doPrint() {
        std::cout << "MyObject ì¶œë ¥\n";
    }
};
```

### 5. ğŸ— ì •ì±…ì„ ë‹¤ì¤‘ ì¡°í•©í•˜ê¸°

#### ì˜ˆ: ë¡œê·¸ ì •ì±… + ì—ëŸ¬ ì •ì±…

```
struct LogToConsole {
    void log(const std::string& msg) {
        std::cout << "[Console] " << msg << "\n";
    }
};

struct LogToFile {
    void log(const std::string& msg) {
        std::ofstream("log.txt") << msg << "\n";
    }
};

struct ThrowError {
    void handleError(const std::string& e) {
        throw std::runtime_error(e);
    }
};

template <typename LogPolicy, typename ErrorPolicy>
class Engine : public LogPolicy, public ErrorPolicy {
public:
    void run() {
        this->log("ì—”ì§„ ì‹¤í–‰ ì¤‘...");
        this->handleError("ì—ëŸ¬ ë°œìƒ!");
    }
};
```

```
Engine<LogToConsole, ThrowError> app;
app.run();  // â†’ ì½˜ì†” ì¶œë ¥ + ì˜ˆì™¸ ë°œìƒ
```

### 6. ğŸ’¡ ì¥ì 

| ì¥ì         | ì„¤ëª…                                                 |
| ----------- | ---------------------------------------------------- |
| ì„±ëŠ¥ ìµœì í™” | ê°€ìƒ í•¨ìˆ˜ ì—†ì´ ë™ì‘ ì„ íƒ ê°€ëŠ¥                        |
| ì½”ë“œ ì¬ì‚¬ìš© | ê¸°ëŠ¥ì„ ì¡°ê°í™”í•˜ì—¬ ì¬í™œìš© ê°€ëŠ¥                        |
| ìœ ì—°ì„±      | ë‹¤ì–‘í•œ ê¸°ëŠ¥ ì¡°í•©ì´ ì‰¬ì›€                              |
| ë””ë²„ê¹… ìš©ì´ | static type ê¸°ë°˜ â†’ ì˜¤ë¥˜ ì¡°ê¸° ë°œê²¬                    |
| ì¸ë¼ì¸í™”    | ê±°ì˜ ëª¨ë“  í•¨ìˆ˜ê°€ ì¸ë¼ì¸ ê°€ëŠ¥ (zero-cost abstraction) |

### 7. âš ï¸ ì£¼ì˜ì 

- **ì»´íŒŒì¼ ì‹œê°„ ì¦ê°€**: í…œí”Œë¦¿ ì¸ìŠ¤í„´ìŠ¤í™”ê°€ ë§ì•„ì§€ë©´ ì»´íŒŒì¼ ëŠë¦¼
- **ì—ëŸ¬ ë©”ì‹œì§€ ê°€ë…ì„± ì €í•˜**: íŠ¹íˆ ì¤‘ì²© ì¡°í•© ì‹œ
- **ì •ì±… í´ë˜ìŠ¤ ê³„ì•½(Contract)ì„ ë¬¸ì„œí™”í•´ì•¼ í•¨**: í•¨ìˆ˜ ëª…, ì‹œê·¸ë‹ˆì²˜ ê³ ì • í•„ìš”

### 8. ğŸ“ ì‹¤ì œ ì ìš© ì‚¬ë¡€

| ë¼ì´ë¸ŒëŸ¬ë¦¬              | ì„¤ëª…                                 |
| ----------------------- | ------------------------------------ |
| **Boost.Intrusive**     | ë©”ëª¨ë¦¬ ì •ì±… ê¸°ë°˜ ì»¨í…Œì´ë„ˆ êµ¬ì„±       |
| **Loki (Alexandrescu)** | ì •ì±… ê¸°ë°˜ ë””ìì¸ì˜ ë°”ì´ë¸”            |
| **STL ë‚´ë¶€**            | `std::allocator`, `std::char_traits` |
| **fmtlib**              | í¬ë§·íŒ… ë¡œì§ ë¶„ë¦¬ ì •ì±… ì‚¬ìš©           |

### 9. âœ¨ ê³ ê¸‰ í™•ì¥ ë°©í–¥

- `template<typename T, typename Policy = DefaultPolicy>` ê¸°ë³¸ê°’ ì„¤ì •
- `std::conditional`, `std::is_same` ë“±ì„ ì´ìš©í•œ **SFINAE ê¸°ë°˜ ì •ì±… ë¶„ê¸°**
- **Concepts (C++20)** ë¥¼ í™œìš©í•œ ì •ì±… ê³„ì•½ ì •ì  ê²€ì‚¬

```
template <typename T>
concept LoggerPolicy = requires(T t, std::string msg) {
    t.log(msg);
};
```

### âœ… ìš”ì•½

- Policy-based Designì€ ê¸°ëŠ¥ì„ ì¡°ê°(policy)ìœ¼ë¡œ ë‚˜ëˆ„ê³  ì¡°í•©í•˜ëŠ” í…œí”Œë¦¿ ì„¤ê³„ ê¸°ë²•
- **ë™ì  ë‹¤í˜•ì„± ëŒ€ì‹  ì •ì  ë‹¤í˜•ì„±**ì„ ì´ìš©í•˜ì—¬ ì„±ëŠ¥ê³¼ ìœ ì—°ì„± í–¥ìƒ
- C++ ê³ ì„±ëŠ¥ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ê³„ì—ì„œ ë§¤ìš° ìì£¼ ì‚¬ìš©ë˜ëŠ” í•µì‹¬ ê¸°ë²•

## Pimpl idiom

### 1. ğŸ¯ ê°œë…

**Pimpl**ì€ "Pointer to Implementation"ì˜ ì•½ìì•¼.
 ì¦‰, **í´ë˜ìŠ¤ì˜ ì‹¤ì œ êµ¬í˜„ì„ ë³„ë„ì˜ êµ¬ì¡°ì²´ë¡œ ë¶„ë¦¬í•˜ê³ , í¬ì¸í„°ë¡œ ì—°ê²°**í•˜ëŠ” ë°©ì‹ì´ì•¼.

> ì£¼ìš” ëª©ì :
>
> - êµ¬í˜„ì„ í—¤ë”ì—ì„œ ìˆ¨ê¸°ê³ 
> - ì¢…ì†ì„± ì¤„ì´ê³ 
> - ì»´íŒŒì¼ ì‹œê°„ì„ ë‹¨ì¶•í•˜ë©°
> - ABI(ì´ì§„ í˜¸í™˜ì„±)ë¥¼ ìœ ì§€í•¨

### 2. ğŸ” ê¸°ë³¸ êµ¬ì¡°

```
// MyClass.h
class MyClass {
public:
    MyClass();
    ~MyClass();
    void doSomething();

private:
    class Impl;              // ì „ë°© ì„ ì–¸
    Impl* pImpl;             // êµ¬í˜„ë¶€ í¬ì¸í„°
};
```

```
// MyClass.cpp
class MyClass::Impl {
public:
    void doSomethingImpl() {
        std::cout << "Doing something...\n";
    }
};

MyClass::MyClass() : pImpl(new Impl) {}
MyClass::~MyClass() { delete pImpl; }

void MyClass::doSomething() {
    pImpl->doSomethingImpl();
}
```

### 3. âœ… ì¥ì 

| í•­ëª©                        | ì„¤ëª…                                    |
| --------------------------- | --------------------------------------- |
| **í—¤ë” íŒŒì¼ì—ì„œ êµ¬í˜„ ì€ë‹‰** | `#include`ê°€ ì¤„ì–´ë“¦ â†’ ë¹Œë“œ ì¢…ì†ì„± ê°ì†Œ  |
| **ì»´íŒŒì¼ ì‹œê°„ ë‹¨ì¶•**        | êµ¬í˜„ ë³€ê²½í•´ë„ ì¸í„°í˜ì´ìŠ¤ íŒŒì¼ì€ ìœ ì§€    |
| **ì´ì§„ í˜¸í™˜ì„± ë³´ì¥(ABI)**   | `.h` ë³€ê²½ ì—†ì´ `.cpp`ë§Œ êµì²´ ê°€ëŠ¥       |
| **ì˜ë„ì  ìº¡ìŠí™”**           | ë‚´ë¶€ êµ¬í˜„ ë””í…Œì¼ì„ ì™¸ë¶€ì— ë…¸ì¶œí•˜ì§€ ì•ŠìŒ |

### 4. ğŸ§  ì™œ Pimplì´ ì¤‘ìš”í•œê°€?

#### ì˜ˆì‹œ: êµ¬í˜„ë¶€ì— í—¤ë” ì¢…ì†ì„±ì´ ìˆì„ ë•Œ

```
// Bad.h
#include <vector>

class Bad {
    std::vector<int> data;  // ì´ ë•Œë¬¸ì— ëª¨ë“  ì‚¬ìš©ìê°€ vector í¬í•¨ë¨
};
```

â†’ ë§¤ë²ˆ `Bad.h`ë¥¼ includeí•  ë•Œë§ˆë‹¤ `<vector>`ê¹Œì§€ ëŒê³  ë“¤ì–´ì˜´

### Pimpl ë°©ì‹ìœ¼ë¡œ ë³€ê²½

```
// Good.h
class Good {
public:
    Good();
    ~Good();
    void work();
private:
    class Impl;
    Impl* pImpl;
};
```

```
// Good.cpp
#include <vector>

class Good::Impl {
    std::vector<int> data;
public:
    void work() {
        std::cout << "Doing work with vector\n";
    }
};

Good::Good() : pImpl(new Impl) {}
Good::~Good() { delete pImpl; }

void Good::work() {
    pImpl->work();
}
```

> âœ… ì´ì œ `Good.h`ëŠ” `<vector>`ì— **ì˜ì¡´í•˜ì§€ ì•ŠìŒ!**

### 5. ğŸ§± ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° ì‚¬ìš© (modern Pimpl)

```
// Modern version
#include <memory>

class MyClass {
public:
    MyClass();
    ~MyClass();
    void work();

private:
    class Impl;
    std::unique_ptr<Impl> pImpl;
};
```

```
// Impl ì •ì˜
class MyClass::Impl {
public:
    void work() {
        std::cout << "Unique_ptr Pimpl!\n";
    }
};

MyClass::MyClass() : pImpl(std::make_unique<Impl>()) {}
MyClass::~MyClass() = default;

void MyClass::work() {
    pImpl->work();
}
```

- `std::unique_ptr` ì‚¬ìš© ì‹œ **ìˆ˜ë™ `delete` í•„ìš” ì—†ìŒ**
- ë³µì‚¬ ìƒì„±ì / ëŒ€ì… ì—°ì‚°ì ì •ì˜ ì‹œ ì£¼ì˜ í•„ìš” (ë³µì‚¬ ê¸ˆì§€ or ë³µì‚¬ ìˆ˜í–‰)

### 6. âœ¨ ì‘ìš© ì‚¬ë¡€

| ë¼ì´ë¸ŒëŸ¬ë¦¬ / ì‹œìŠ¤í…œ        | ì„¤ëª…                                             |
| -------------------------- | ------------------------------------------------ |
| Qt                         | ëª¨ë“  QObject ê³„ì—´ í´ë˜ìŠ¤ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ Pimpl ì‚¬ìš© |
| LLVM                       | ABI ì•ˆì •ì„±ê³¼ ìº¡ìŠí™”ë¥¼ ìœ„í•´ ê´‘ë²”ìœ„ ì‚¬ìš©           |
| Boost                      | ë‚´ë¶€ êµ¬ì¡° ì€ë‹‰ì— í™œìš©                            |
| C++ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬í˜„ì²´ | ë‚´ë¶€ ë””í…Œì¼ì„ ì‚¬ìš©ìì—ê²Œ ê°ì¶”ê¸° ìœ„í•´ ì‚¬ìš©        |

### 7. â— ì£¼ì˜ì‚¬í•­

| í•­ëª©        | ì£¼ì˜ì                                                        |
| ----------- | ------------------------------------------------------------ |
| ë³µì‚¬ ëŒ€ì…   | `MyClass(const MyClass&)`, `operator=` ì •ì˜ ì•ˆ í•˜ë©´ ë³µì‚¬ ë¶ˆê°€ëŠ¥ |
| ì„±ëŠ¥        | í¬ì¸í„° ê°„ì ‘ ì ‘ê·¼ â†’ **ì•½ê°„ì˜ ì˜¤ë²„í—¤ë“œ ì¡´ì¬**                  |
| ë””ë²„ê¹…      | êµ¬í˜„ì´ ë³„ë„ ë¶„ë¦¬ë˜ì–´ ìˆì–´ ë””ë²„ê¹…ì´ ë¶ˆí¸í•  ìˆ˜ ìˆìŒ            |
| ì¸ë¼ì¸ ë¶ˆê°€ | `Impl`ì´ .cppì—ë§Œ ì •ì˜ë˜ë©´ í•¨ìˆ˜ ì¸ë¼ì¸ ì–´ë ¤ì›€                |

### 8. âœ… ìš”ì•½

- Pimpl Idiomì€ C++ì—ì„œ **êµ¬í˜„ ì€ë‹‰, ì»´íŒŒì¼ ì¢…ì†ì„± ìµœì†Œí™”, ABI ì•ˆì •ì„± í™•ë³´**ë¥¼ ìœ„í•œ ê³ ì „ì ì´ê³  ê°•ë ¥í•œ ê¸°ë²•
- í˜„ëŒ€ C++ì—ì„œëŠ” `std::unique_ptr` ë˜ëŠ” `std::shared_ptr`ê³¼ í•¨ê»˜ ì‚¬ìš©í•˜ì—¬ ë©”ëª¨ë¦¬ ì•ˆì „ì„± ê°•í™”
- ë‹¤ë§Œ ì„±ëŠ¥ ë¯¼ê°í•œ ì½”ë“œì—ì„œëŠ” **ê°„ì ‘ ì ‘ê·¼ ë¹„ìš©**ê³¼ **ì¸ë¼ì¸ ìµœì í™” ì œí•œ**ì— ìœ ì˜í•  ê²ƒ