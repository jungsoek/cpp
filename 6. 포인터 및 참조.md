# 6. 포인터 및 참조

## 포인터 개념 및 연산

**포인터(pointer)**는 **다른 변수의 주소(address)**를 저장하는 변수다.
 C++에서 포인터는 메모리의 직접적인 접근, 동적 할당, 함수 인자 전달 등 다양한 **저수준 메모리 제어**를 가능하게 한다.
 특히 시스템 프로그래밍, 임베디드 시스템, 성능 최적화 등에서 핵심적으로 사용된다.

### 📌 포인터 기본 개념

```
int a = 10;
int* p = &a;  // 'p'는 'a'의 주소를 저장
```

- `*p`: **역참조(dereference)** → 포인터가 가리키는 실제 값
- `&a`: **주소 연산자(address-of operator)** → 변수 `a`의 메모리 주소

### 📌 포인터 선언 문법

```
타입* 변수명;
```

예시:

```
int* p;       // int형을 가리키는 포인터
char* cp;     // char형을 가리키는 포인터
double* dp;   // double형을 가리키는 포인터
```

> `int *p, q;`라고 선언하면, `p`는 포인터지만 `q`는 일반 int → 별도로 선언 권장

### 📌 기본 예제

```
int x = 42;
int* ptr = &x;

std::cout << ptr << "\n";   // 주소 출력
std::cout << *ptr << "\n";  // x의 값 출력: 42
```

### 📌 포인터 연산

#### 1. 주소 연산자 `&`

```
int a = 10;
int* p = &a;
```

- `&a`는 변수 `a`의 주소를 반환
- `p`는 `a`를 가리키는 포인터

#### 2. 역참조 연산자 `*`

```
int a = 10;
int* p = &a;
*p = 20;  // a의 값이 20으로 변경됨
```

- `*p`는 포인터가 가리키는 **메모리 공간의 실제 값**을 의미
- 포인터를 통해 원본 데이터를 직접 수정 가능

#### 3. 포인터 산술 연산 (Pointer Arithmetic)

```
int arr[3] = {10, 20, 30};
int* p = arr;

std::cout << *p << "\n";     // 10
std::cout << *(p + 1) << "\n"; // 20
```

- `p + 1`: 다음 요소의 주소 (int는 4바이트일 경우 `p + 4 byte`)
- 포인터 연산은 **타입 크기를 자동으로 고려함**

#### 허용되는 연산:

| 연산         | 의미                            |
| ------------ | ------------------------------- |
| `p + n`      | n번째 이후 위치로 이동          |
| `p - n`      | n번째 이전 위치로 이동          |
| `p1 - p2`    | 두 포인터 간 거리(요소 수 단위) |
| `++p`, `--p` | 다음/이전 요소로 이동           |

### 📌 널 포인터 (`nullptr`)

```
int* p = nullptr;
```

- C++11부터 `nullptr` 사용 → `NULL`보다 타입 안정성 높음
- 조건문에서 포인터가 유효한지 검사할 때 사용

```
if (p != nullptr) {
    // 안전하게 역참조
}
```

### 📌 포인터와 배열

```
int arr[5] = {1, 2, 3, 4, 5};
int* p = arr;

std::cout << *(p + 2) << "\n";  // 3
```

- 배열 이름 `arr`은 사실상 배열의 첫 번째 요소 주소 (`&arr[0]`)를 의미
- 배열과 포인터는 매우 밀접하게 연관되어 있음

### 📌 포인터와 함수

```
void increment(int* p) {
    (*p)++;
}

int main() {
    int x = 5;
    increment(&x);
    std::cout << x;  // 출력: 6
}
```

- 포인터를 통해 **함수에서 원본 변수의 값 수정 가능**
- **Call by Pointer** 방식

### 📌 포인터의 포인터 (`int**`)

```
int x = 5;
int* p = &x;
int** pp = &p;

std::cout << **pp;  // 5
```

- 다중 포인터는 메모리 간접 접근을 가능하게 함
- 2차원 배열, 이중 포인터 동적 할당 등에 사용

### 📎 요약: 포인터 핵심 정리

| 요소        | 설명                                          |
| ----------- | --------------------------------------------- |
| `*`         | 역참조: 포인터가 가리키는 실제 값             |
| `&`         | 주소 취득: 변수의 메모리 주소                 |
| `nullptr`   | 유효하지 않은 포인터를 명시적으로 표현        |
| 산술 연산   | 배열 순회, 구조체 필드 접근 등 가능           |
| 다중 포인터 | 포인터를 가리키는 포인터 (`int**`, `char***`) |
| 함수 전달   | 원본 수정, 콜백 구현 가능                     |

포인터는 C++의 가장 강력한 도구이자 가장 위험한 기능 중 하나다. **정확한 타입, 올바른 주소, 유효한 범위**를 항상 보장하는 습관이 필요하며,
 `nullptr`, `const`, `smart pointer` 같은 C++의 안전 장치를 적극 활용해야 한다.

## 포인터와 배열의 관계

C++에서 **배열(array)**과 **포인터(pointer)**는 매우 밀접한 관계를 가진다. 배열의 이름은 **암시적으로 해당 배열의 첫 번째 요소의 주소로 변환**되며,
 이 때문에 포인터처럼 배열을 다룰 수 있고, 포인터 연산을 이용해 배열 요소에 접근할 수 있다.

### 📌 배열 이름 = 배열 첫 요소의 주소

```
int arr[5] = {10, 20, 30, 40, 50};
int* p = arr;         // == &arr[0]
```

- `arr`은 **배열 전체가 아니라, `&arr[0]`로 자동 변환**
- `p`는 이제 `arr[0]`을 가리키는 포인터가 된다

```
std::cout << arr[0];  // 10
std::cout << *arr;    // 10 → *(&arr[0])
std::cout << *(arr + 2);  // 30
std::cout << p[2];        // 30
```

➡ `arr[i] == *(arr + i)`
➡ `p[i] == *(p + i)`

### 📌 배열과 포인터 연산 비교

| 표현식       | 의미                            |
| ------------ | ------------------------------- |
| `arr`        | 배열의 시작 주소 (`&arr[0]`)    |
| `arr + i`    | `i`번째 요소의 주소 (`&arr[i]`) |
| `*(arr + i)` | `i`번째 요소의 값 (`arr[i]`)    |
| `p = arr`    | `p`는 `arr[0]`의 주소를 갖게 됨 |
| `p + 1`      | 다음 요소 주소 (`&arr[1]`)      |
| `*(p + 1)`   | `p[1]`과 동일                   |

### 📌 배열은 상수 포인터(L-value), 포인터는 가변

```
int arr[3] = {1, 2, 3};
arr = arr + 1;      // ❌ 컴파일 에러 (배열 이름은 주소 상수)
cpp코드 복사int* p = arr;
p = p + 1;          // ✅ 가능 (포인터는 값 변경 가능)
```

- **배열 이름은 상수 포인터처럼 동작하지만 값 변경 불가**
- **포인터 변수는 다른 주소로 이동 가능**

### 📌 배열을 함수에 전달하면? (포인터로 전달됨)

```
void printArray(int* ptr, int size) {
    for (int i = 0; i < size; ++i)
        std::cout << ptr[i] << " ";
}

int main() {
    int arr[3] = {1, 2, 3};
    printArray(arr, 3);  // 배열 → 포인터로 자동 변환
}
```

- 함수 인자로 배열을 넘기면 → 포인터로 전달됨 (`int* ptr`)
- 즉, 함수 내부에서 `ptr[i]`는 `arr[i]`와 동일하게 동작

### 📌 배열 크기 차이: `sizeof`

```
int arr[5] = {0};
int* p = arr;

std::cout << sizeof(arr);  // 5 * sizeof(int) = 20 (예: 4바이트 x 5)
std::cout << sizeof(p);    // 포인터 크기 (보통 8바이트)
```

- `sizeof(arr)`는 배열 전체 크기
- `sizeof(p)`는 포인터 변수의 크기 → **동일하게 보이지만 완전히 다름**

### 📌 다차원 배열과 포인터

```
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};

int (*ptr)[3] = matrix;  // 1행 3열짜리 배열을 가리키는 포인터
```

- `matrix`는 `int(*)[3]` 타입
- `*ptr`은 한 행(`int[3]`)에 해당
- `*(*(ptr + 1) + 2)` → `matrix[1][2]` → 6

### 📎 요약 비교

| 항목             | 배열                                  | 포인터                         |
| ---------------- | ------------------------------------- | ------------------------------ |
| 선언             | `int arr[5];`                         | `int* p;`                      |
| 기본 의미        | **고정된 메모리 공간**                | **주소를 저장하는 변수**       |
| `arr`            | `&arr[0]`로 암시적 변환               | 이미 주소                      |
| 크기             | 전체 메모리 크기 (`sizeof`) 계산 가능 | 항상 포인터 크기만 계산됨      |
| 값 변경          | 주소 자체 변경 불가                   | 다른 주소로 자유롭게 변경 가능 |
| 함수 인자 전달   | 포인터로 암시적 변환                  | 그대로 포인터                  |
| 동적 메모리 할당 | 불가능 (`new`로 할당 불가)            | 동적 배열 가능 (`new[]`) 사용  |

### ✅ 정리

- 배열 이름은 첫 요소의 주소와 같지만, **변경할 수 없는 상수 포인터**처럼 작동함
- 포인터는 배열처럼 사용할 수 있고, `p[i] == *(p + i)`는 표준 패턴임
- 함수 인자로 배열을 넘기면 **포인터로 전달됨**
- **배열 크기**, **소유권**, **동적 할당 여부**는 포인터와 배열의 결정적 차이점

이 차이를 명확히 이해하는 것은 **버그 없는 메모리 제어, 안전한 함수 호출, 고성능 배열 처리**를 위한 기초 중의 기초다.

## 이중 포인터, void 포인터

C++에서 포인터는 단일 수준을 넘어서 **다중 포인터**, **범용 포인터**로도 확장된다.
 이중 포인터(`T**`)는 **포인터를 가리키는 포인터**,
 `void*` 포인터는 **타입이 없는 범용 포인터**로, C 스타일 저수준 프로그래밍에서 특히 유용하다.

### 🧷 이중 포인터 (`T**`)

#### 📌 개념

이중 포인터는 **포인터를 가리키는 포인터**이다. 즉,

- `int* p`는 `int`를 가리킴
- `int** pp`는 `int*`를 가리킴

```
int x = 42;
int* p = &x;
int** pp = &p;
```

#### 📌 사용 예

```
std::cout << x   << "\n";  // 42
std::cout << *p  << "\n";  // 42
std::cout << **pp << "\n"; // 42
```

- `pp`는 `p`의 주소를 가짐
- `*pp`는 `p` → `int*`
- `**pp`는 `*p` → `x`

#### 📌 주요 활용 사례

1. **함수 내에서 포인터를 수정하고 싶을 때**

```
void allocate(int** ptr) {
    *ptr = new int(100);
}

int* p = nullptr;
allocate(&p);       // 함수 내부에서 p 자체를 변경
std::cout << *p;    // 100
```

> `int*`를 함수로 넘기면 값만 변경 가능, `int**`를 넘기면 **주소 자체 변경 가능**

2. **2차원 배열 동적 할당**

```
int** matrix = new int*[3];
for (int i = 0; i < 3; ++i)
    matrix[i] = new int[4];  // 3x4 배열
```

### ⚫ `void*` 포인터 (void pointer)

#### 📌 개념

`void*`는 **타입이 없는 범용 포인터**이다.
 어떤 자료형의 주소든 저장할 수 있지만, **직접 역참조하거나 산술 연산은 불가능하다.**

```
int a = 10;
void* ptr = &a;

// std::cout << *ptr;   ❌ 불가 — 타입 불분명
std::cout << *(static_cast<int*>(ptr));  // ✅ 타입 지정 후 역참조
```

#### 📌 특징 요약

| 항목           | 설명                                            |
| -------------- | ----------------------------------------------- |
| 타입 없음      | 어떤 자료형 주소든 저장 가능                    |
| 역참조 불가    | 반드시 명시적 형 변환 필요                      |
| 산술 연산 불가 | `ptr + 1` 등 주소 연산 불가                     |
| 유용한 상황    | 제네릭 함수, 라이브러리 인터페이스, malloc 결과 |

#### 📌 예: `malloc`과 `void*`

```
int* data = (int*)malloc(sizeof(int) * 10);  // C 스타일
```

- `malloc`은 항상 `void*` 반환 → 타입에 맞게 형 변환 필요

#### 📌 주의

- `void*`를 잘못된 타입으로 캐스팅하면 **UB(정의되지 않은 동작) 발생**
- C++에서는 가능하면 `void*`보다 **템플릿**, `std::any`, `std::variant` 등 사용을 권장

### 📎 요약 비교

| 항목         | 이중 포인터 (`T**`)                           | `void*` 포인터                         |
| ------------ | --------------------------------------------- | -------------------------------------- |
| 역할         | 포인터를 가리키는 포인터                      | 타입이 없는 범용 포인터                |
| 역참조       | `**pp` → 원본 데이터 접근                     | 역참조 전 반드시 타입 변환 필요        |
| 산술 연산    | 가능 (`pp++`, `(*pp)++` 등)                   | 불가 (`ptr + 1` 불가)                  |
| 주 사용 사례 | 포인터 수정 함수, 2D 배열, 메모리 이중 포인터 | 제네릭 함수, C 라이브러리, `malloc` 등 |
| 안전성       | 타입 정보 보존됨                              | 타입 정보 없음, **캐스팅 필수**        |

이중 포인터와 `void*`는 **C++의 저수준 제어를 가능하게 하는 도구**다.
 하지만 동시에 **버그를 일으키기 쉬운 위험한 도구**이기도 하므로, 명확한 목적이 없다면
 가능하면 **스마트 포인터, 컨테이너, 템플릿 등 C++ 고수준 도구로 대체**하는 것이 권장된다.

## nullptr, NULL 차이

C++에서는 포인터가 **어떤 것도 가리키지 않음을 표현**할 때 `NULL` 또는 `nullptr`을 사용한다.
 두 표현은 비슷해 보이지만, **타입, 동작, 안전성 측면에서 근본적인 차이**가 있다.
 **C++11 이후에는 `nullptr` 사용이 명확하고 안전한 방식으로 권장된다.**

### 📌 `NULL`: C 스타일 매크로 상수

- C 언어에서 유래된 방식
- 일반적으로 `#define NULL 0` 혹은 `((void*)0)`로 정의
- 사실상 **정수 0**으로 처리됨
- 포인터뿐만 아니라 **정수 타입에도 전달 가능** → **모호성 문제 발생 가능**

```
int* p = NULL;  // 포인터에 정수 0을 대입 → OK
if (p == 0) { ... }  // 의미상 NULL과 동일
```

#### ⚠️ 문제점:

```
void func(int);
void func(int*);

func(NULL);  // ⚠️ 컴파일러는 int와 int* 중 어느 걸 선택할지 모호함
```

- `NULL`은 **정수 0**으로 간주되므로, 포인터 오버로딩에서 충돌 발생 가능

### 📌 `nullptr`: C++11 도입된 null 전용 키워드

- `nullptr`은 **null 포인터를 표현하기 위한 전용 키워드**
- 타입은 `std::nullptr_t`이며, **포인터로만 암시적 변환 가능**
- 정수로 변환 불가 → **함수 오버로딩 시 혼란 방지**

```
int* p = nullptr;  // 안전하고 명확

func(nullptr);     // int*에만 일치 → 명확한 선택 가능
```

#### 타입 검사:

```
#include <type_traits>

static_assert(std::is_same<decltype(nullptr), std::nullptr_t>::value, "맞음");
```

### 📎 비교 요약

| 항목             | `NULL`                 | `nullptr`                      |
| ---------------- | ---------------------- | ------------------------------ |
| 도입             | C에서 도입, C++로 계승 | C++11에서 새로 도입            |
| 정의             | 보통 `#define NULL 0`  | 전용 키워드 (`std::nullptr_t`) |
| 타입             | `int` 또는 `void*`     | `nullptr_t`                    |
| 포인터 전용 여부 | ❌ (정수도 포함됨)      | ✅ (포인터 전용)                |
| 오버로딩 안전성  | ❌ 모호성 발생 가능     | ✅ 타입이 명확해 충돌 없음      |
| 권장 여부        | ❌ C 호환용으로만 유지  | ✅ 현대 C++에서 표준 방식       |

### ✅ 결론

| 언제                           | 무엇을 써야 하나               |
| ------------------------------ | ------------------------------ |
| **C 코드**                     | `NULL` 사용 가능 (역사적 이유) |
| **C++ 코드** (특히 C++11 이상) | 반드시 `nullptr` 사용          |

`nullptr`은 **타입 안전성, 함수 오버로딩 명확성, 코드 명료성** 모두에서 `NULL`보다 우수하다.
 **현대 C++에서는 `NULL`을 더 이상 사용하지 말고 `nullptr`만 사용할 것.**

## 참조(Reference)의 개념

C++에서 **참조(reference)**란, **어떤 변수(대상)의 또 다른 이름(별칭, alias)**을 의미한다.
 참조를 통해 **원래 변수 자체를 직접 가리키면서도 포인터보다 간결하게 사용할 수 있는 방식**을 제공한다.
 포인터와 달리 **역참조 연산자 없이도 바로 변수처럼 사용**할 수 있고, **널 값이 불가능하며**, **초기화 이후 바꿀 수 없다.**

### 📌 기본 문법

```
int a = 10;
int& ref = a;  // ref는 a의 참조 (alias)
```

- `ref`는 `a`의 또 다른 이름이 된다
- `ref`를 수정하면 곧 `a`를 수정하는 것과 같다

```
ref = 20;
std::cout << a;  // 출력: 20
```

### 📌 참조의 특징 요약

| 특성                 | 설명                                                        |
| -------------------- | ----------------------------------------------------------- |
| 별칭(Alias)          | 참조는 변수의 또 다른 이름 (별도 메모리 없음)               |
| 초기화 필수          | 참조는 **선언과 동시에 반드시 초기화**해야 함               |
| 재지정 불가          | 참조는 한 번 어떤 변수에 붙으면, 다른 변수로 바꿀 수 없음   |
| null 불가능          | 포인터와 달리 `nullptr` 같은 무참조 상태 불가 (보통 안전함) |
| 포인터보다 문법 간결 | `*`, `->` 없이 변수처럼 사용 가능                           |

### 📌 함수 인자 전달에서의 참조

#### ✅ 값 전달 vs 참조 전달

```
void modifyByValue(int x) {
    x = 100;
}

void modifyByReference(int& x) {
    x = 100;
}
```

```
int a = 10;
modifyByValue(a);      // a는 여전히 10
modifyByReference(a);  // a는 100으로 변경됨
```

- 참조를 함수 인자로 사용하면 **원본 변수 수정 가능**
- 성능상 이점도 있음 (복사 비용 없음)

### 📌 const 참조 (`const T&`)

```
void print(const std::string& str) {
    std::cout << str << "\n";
}
```

- 읽기 전용 참조 → **복사 없이 인자를 전달하면서도 수정은 불가**
- 특히 **복사 비용이 큰 객체(vector, string 등)**에 적합

### 📌 참조 반환

```
int& getElement(int arr[], int index) {
    return arr[index];
}

int a[3] = {10, 20, 30};
getElement(a, 1) = 99;  // a[1] 값이 99로 변경됨
```

- 함수에서 참조를 반환하면 **호출한 쪽에서 원본을 수정 가능**
- 단, **지역 변수 참조 반환은 절대 금지 (dangling reference)**

### 📌 참조 vs 포인터 비교

| 항목             | 참조 (`T&`)      | 포인터 (`T*`)   |
| ---------------- | ---------------- | --------------- |
| 선언 문법        | `int& r = x;`    | `int* p = &x;`  |
| 역참조 문법      | 없음 (바로 사용) | `*p`            |
| null 가능성      | ❌ (없음)         | ✅ (가능)        |
| 재지정 가능 여부 | ❌ (불가능)       | ✅ (가능)        |
| 초기화 필수      | ✅ (필수)         | ❌ (선언만 가능) |
| 간결성           | ✅                | ❌               |

### 📎 정리

- 참조는 **값처럼 쓰면서 포인터처럼 동작하는 구조**
- 함수 인자 전달 시 **참조는 복사 없이 값 수정 가능**
- 참조는 **포인터보다 안전하고 직관적인 사용 방식**
- `const T&`는 **고성능 읽기 전용 인자 전달의 표준 방식**

### ✅ 핵심 요약

> **참조는 변수의 또 다른 이름이다.**
>  **참조를 통해 원본 데이터에 직접 접근하거나 수정할 수 있지만, 반드시 초기화되어야 하고, 중간에 다른 대상을 참조하도록 바꿀 수 없다.**
>  **C++ 함수 설계에서 참조는 성능과 명확성을 모두 충족하는 중요한 도구다.**

## const 포인터 vs 포인터 to const

C++에서 `const`와 포인터를 함께 사용할 때는 **"무엇이 상수인가?"**를 정확히 파악해야 한다.
 표현에 따라 **포인터 자체가 상수인지**, **포인터가 가리키는 값이 상수인지**, 또는 **둘 다 상수인지**가 달라진다.

### 📌 1. **포인터 to const** (`const T*` 또는 `T const*`)

> **"가리키는 대상은 상수이지만, 포인터 자체는 변경 가능"**

```
const int* p = &x;   // 또는 int const* p = &x;
```

- `*p`는 읽기만 가능 → **값 수정 금지**
- `p`는 다른 주소를 가리킬 수 있음 → **포인터 변경 가능**

```
*p = 10;     // ❌ 오류: 상수 값 수정 불가
p = &y;      // ✅ 가능: 다른 주소를 가리킬 수 있음
```

#### 사용 상황

- 함수 인자에서 **읽기 전용 포인터**를 받고 싶을 때

```
void readOnly(const int* ptr);  // 함수 내에서 *ptr 수정 불가
```

### 📌 2. **const 포인터** (`T* const`)

> **"포인터 자체는 상수지만, 가리키는 대상은 변경 가능"**

```
int* const p = &x;
```

- `*p`는 수정 가능 → **값 변경 가능**
- `p`는 상수 → **다른 주소로 변경 불가**

```
*p = 20;     // ✅ 가능
p = &y;      // ❌ 오류: 포인터 값 변경 불가
```

#### 사용 상황

- 포인터를 **절대 다른 대상을 가리키게 하지 않도록 고정**하고 싶을 때

### 📌 3. **const 포인터 to const** (`const T* const`)

> **"포인터도 상수, 가리키는 값도 상수"**

```
const int* const p = &x;
```

- `*p`는 읽기 전용 → **값 수정 불가**
- `p`는 상수 → **주소 재지정 불가**

```
*p = 30;  // ❌
p = &y;   // ❌
```

### 📎 표 정리

| 선언 형식          | 값 변경 가능 | 포인터 변경 가능 | 설명                       |
| ------------------ | ------------ | ---------------- | -------------------------- |
| `const T* p`       | ❌            | ✅                | 상수 값 → 읽기 전용 포인터 |
| `T* const p`       | ✅            | ❌                | 상수 포인터 → 고정된 대상  |
| `const T* const p` | ❌            | ❌                | 상수 포인터 + 상수 값      |

### ✅ 예시 정리

```
int x = 10;
int y = 20;

// 1. 읽기 전용 포인터 (포인터는 이동 가능)
const int* a = &x;
a = &y;    // OK
//*a = 5;  // 오류

// 2. 고정된 포인터 (값은 변경 가능)
int* const b = &x;
//b = &y;   // 오류
*b = 5;    // OK

// 3. 완전 상수 포인터
const int* const c = &x;
//c = &y;   // 오류
//*c = 5;   // 오류
```

### ✅ 결론

| 질문                              | 답변                                |
| --------------------------------- | ----------------------------------- |
| 값을 바꾸지 못하게 하고 싶은가?   | `const T*` 사용 (`T const*`도 동일) |
| 주소를 바꾸지 못하게 하고 싶은가? | `T* const` 사용                     |
| 둘 다 못 바꾸게 하고 싶은가?      | `const T* const` 사용               |

👉 **읽기 전용 포인터**: `const T*`
 👉 **고정된 포인터**: `T* const`
 👉 **읽기 전용 + 고정**: `const T* const`

> **const 위치 기준은 “const 오른쪽이 상수다”로 기억하면 쉽다!**
>  예: `int* const p` → "포인터(p)가 상수", `const int* p` → "포인터가 가리키는 값이 상수" ✅

## 포인터와 동적 메모리의 연관

C++에서 **포인터(pointer)**는 **동적 메모리(dynamic memory)**를 제어하는 핵심 수단이다.
 **동적 메모리란 런타임에 힙 영역(heap memory)에 필요에 따라 메모리를 할당하고 해제하는 공간**이며, 포인터 없이는 이를 제어할 수 없다.
 C언어에서는 `malloc/free`, C++에서는 `new/delete` 키워드를 통해 동적 메모리를 관리한다.

### 📌 동적 메모리란?

- 컴파일 타임이 아닌 **런타임에 메모리 할당**됨
- 정적 메모리(static memory)와 달리 **크기를 유동적으로 결정** 가능
- **힙(Heap) 메모리 영역**에서 할당됨
- 포인터를 통해 접근해야 하며, **명시적으로 해제해야 메모리 누수 방지 가능**

### 📌 `new`와 `delete` (C++ 스타일 동적 메모리)

#### ✅ 단일 변수 할당

```
int* p = new int;     // int 크기만큼 동적 메모리 할당
*p = 42;
std::cout << *p;      // 출력: 42
delete p;             // 반드시 해제!
```

- `new T` → 힙에 `T` 타입 객체 생성, 해당 주소 반환
- `delete` → 해당 주소의 메모리 반환

#### ✅ 배열 할당

```
int* arr = new int[5];  // int 5개짜리 배열 동적 생성
arr[0] = 10;

delete[] arr;           // 배열은 delete[]로 해제해야 함
```

- `new[]`: 연속된 메모리 블록 확보
- `delete[]`: 정확히 대응되어야 메모리 누수/오류 방지 가능

### 📌 동적 메모리와 포인터의 관계

| 작업                      | 관련 포인터 동작                      |
| ------------------------- | ------------------------------------- |
| 메모리 할당 (`new`)       | 포인터가 힙 메모리 주소를 저장        |
| 값 접근 (`*p`, `p[i]`)    | 포인터를 통해 메모리 내용 읽기/쓰기   |
| 메모리 해제 (`delete`)    | 포인터로 가리킨 동적 메모리 반환      |
| 포인터 초기화 (`nullptr`) | 초기 상태 또는 해제 후 안전 상태 유지 |

### 📌 예시: 사용자 입력 크기의 동적 배열

```
int size;
std::cin >> size;

int* data = new int[size];  // 런타임 크기 지정 가능
for (int i = 0; i < size; ++i)
    data[i] = i * 2;

delete[] data;  // 반드시 해제
```

- 크기를 알 수 없는 배열은 **동적 메모리 할당을 통해 생성**
- C++에서 이를 더 안전하게 다루려면 `std::vector` 사용 권장

### 📌 동적 메모리 관리 시 주의사항

| 문제 유형                | 설명                                             |
| ------------------------ | ------------------------------------------------ |
| 메모리 누수              | `new` 후 `delete`를 호출하지 않으면 누수 발생    |
| 이중 해제                | `delete`를 두 번 호출하면 정의되지 않은 동작(UB) |
| 잘못된 접근              | 이미 해제된 메모리를 참조하면 UB                 |
| 배열 할당 후 단일 delete | `new[]`는 `delete[]`로 해제해야 안전             |

### 📌 Modern C++ 권장: 스마트 포인터 사용

C++11 이후에는 `new/delete` 대신 **스마트 포인터** (`std::unique_ptr`, `std::shared_ptr`) 사용이 권장된다:

```
#include <memory>

std::unique_ptr<int> ptr = std::make_unique<int>(10);
std::shared_ptr<int> sptr = std::make_shared<int>(20);
```

- 자동으로 메모리를 관리해줌 (`delete` 필요 없음)
- **RAII (Resource Acquisition Is Initialization)** 원칙 준수

### 📎 요약

| 개념             | 설명                                              |
| ---------------- | ------------------------------------------------- |
| 포인터           | 동적 메모리 주소를 저장하는 변수                  |
| `new` / `delete` | C++ 동적 메모리 할당/해제 키워드                  |
| 힙 메모리        | 런타임에 생성되는 유동적 메모리                   |
| 메모리 누수 방지 | 할당 후 반드시 `delete` (또는 스마트 포인터 사용) |
| 스마트 포인터    | 메모리 관리 자동화 (C++11 이상 권장)              |

**결론**:
 포인터는 **동적 메모리 제어의 핵심 도구**이며, `new/delete`를 통해 유연한 메모리 사용이 가능해진다.
 하지만 **수동 메모리 관리의 위험성과 복잡성**을 피하기 위해, 현대 C++에서는 **스마트 포인터 사용이 기본 규칙**이다.