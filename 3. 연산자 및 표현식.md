# 3. 연산자 및 표현식

## 산술, 대입, 관계, 논리, 비트 연산자

C++는 연산자 중심 언어이며, 다양한 연산자를 통해 값을 계산하거나 비교하고, 상태를 조작할 수 있다. 이 연산자들은 **피연산자의 타입과 위치, 우선순위**에 따라 다른 의미를 갖는다. 여기서는 가장 기초적이고도 가장 많이 사용되는 연산자인 **산술, 대입, 관계, 논리, 비트 연산자**에 대해 다룬다.

### 📌 산술 연산자 (Arithmetic Operators)

| 연산자 | 의미   | 예시    | 결과              |
| ------ | ------ | ------- | ----------------- |
| `+`    | 덧셈   | `5 + 3` | `8`               |
| `-`    | 뺄셈   | `5 - 3` | `2`               |
| `*`    | 곱셈   | `5 * 3` | `15`              |
| `/`    | 나눗셈 | `5 / 2` | `2` (정수 나눗셈) |
| `%`    | 나머지 | `5 % 2` | `1`               |

- 정수형끼리 `/` 연산을 하면 소수점 이하는 **버려진다**
- `float` 또는 `double` 중 하나라도 포함되면 **실수 나눗셈** 수행됨

### 📌 대입 연산자 (Assignment Operators)

| 연산자 | 의미           | 예시     | 결과           |
| ------ | -------------- | -------- | -------------- |
| `=`    | 대입           | `x = 5`  | `x에 5를 저장` |
| `+=`   | 덧셈 후 대입   | `x += 3` | `x = x + 3`    |
| `-=`   | 뺄셈 후 대입   | `x -= 2` | `x = x - 2`    |
| `*=`   | 곱셈 후 대입   | `x *= 4` | `x = x * 4`    |
| `/=`   | 나눗셈 후 대입 | `x /= 2` | `x = x / 2`    |
| `%=`   | 나머지 후 대입 | `x %= 3` | `x = x % 3`    |

복합 대입 연산자는 코드를 간결하게 만들고, 연산과 저장을 동시에 수행한다.

### 📌 관계 연산자 (Relational Operators)

| 연산자 | 의미        | 예시     | 결과         |
| ------ | ----------- | -------- | ------------ |
| `==`   | 같음        | `x == y` | `true/false` |
| `!=`   | 같지 않음   | `x != y` | `true/false` |
| `<`    | 보다 작음   | `x < y`  | `true/false` |
| `>`    | 보다 큼     | `x > y`  | `true/false` |
| `<=`   | 작거나 같음 | `x <= y` | `true/false` |
| `>=`   | 크거나 같음 | `x >= y` | `true/false` |

관계 연산자의 결과는 `bool` 타입이다. 조건문이나 반복문의 조건 판단에 주로 사용된다.

### 📌 논리 연산자 (Logical Operators)

| 연산자 | 의미     | 예시              | 결과         |
| ------ | -------- | ----------------- | ------------ |
| `&&`   | 논리 AND | `x > 0 && x < 10` | `true/false` |
| `      |          | `                 | 논리 OR      |
| `!`    | 논리 NOT | `!flag`           | 반대값       |

- `&&`와 `||`는 **단축 평가(short-circuit evaluation)**를 지원
  - `&&`: 왼쪽이 false이면 오른쪽 평가 생략
  - `||`: 왼쪽이 true이면 오른쪽 평가 생략

### 📌 비트 연산자 (Bitwise Operators)

비트 연산자는 정수형 타입에 대해서만 적용되며, 메모리 비트 단위로 조작을 수행한다.

| 연산자 | 의미          | 예시     | 결과            |
| ------ | ------------- | -------- | --------------- |
| `&`    | 비트 AND      | `5 & 3`  | `1`             |
| `      | `             | 비트 OR  | `5              |
| `^`    | 비트 XOR      | `5 ^ 3`  | `6`             |
| `~`    | 비트 NOT      | `~5`     | `-6` (2의 보수) |
| `<<`   | 왼쪽 시프트   | `5 << 1` | `10`            |
| `>>`   | 오른쪽 시프트 | `5 >> 1` | `2`             |

예시 설명:

```
5 = 0b0101  
3 = 0b0011  

AND: 0101 & 0011 = 0001 (1)  
OR:  0101 | 0011 = 0111 (7)  
XOR: 0101 ^ 0011 = 0110 (6)  
```

- `~x`: 모든 비트를 반전 (1 → 0, 0 → 1)
- `<<`: 비트를 왼쪽으로 밀고, 0으로 채움
- `>>`: 비트를 오른쪽으로 밀며, 부호 비트 유지 (산술 시프트)

### 📎 연산자 우선순위 요약 (상위 일부)

| 우선순위 | 연산자                    | 결합 방향   |
| -------- | ------------------------- | ----------- |
| 1        | `++`, `--`, `()`, `[]`    | 왼 → 오     |
| 2        | `*`, `/`, `%`             | 왼 → 오     |
| 3        | `+`, `-`                  | 왼 → 오     |
| 4        | `<<`, `>>`                | 왼 → 오     |
| 5        | `<`, `<=`, `>`, `>=`      | 왼 → 오     |
| 6        | `==`, `!=`                | 왼 → 오     |
| 7        | `&` (비트 AND)            | 왼 → 오     |
| 8        | `^` (비트 XOR)            | 왼 → 오     |
| 9        | `                         | ` (비트 OR) |
| 10       | `&&`                      | 왼 → 오     |
| 11       | `                         |             |
| 12       | `=`, `+=`, `-=` 등 대입류 | 오 → 왼     |

이 연산자들은 C++ 프로그래밍의 모든 계산, 비교, 조건 분기, 상태 제어에 핵심적으로 사용된다. 특히 **비트 연산자**는 마이크로컨트롤러, 임베디드, 시스템 프로그래밍에서 필수적으로 쓰이므로, 정확한 이진 해석 능력이 필요하다.
 모든 연산자는 **피연산자의 타입에 따라 동작이 다를 수 있기 때문에**, 연산 전후의 타입 확인과 자동 형 변환(implicit conversion)에 주의하는 것이 좋다.

## 증감, 조건(삼항), 쉼표 연산자

C++는 복잡한 연산을 간결하게 표현할 수 있도록 다양한 **단항 및 이항 연산자**를 제공한다. 그중에서도 **증감 연산자**, **조건(삼항) 연산자**, **쉼표 연산자**는 **제어 흐름이나 상태 변경**을 간결하게 다룰 수 있게 해주는 고수준 표현 수단이다. 하지만 동작 방식에 따라 **미묘한 차이**와 **오용 위험**이 있으므로 정확한 이해가 필수다.

### 📌 증감 연산자 (`++`, `--`)

- 피연산자의 값을 **1 증가** 또는 **1 감소**시킨다
- **전위형(prefix)**: 먼저 연산 후 평가
- **후위형(postfix)**: 먼저 평가 후 연산

```
int a = 5;
int b = ++a;  // 전위형: a=6, b=6
int c = a--;  // 후위형: c=6, a=5
```

#### 비교:

| 표현식 | 의미                           | 설명              |
| ------ | ------------------------------ | ----------------- |
| `++x`  | x를 1 증가시킨 후 그 값을 반환 | 값 사용 전에 증가 |
| `x++`  | x의 현재 값을 반환한 후 1 증가 | 값 사용 후에 증가 |
| `--x`  | x를 1 감소시킨 후 그 값을 반환 | 값 사용 전에 감소 |
| `x--`  | x의 현재 값을 반환한 후 1 감소 | 값 사용 후에 감소 |

> 객체 타입(예: 반복자)에서 후위형은 복사본을 반환하므로 **전위형이 더 효율적**이다.

### 📌 조건(삼항) 연산자 `? :`

조건문을 간단한 표현식으로 줄여 쓰는 **삼항 연산자(ternary operator)**.
 형식:

```
조건식 ? 참일 때 값 : 거짓일 때 값
```

예시:

```
int a = 10, b = 20;
int max = (a > b) ? a : b;  // max = 20
```

중첩도 가능하나 가독성이 떨어지므로 복잡한 경우에는 `if` 문으로 분리하는 것이 낫다:

```
string result = (score >= 90) ? "A" :
                (score >= 80) ? "B" :
                (score >= 70) ? "C" : "F";
```

#### 장점:

- 표현식 안에서 조건 분기 가능
- 함수 인자 또는 리턴 값으로 활용 가능

#### 단점:

- 복잡한 로직에는 적합하지 않음
- 가독성 저하 위험

### 📌 쉼표 연산자 `,`

**여러 표현식을 한 줄에서 순차적으로 평가**하고, **마지막 표현식의 결과를 반환**한다.
 모든 표현식을 좌→우 순서로 평가함.

```
int x = (a = 3, a + 5);  // a = 3 먼저 실행, x = 8
```

주로 `for` 루프 내에서 다중 제어 변수 초기화나 증감 시 사용된다:

```
for (int i = 0, j = 10; i < j; ++i, --j) {
    // i는 증가, j는 감소
}
```

#### 주의:

- **우선순위가 매우 낮기 때문에** 괄호로 감싸지 않으면 예상과 다른 결과가 나올 수 있음
- **대입 연산자보다도 우선순위가 낮음**

### 📎 요약

| 연산자       | 의미             | 특징                                     |
| ------------ | ---------------- | ---------------------------------------- |
| `++x`        | 전위 증가        | 먼저 증가, 그 후 평가                    |
| `x++`        | 후위 증가        | 먼저 평가, 그 후 증가                    |
| `--x`, `x--` | 전위/후위 감소   | 위와 동일                                |
| `? :`        | 조건 삼항 연산자 | 조건에 따라 값 선택, `if-else` 대체 가능 |
| `,`          | 쉼표 연산자      | 다중 표현식 순차 실행, 마지막 결과 반환  |

이 연산자들은 간결한 코드 작성에 매우 유용하지만, **부주의하게 사용하면 버그를 유발하거나 가독성을 떨어뜨릴 수 있다.** 특히 증감 연산자의 전위/후위, 쉼표 연산자의 우선순위 등은 반드시 정확하게 이해하고 사용해야 안정적인 코드 작성이 가능하다.

## 연산자 우선순위 및 결합 규칙

C++는 다양한 연산자가 존재하며, 이들이 한 식(expression) 안에서 함께 사용될 경우 **평가 순서**는 **우선순위(Precedence)**와 **결합 규칙(Associativity)**에 따라 결정된다.
 우선순위는 어떤 연산을 먼저 할 것인지 결정하고, 결합 규칙은 **동일한 우선순위의 연산자가 연속으로 나왔을 때** 어떤 방향으로 평가할지를 정한다.

### 📌 연산자 우선순위표 (요약)

| 우선순위 (높음→낮음) | 연산자 예시                                                  | 결합 방향 | 설명                             |
| -------------------- | ------------------------------------------------------------ | --------- | -------------------------------- |
| 1                    | `::`                                                         | 왼→오     | 스코프 지정자                    |
| 2                    | `++`, `--`, `()`, `[]`, `.`, `->`, `typeid`, `sizeof`, `alignof` | 왼→오     | 단항 연산자, 함수 호출 등        |
| 3                    | `++`, `--`, `+`, `-`, `!`, `~`, `*`, `&` (단항), `new`, `delete`, `cast`류 | 오른→왼   | 단항 연산자 및 객체 생성/삭제    |
| 4                    | `*`, `/`, `%`                                                | 왼→오     | 산술 연산자 (곱셈/나눗셈/나머지) |
| 5                    | `+`, `-`                                                     | 왼→오     | 덧셈/뺄셈                        |
| 6                    | `<<`, `>>`                                                   | 왼→오     | 비트 시프트                      |
| 7                    | `<`, `<=`, `>`, `>=`                                         | 왼→오     | 관계 연산자 (비교)               |
| 8                    | `==`, `!=`                                                   | 왼→오     | 등가 연산자                      |
| 9                    | `&`                                                          | 왼→오     | 비트 AND                         |
| 10                   | `^`                                                          | 왼→오     | 비트 XOR                         |
| 11                   | `                                                            | `         | 왼→오                            |
| 12                   | `&&`                                                         | 왼→오     | 논리 AND                         |
| 13                   | `                                                            |           | `                                |
| 14                   | `?:`                                                         | 오른→왼   | 조건(삼항) 연산자                |
| 15                   | `=`, `+=`, `-=`, `*=`, `/=`, ...                             | 오른→왼   | 대입 및 복합 대입                |
| 16                   | `,`                                                          | 왼→오     | 쉼표 연산자 (순차 평가)          |

### 📌 결합 규칙 (Associativity)

결합 규칙은 **같은 우선순위의 연산자가 연속으로 나올 때** 어떤 순서로 평가할지를 나타낸다.

- **왼쪽에서 오른쪽(Left-to-Right)**: 대부분의 이항 연산자

  ```
  a - b - c  →  (a - b) - c
  ```

- **오른쪽에서 왼쪽(Right-to-Left)**: 대입 연산자, 조건 연산자, 단항 연산자

  ```
  a = b = c  →  a = (b = c)
  ```

### 📌 괄호 `()` 사용 권장

- **우선순위를 명시하고 실수를 방지**하기 위해 괄호 사용이 권장된다
- 코드의 **명확성**, **가독성**, **버그 방지**에 매우 효과적이다

```
int result = a + b * c;         // b * c 먼저
int safe = (a + b) * c;         // a + b 먼저
```

### 📎 실제 예제

```
int a = 2, b = 3, c = 4;
int result = a + b * c - 1;
```

- 평가 순서:
  - `b * c` → `3 * 4 = 12`
  - `a + 12` → `2 + 12 = 14`
  - `14 - 1 = 13`

```
int d = 1;
d += 2 * 3;    // 우선순위: * > += → d = d + (2 * 3) = 7
```

### 📌 주의할 점

- `=`, `+=` 등의 대입 연산자는 **오른쪽 결합**이므로 항상 **오른쪽부터 계산**됨

- `?:` 삼항 연산자는 **가장 오해하기 쉬운 결합 규칙을 가짐**

  ```
  int result = a > b ? x : y + z;
  // 의도한 대로 작동하지 않을 수 있음 → 괄호로 명시 필요
  ```

### 요약

| 요소        | 내용                                       |
| ----------- | ------------------------------------------ |
| 우선순위    | 어떤 연산이 먼저 실행될지 결정함           |
| 결합 규칙   | 동일 우선순위 연산자가 연속할 때 평가 방향 |
| 괄호 사용   | 연산 순서 명확화, 안전하고 가독성 향상     |
| 주의 연산자 | `=`, `?:`, `,` 등은 결합 방향이 비직관적임 |

연산자의 정확한 우선순위와 결합 방향을 이해하는 건 단순한 암기가 아니라 **안정적이고 의도된 코드 실행을 위한 기초 체계**다. 복잡한 식일수록 괄호를 적극적으로 사용하는 습관이 중요하다.

## 명시적 형 변환 및 암시적 형 변환

C++에서 **형 변환(type conversion)**은 한 자료형을 다른 자료형으로 바꾸는 과정을 의미한다. 형 변환은 **자동으로 일어나는 경우(암시적, implicit)**와 **프로그래머가 직접 지시하는 경우(명시적, explicit)**로 나뉜다.

### 📌 암시적 형 변환 (Implicit Type Conversion)

암시적 변환은 컴파일러가 **자동으로 수행하는 형 변환**이다. 보통 연산자 사용이나 함수 호출 시 **두 타입이 맞지 않을 경우** 더 큰 타입으로 자동 변환된다.

#### 예시:

```
int i = 42;
double d = i;  // 암시적으로 int → double 변환
```

```
char c = 'A';
int ascii = c; // 암시적으로 char → int (ascii 65)
```

#### 변환 우선순위 (Integer Promotion → Usual Arithmetic Conversion)

| 자료형 우선순위 |
| --------------- |
| `long double`   |
| `double`        |
| `float`         |
| `unsigned long` |
| `long`          |
| `unsigned int`  |
| `int`           |
| `short`         |
| `char`          |
| `bool`          |

컴파일러는 연산이나 함수 전달 시 **낮은 우선순위 타입을 높은 타입으로 자동 승격**한다.

#### 예시:

```
float f = 3.14f;
int i = 2;
auto result = f + i; // i → float 으로 변환됨 → result는 float
```

암시적 변환은 편리하지만 **의도치 않은 정보 손실(narrowing)**이 발생할 수 있어 주의가 필요하다.

```
double d = 3.14;
int x = d;  // 소수점 손실 발생
```

### 📌 명시적 형 변환 (Explicit Type Conversion)

프로그래머가 특정 값의 타입을 **직접 바꾸도록 명시하는 형 변환**이다. 명시적 형 변환은 **의도적이고, 위험한 변환임을 코드에 드러내는 효과**를 준다.

#### 1. C 스타일 형 변환 (비권장)

```
int x = (int)3.14;  // 결과: 3
```

이 방식은 유연하지만 **유형별 변환 규칙이 불명확**하고, **C++ 고유 문법과 충돌할 수 있기 때문에** 현대 C++에서는 사용을 지양한다.

#### 2. C++ 스타일 형 변환 (권장)

| 형식                     | 용도                                            |
| ------------------------ | ----------------------------------------------- |
| `static_cast<T>(x)`      | 일반적인 타입 변환 (int → double 등)            |
| `const_cast<T>(x)`       | const, volatile 제거                            |
| `reinterpret_cast<T>(x)` | 메모리 주소 수준의 비트 재해석                  |
| `dynamic_cast<T>(x)`     | RTTI 기반 런타임 형 변환 (다형성 클래스에 사용) |

#### 예시:

```
double pi = 3.14159;
int x = static_cast<int>(pi);  // 3

const char* str = "hello";
char* modifiable = const_cast<char*>(str);  // const 제거 (주의 필요)

void* ptr = &x;
int* pInt = reinterpret_cast<int*>(ptr);  // 위험: 타입 해석만 변경

Base* b = new Derived();
Derived* d = dynamic_cast<Derived*>(b);  // 다운캐스팅 (성공 시 d != nullptr)
```

### 📎 암시적 vs 명시적 비교 요약

| 항목        | 암시적 변환 (Implicit)            | 명시적 변환 (Explicit)                     |
| ----------- | --------------------------------- | ------------------------------------------ |
| 수행 주체   | 컴파일러 자동 수행                | 프로그래머가 명시적으로 지시               |
| 사용 예     | `int → double`, `char → int`      | `static_cast`, `reinterpret_cast` 등       |
| 위험성      | 정보 손실 가능 (예: double → int) | 명확하나, 잘못된 변환 시 더 위험할 수 있음 |
| 코드 가독성 | 숨겨져 있어 추적 어려움           | 의도가 명확하게 드러남                     |
| 권장 여부   | 단순한 경우에 한해 가능           | 복잡한 변환은 항상 명시적으로 수행         |

### ⚠️ 주의 사항

- 암시적 변환은 예기치 않은 동작을 유발할 수 있으므로 **혼합 타입 연산 시 주의**
- 특히 **`bool`, `char`, `float`** 등 **축소 변환(narrowing)**은 컴파일 타임 경고나 런타임 버그를 일으킬 수 있다
- C++11 이후는 중괄호 초기화를 사용하면 **암시적 narrowing 변환을 막을 수 있다**

```
int x{3.14};  // ❌ 컴파일 에러 (narrowing 방지)
```

**정리하자면**, C++에서는 가능한 경우에는 **컴파일러의 암시적 변환에 의존하기보다는**, **명시적 형 변환을 사용하여 코드의 안정성과 명확성을 높이는 것이 바람직하다.**
 특히 포인터 변환, 상속 계층 간 캐스팅 등은 반드시 적절한 `cast` 연산자를 선택해 사용해야 한다.