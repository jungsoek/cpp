# 19. STL (Standard Template Library)

## ì»¨í…Œì´ë„ˆ ê°œìš”: vector, list, deque, stack, queue, map, set, unordered_map, unordered_set ë“±

### âœ… 1. ì»¨í…Œì´ë„ˆë€?

**ì»¨í…Œì´ë„ˆ(Container)**ëŠ” C++ STLì—ì„œ **ë°ì´í„°ë¥¼ ì €ì¥í•˜ê³  ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤ í…œí”Œë¦¿**ì´ë‹¤.
 ì»¨í…Œì´ë„ˆëŠ” ë‚´ë¶€ì— ì—¬ëŸ¬ ì›ì†Œë¥¼ ë³´ê´€í•˜ê³ , ê·¸ ìœ„ì—ì„œ **ì‚½ì…, ì‚­ì œ, íƒìƒ‰, ìˆœíšŒ ë“± ë‹¤ì–‘í•œ ì—°ì‚°**ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì œê³µí•œë‹¤.

ì»¨í…Œì´ë„ˆëŠ” í¬ê²Œ ë‹¤ìŒ ì„¸ ê°€ì§€ë¡œ ë¶„ë¥˜ëœë‹¤:

| ë¶„ë¥˜                     | ì˜ˆì‹œ                             | ì„¤ëª…                    |
| ------------------------ | -------------------------------- | ----------------------- |
| **ìˆœì°¨ ì»¨í…Œì´ë„ˆ**        | `vector`, `list`, `deque`        | ì›ì†Œë¥¼ ì„ í˜• êµ¬ì¡°ë¡œ ì €ì¥ |
| **ì—°ê´€ ì»¨í…Œì´ë„ˆ**        | `map`, `set`                     | ì •ë ¬ëœ í‚¤-ê°’ ê¸°ë°˜ ì €ì¥  |
| **ë¹„ì •ë ¬ ì—°ê´€ ì»¨í…Œì´ë„ˆ** | `unordered_map`, `unordered_set` | í•´ì‹œ ê¸°ë°˜ ì €ì¥          |

### âœ… 2. ìˆœì°¨ ì»¨í…Œì´ë„ˆ

#### 2.1 `vector` (ë™ì  ë°°ì—´)

- **ê°€ë³€ ê¸¸ì´ ë°°ì—´**
- ì—°ì†ëœ ë©”ëª¨ë¦¬ ë¸”ë¡ì— ì €ì¥ë¨ â†’ **ëœë¤ ì ‘ê·¼ ë¹ ë¦„**
- ëì—ì„œì˜ ì‚½ì…/ì‚­ì œëŠ” ë¹ ë¦„, ì¤‘ê°„ ì‚½ì…ì€ ëŠë¦¼

```
std::vector<int> v = {1, 2, 3};
v.push_back(4);    // ë’¤ì— ì‚½ì…
int x = v[2];      // ëœë¤ ì ‘ê·¼
```

#### 2.2 `list` (ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸)

- ê° ì›ì†Œê°€ **ì „/í›„ í¬ì¸í„°ë¥¼ ê°€ì§€ëŠ” êµ¬ì¡°**
- **ì¤‘ê°„ ì‚½ì…/ì‚­ì œê°€ ë¹ ë¦„**, **ëœë¤ ì ‘ê·¼ ë¶ˆê°€**

```
std::list<int> l = {1, 2, 3};
l.push_back(4);
l.insert(++l.begin(), 10);  // 2 ì•ì— ì‚½ì…
```

#### 2.3 `deque` (ì–‘ë°©í–¥ í)

- **ì•ë’¤ ì–‘ìª½ì—ì„œ ì‚½ì…/ì‚­ì œê°€ ëª¨ë‘ O(1)**
- ë‚´ë¶€ì ìœ¼ë¡œ ì—¬ëŸ¬ ë¸”ë¡ì„ ì¡°í•©í•˜ì—¬ êµ¬í˜„

```
std::deque<int> dq;
dq.push_front(10);
dq.push_back(20);
```

### âœ… 3. ì–´ëŒ‘í„° ì»¨í…Œì´ë„ˆ

> ë‚´ë¶€ì ìœ¼ë¡œ **ë‹¤ë¥¸ ì»¨í…Œì´ë„ˆ(`deque`, `vector`)ë¥¼ ê¸°ë°˜**ìœ¼ë¡œ ë™ì‘í•˜ëŠ” ì»¨í…Œì´ë„ˆ

#### 3.1 `stack` (í›„ì…ì„ ì¶œ)

- ê¸°ë³¸ì ìœ¼ë¡œ `deque`ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•¨
- **push/pop/top** ë©”ì„œë“œë§Œ ì œê³µ

```
std::stack<int> st;
st.push(1);
st.push(2);
st.pop();           // 2 ì œê±°
int x = st.top();   // 1
```

#### 3.2 `queue` (ì„ ì…ì„ ì¶œ)

- ë‚´ë¶€ì ìœ¼ë¡œ `deque` ì‚¬ìš©
- **push/pop/front/back** ì œê³µ

```
std::queue<int> q;
q.push(1);
q.push(2);
q.pop();           // 1 ì œê±°
```

### âœ… 4. ì—°ê´€ ì»¨í…Œì´ë„ˆ (ì •ë ¬ ê¸°ë°˜)

> ë‚´ë¶€ì ìœ¼ë¡œ **ë ˆë“œ-ë¸”ë™ íŠ¸ë¦¬**ì™€ ê°™ì€ ê· í˜• ì´ì§„ íŠ¸ë¦¬ êµ¬ì¡°ë¡œ êµ¬í˜„ë˜ì–´ ìˆìŒ

#### 4.1 `set` (ì¤‘ë³µ ì—†ëŠ” ì§‘í•©)

- ìë™ ì •ë ¬ë¨ (ê¸°ë³¸ì ìœ¼ë¡œ `operator<`)
- íƒìƒ‰, ì‚½ì…, ì‚­ì œ ëª¨ë‘ **O(log N)**

```
std::set<int> s;
s.insert(10);
s.insert(5);
s.insert(10);  // ì¤‘ë³µ ë¬´ì‹œ
```

#### 4.2 `map` (í‚¤-ê°’ ìŒ)

- í‚¤ëŠ” **ì •ë ¬ ìƒíƒœë¡œ ìœ ì§€ë¨**
- í‚¤ ì¤‘ë³µ ë¶ˆê°€, ì‚½ì…/íƒìƒ‰ O(log N)

```
std::map<std::string, int> ages;
ages["Tom"] = 30;
ages["Jerry"] = 25;
```

### âœ… 5. ë¹„ì •ë ¬ ì—°ê´€ ì»¨í…Œì´ë„ˆ (í•´ì‹œ ê¸°ë°˜)

> ë‚´ë¶€ì ìœ¼ë¡œ **í•´ì‹œ í…Œì´ë¸”**ë¡œ êµ¬í˜„ë˜ì–´ **íƒìƒ‰/ì‚½ì…/ì‚­ì œ í‰ê·  O(1)**

#### 5.1 `unordered_set`

- ìˆœì„œ ì—†ëŠ” ì¤‘ë³µ ë¶ˆê°€ ì§‘í•©
- í•´ì‹œ ê¸°ë°˜ â†’ ì„±ëŠ¥ ë¹ ë¦„, í•˜ì§€ë§Œ ì •ë ¬ë˜ì§€ ì•ŠìŒ

```
std::unordered_set<std::string> us;
us.insert("apple");
us.insert("banana");
```

#### 5.2 `unordered_map`

- ìˆœì„œ ì—†ëŠ” í‚¤-ê°’ ìŒ ì €ì¥
- íƒìƒ‰/ì‚½ì… í‰ê·  O(1), ìµœì•…ì˜ ê²½ìš° O(N)

```
std::unordered_map<std::string, int> scores;
scores["math"] = 90;
scores["english"] = 85;
```

### âœ… 6. ë¹„êµ ìš”ì•½í‘œ

| ì»¨í…Œì´ë„ˆ        | íŠ¹ì§•             | ì‚½ì…/ì‚­ì œ       | ì ‘ê·¼ ì†ë„        | ì •ë ¬ ì—¬ë¶€ |
| --------------- | ---------------- | --------------- | ---------------- | --------- |
| `vector`        | ë™ì  ë°°ì—´        | ë’¤ë§Œ ë¹ ë¦„       | ë¹ ë¦„ (ëœë¤ ì ‘ê·¼) | âŒ         |
| `list`          | ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ | ì–´ë””ì„œë‚˜ ë¹ ë¦„   | ëŠë¦¼             | âŒ         |
| `deque`         | ì–‘ë°©í–¥ í        | ì•/ë’¤ ëª¨ë‘ ë¹ ë¦„ | ì¤‘ê°„ ëŠë¦¼        | âŒ         |
| `stack`         | í›„ì…ì„ ì¶œ (LIFO)  | topë§Œ ì¡°ì‘      | topë§Œ ê°€ëŠ¥       | âŒ         |
| `queue`         | ì„ ì…ì„ ì¶œ (FIFO)  | front/back ì¡°ì‘ | frontë§Œ ì ‘ê·¼     | âŒ         |
| `set`           | ì¤‘ë³µ ì—†ìŒ, ì •ë ¬  | O(log N)        | O(log N)         | âœ…         |
| `map`           | í‚¤-ê°’, ì •ë ¬      | O(log N)        | O(log N)         | âœ…         |
| `unordered_set` | ì¤‘ë³µ ì—†ìŒ, í•´ì‹œ  | í‰ê·  O(1)       | í‰ê·  O(1)        | âŒ         |
| `unordered_map` | í‚¤-ê°’, í•´ì‹œ      | í‰ê·  O(1)       | í‰ê·  O(1)        | âŒ         |

### âœ… ì„ íƒ ê¸°ì¤€

| ëª©ì                   | ì¶”ì²œ ì»¨í…Œì´ë„ˆ                    |
| --------------------- | -------------------------------- |
| ì •ë ¬ëœ ìˆœì„œ ìœ ì§€      | `set`, `map`                     |
| ê°€ì¥ ë¹ ë¥¸ ì‚½ì…/íƒìƒ‰   | `unordered_map`, `unordered_set` |
| ì¸ë±ìŠ¤ ê¸°ë°˜ ìˆœíšŒ      | `vector`                         |
| ë¹ˆë²ˆí•œ ì¤‘ê°„ ì‚½ì…/ì‚­ì œ | `list`                           |
| ì•ë’¤ì—ì„œ ëª¨ë‘ ì‚½ì…    | `deque`                          |
| í›„ì…ì„ ì¶œ ìŠ¤íƒ         | `stack`                          |
| ì„ ì…ì„ ì¶œ í           | `queue`                          |

## ë°˜ë³µì(iterator): begin, end, const_iterator

### âœ… 1. ë°˜ë³µì(iterator)ë€?

**ë°˜ë³µì(Iterator)**ëŠ” STL ì»¨í…Œì´ë„ˆ ë‚´ë¶€ì˜ ì›ì†Œì— **ìˆœì°¨ì ìœ¼ë¡œ ì ‘ê·¼í•˜ê¸° ìœ„í•œ ê°ì²´**ì´ë‹¤.
 C++ì—ì„œ ë°˜ë³µìëŠ” í¬ì¸í„°ì²˜ëŸ¼ ë™ì‘í•˜ë©°, `*`, `++`, `--` ë“±ì˜ ì—°ì‚°ìë¥¼ í†µí•´ ì›ì†Œë¥¼ íƒìƒ‰í•˜ê±°ë‚˜ ì¡°ì‘í•  ìˆ˜ ìˆë‹¤.

> ì»¨í…Œì´ë„ˆì˜ ë‚´ë¶€ êµ¬í˜„ì„ ì•Œ í•„ìš” ì—†ì´ **ë²”ìš©ì ì´ê³  ì¶”ìƒì ì¸ ë°©ë²•ìœ¼ë¡œ ìˆœíšŒ**í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.

### âœ… 2. ê¸°ë³¸ êµ¬ì¡° ì˜ˆì‹œ

```
std::vector<int> v = {1, 2, 3, 4};

for (std::vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
    std::cout << *it << '\n';
}
```

- `v.begin()` â†’ ì²« ë²ˆì§¸ ìš”ì†Œë¥¼ ê°€ë¦¬í‚¤ëŠ” ë°˜ë³µì
- `v.end()` â†’ ë§ˆì§€ë§‰ ìš”ì†Œì˜ **ë‹¤ìŒ ìœ„ì¹˜**ë¥¼ ê°€ë¦¬í‚¤ëŠ” ë°˜ë³µì
- `*it` â†’ í˜„ì¬ ë°˜ë³µìê°€ ê°€ë¦¬í‚¤ëŠ” ê°’ì„ ì°¸ì¡°
- `++it` â†’ ë‹¤ìŒ ìš”ì†Œë¡œ ì´ë™

### âœ… 3. ì£¼ìš” ë°˜ë³µì í•¨ìˆ˜

| í•¨ìˆ˜       | ì˜ë¯¸                                                   |
| ---------- | ------------------------------------------------------ |
| `begin()`  | ì»¨í…Œì´ë„ˆì˜ **ì²« ë²ˆì§¸ ìš”ì†Œë¥¼ ê°€ë¦¬í‚¤ëŠ” ë°˜ë³µì ë°˜í™˜**     |
| `end()`    | ì»¨í…Œì´ë„ˆì˜ **ë§ˆì§€ë§‰ ìš”ì†Œ ë‹¤ìŒì„ ê°€ë¦¬í‚¤ëŠ” ë°˜ë³µì ë°˜í™˜** |
| `cbegin()` | `const_iterator` ë°˜í™˜ (ì½ê¸° ì „ìš©)                      |
| `cend()`   | `const_iterator`ì˜ end                                 |
| `rbegin()` | ì—­ìˆœ ë°˜ë³µì ì‹œì‘ (ë§ˆì§€ë§‰ ìš”ì†Œ)                         |
| `rend()`   | ì—­ìˆœ ë°˜ë³µì ë (ì²« ìš”ì†Œ ì•)                            |

### âœ… 4. ë°˜ë³µìì˜ ì¢…ë¥˜

| ë°˜ë³µì íƒ€ì…              | ì„¤ëª…                               |
| ------------------------ | ---------------------------------- |
| `iterator`               | ì¼ë°˜ ë°˜ë³µì (ì½ê¸°/ì“°ê¸° ê°€ëŠ¥)       |
| `const_iterator`         | ì½ê¸° ì „ìš© ë°˜ë³µì (ì“°ê¸° ë¶ˆê°€)       |
| `reverse_iterator`       | ì—­ìˆœ ë°˜ë³µì (`rbegin()`, `rend()`) |
| `const_reverse_iterator` | ì½ê¸° ì „ìš© ì—­ìˆœ ë°˜ë³µì              |

### âœ… 5. `const_iterator` ì˜ˆì œ

```
std::vector<int> v = {10, 20, 30};

for (std::vector<int>::const_iterator it = v.cbegin(); it != v.cend(); ++it) {
    std::cout << *it << '\n';
    // *it = 100;  // âŒ ì˜¤ë¥˜: const_iteratorëŠ” ì“°ê¸° ë¶ˆê°€
}
```

#### ë˜ëŠ” C++11 ì´í›„ì—ëŠ” `auto`ì™€ í•¨ê»˜:

```
for (auto it = v.cbegin(); it != v.cend(); ++it) {
    std::cout << *it << '\n';
}
```

### âœ… 6. ë²”ìœ„ ê¸°ë°˜ for ë¬¸ê³¼ì˜ ê´€ê³„

```
for (const auto& val : v) {
    std::cout << val << '\n';
}
```

- ìœ„ ë¬¸ì¥ì€ ë‚´ë¶€ì ìœ¼ë¡œ `v.begin()`ë¶€í„° `v.end()`ê¹Œì§€ ë°˜ë³µí•˜ëŠ” ë°˜ë³µì ê¸°ë°˜ ë£¨í”„ë¡œ ë³€í™˜ëœë‹¤.
- `const auto&`ë¥¼ ì‚¬ìš©í•˜ë©´ **ë³µì‚¬ ë¹„ìš© ì—†ì´ ì½ê¸° ì „ìš© ìˆœíšŒ**ê°€ ê°€ëŠ¥í•˜ë‹¤.

### âœ… 7. ë°˜ë³µì ì—°ì‚° ì˜ˆì‹œ

```
std::vector<int> v = {1, 2, 3, 4, 5};
auto it = v.begin();

std::cout << *it;     // 1
++it;
std::cout << *it;     // 2
it += 2;
std::cout << *it;     // 4
```

- `vector`, `deque`ëŠ” **ëœë¤ ì ‘ê·¼ ë°˜ë³µì**ë¥¼ ì œê³µí•˜ì—¬ `it + n`ì´ ê°€ëŠ¥
- `list`ëŠ” **ì–‘ë°©í–¥ ë°˜ë³µì**ë§Œ ì§€ì› â†’ `it++`, `--it`ì€ ê°€ëŠ¥í•˜ë‚˜ `it + n`ì€ ë¶ˆê°€ëŠ¥

### âœ… 8. ì»¤ìŠ¤í…€ ì»¨í…Œì´ë„ˆì™€ ë°˜ë³µì

ì‚¬ìš©ì ì •ì˜ í´ë˜ìŠ¤ì— `begin()` / `end()` í•¨ìˆ˜ë¥¼ ì œê³µí•˜ë©´ STL ë°˜ë³µ ê¸°ë°˜ ì•Œê³ ë¦¬ì¦˜ê³¼ í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```
struct MyRange {
    int* begin() { return arr; }
    int* end() { return arr + 5; }
    int arr[5] = {10, 20, 30, 40, 50};
};

MyRange r;
for (int x : r) {
    std::cout << x << '\n';
}
```

### âœ… ìš”ì•½ ì •ë¦¬í‘œ

| í•¨ìˆ˜       | ë°˜í™˜ íƒ€ì…          | ì„¤ëª…           |
| ---------- | ------------------ | -------------- |
| `begin()`  | `iterator`         | ì‹œì‘ ìœ„ì¹˜      |
| `end()`    | `iterator`         | ëì˜ ë‹¤ìŒ ìœ„ì¹˜ |
| `cbegin()` | `const_iterator`   | ì½ê¸° ì „ìš© ì‹œì‘ |
| `cend()`   | `const_iterator`   | ì½ê¸° ì „ìš© ë   |
| `rbegin()` | `reverse_iterator` | ì—­ìˆœ ì‹œì‘      |
| `rend()`   | `reverse_iterator` | ì—­ìˆœ ë        |

### âœ… ì‹¤ì „ íŒ

- **ì½ê¸° ì „ìš© ë°˜ë³µ** ì‹œì—ëŠ” `const_iterator` ì‚¬ìš©ìœ¼ë¡œ ì‹¤ìˆ˜ ë°©ì§€
- `auto` í‚¤ì›Œë“œëŠ” ë°˜ë³µì ì„ ì–¸ì„ ê°„ê²°í•˜ê²Œ ë§Œë“¤ì–´ì¤Œ
- ë²”ìœ„ ê¸°ë°˜ forë¬¸ì„ ì‚¬ìš©í•˜ë©´ ë°˜ë³µìì˜ ë¬¸ë²• ì˜¤ë¥˜ ê°€ëŠ¥ì„± ìµœì†Œí™”
- ì•Œê³ ë¦¬ì¦˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ (`std::find`, `std::sort`, `std::for_each`)ëŠ” ëª¨ë‘ ë°˜ë³µì ê¸°ë°˜

## ì•Œê³ ë¦¬ì¦˜: sort, find, transform, for_each ë“±

### âœ… 1. ì•Œê³ ë¦¬ì¦˜ì´ë€?

C++ STLì—ì„œ **ì•Œê³ ë¦¬ì¦˜(algorithm)**ì€ ì»¨í…Œì´ë„ˆë‚˜ ë°˜ë³µì ìœ„ì—ì„œ ìˆ˜í–‰ë˜ëŠ” **ì¼ë°˜í™”ëœ ì—°ì‚°** í•¨ìˆ˜ë“¤ì„ ì˜ë¯¸í•œë‹¤.
 ëª¨ë“  ì•Œê³ ë¦¬ì¦˜ì€ `<algorithm>` í—¤ë”ì— ì •ì˜ë˜ì–´ ìˆìœ¼ë©°, **ë°˜ë³µì(iterator)ë¥¼ ê¸°ë°˜**ìœ¼ë¡œ ë™ì‘í•œë‹¤.

```
#include <algorithm>
```

> ì£¼ìš” íŠ¹ì§•:
>
> - ì»¨í…Œì´ë„ˆ ë…ë¦½ì  (ë°˜ë³µì ê¸°ë°˜)
> - í•¨ìˆ˜ ê°ì²´, ëŒë‹¤ì™€ í•¨ê»˜ ì‚¬ìš© ê°€ëŠ¥
> - ì½ê¸°/ì“°ê¸°/ë³€í˜•/ì •ë ¬/ê²€ìƒ‰ ë“±ì˜ ë²”ìš© ê¸°ëŠ¥ ì œê³µ

### âœ… 2. `std::sort` â€“ ì •ë ¬

#### ëª©ì : **ì§€ì •ëœ ë²”ìœ„ì˜ ì›ì†Œë¥¼ ì˜¤ë¦„ì°¨ìˆœ(ë˜ëŠ” ì‚¬ìš©ì ì •ì˜ ê¸°ì¤€)ìœ¼ë¡œ ì •ë ¬**

#### ì‹œê·¸ë‹ˆì²˜:

```
template<class RandomIt>
void sort(RandomIt first, RandomIt last);

template<class RandomIt, class Compare>
void sort(RandomIt first, RandomIt last, Compare comp);
```

#### ì˜ˆì œ:

```
std::vector<int> v = {5, 3, 9, 1};
std::sort(v.begin(), v.end());  // ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬

std::sort(v.begin(), v.end(), std::greater<>());  // ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
```

> ì‚¬ìš© ì¡°ê±´: ë°˜ë³µìëŠ” `RandomAccessIterator`ì—¬ì•¼ í•˜ë¯€ë¡œ `vector`, `deque`ëŠ” ê°€ëŠ¥í•˜ì§€ë§Œ `list`ëŠ” ë¶ˆê°€ëŠ¥

### âœ… 3. `std::find` â€“ ê°’ ê²€ìƒ‰

#### ëª©ì : **ë²”ìœ„ì—ì„œ íŠ¹ì • ê°’ì„ ì°¾ê³ , ì°¾ìœ¼ë©´ ë°˜ë³µìë¥¼ ë°˜í™˜**

#### ì‹œê·¸ë‹ˆì²˜:

```
template<class InputIt, class T>
InputIt find(InputIt first, InputIt last, const T& value);
```

#### ì˜ˆì œ:

```
std::vector<int> v = {10, 20, 30};

auto it = std::find(v.begin(), v.end(), 20);
if (it != v.end()) {
    std::cout << "ì°¾ìŒ: " << *it << '\n';
} else {
    std::cout << "ê°’ ì—†ìŒ\n";
}
```

### âœ… 4. `std::transform` â€“ ê°’ ë³€í™˜ ë° ì €ì¥

#### ëª©ì : **ì…ë ¥ ë²”ìœ„ì˜ ê° ìš”ì†Œë¥¼ í•¨ìˆ˜ë¡œ ë³€í™˜í•˜ì—¬ ì¶œë ¥ ë²”ìœ„ì— ì €ì¥**

#### ì‹œê·¸ë‹ˆì²˜:

```
template<class InputIt, class OutputIt, class UnaryOperation>
OutputIt transform(InputIt first, InputIt last, OutputIt d_first, UnaryOperation op);
```

#### ì˜ˆì œ:

```
std::vector<int> v = {1, 2, 3};
std::vector<int> result(3);

std::transform(v.begin(), v.end(), result.begin(), [](int x) {
    return x * 2;
});

// result = {2, 4, 6}
```

> ì…ë ¥ê³¼ ì¶œë ¥ ì»¨í…Œì´ë„ˆê°€ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
>  ëŒë‹¤, í•¨ìˆ˜ í¬ì¸í„°, í•¨ìˆ˜ ê°ì²´ ëª¨ë‘ ì‚¬ìš© ê°€ëŠ¥

### âœ… 5. `std::for_each` â€“ ê° ìš”ì†Œì— í•¨ìˆ˜ ì ìš©

#### ëª©ì : **ë²”ìœ„ì˜ ê° ì›ì†Œì— í•¨ìˆ˜ë¥¼ ì ìš© (ë‹¨ìˆœ ë°˜ë³µ)**

#### ì‹œê·¸ë‹ˆì²˜:

```
template<class InputIt, class UnaryFunction>
UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f);
```

#### ì˜ˆì œ:

```
std::vector<int> v = {1, 2, 3};

std::for_each(v.begin(), v.end(), [](int x) {
    std::cout << "ê°’: " << x << '\n';
});
```

- ë°˜í™˜ê°’ì€ í•¨ìˆ˜ ê°ì²´(f) â†’ ìƒíƒœë¥¼ ê°€ì§„ í•¨ìˆ˜ ê°ì²´ì˜ ê²½ìš° í›„ì²˜ë¦¬ì— í™œìš© ê°€ëŠ¥

### âœ… 6. ì•Œê³ ë¦¬ì¦˜ ì„ íƒ ê¸°ì¤€ ìš”ì•½

| ì•Œê³ ë¦¬ì¦˜         | ì„¤ëª…      | ì…ì¶œë ¥ ì¡°ê±´            | íŠ¹ì§•                     |
| ---------------- | --------- | ---------------------- | ------------------------ |
| `std::sort`      | ì •ë ¬      | RandomAccessIterator   | in-place ì •ë ¬, ë§¤ìš° ë¹ ë¦„ |
| `std::find`      | ê°’ ê²€ìƒ‰   | InputIterator ì´ìƒ     | ì²« ë²ˆì§¸ ë§¤ì¹­ ì›ì†Œ ë°˜í™˜   |
| `std::transform` | ë³€í™˜/ë³µì‚¬ | Input + OutputIterator | ì…ë ¥ â†’ ì¶œë ¥ ë§¤í•‘         |
| `std::for_each`  | ë‹¨ìˆœ ë°˜ë³µ | InputIterator ì´ìƒ     | ì¶œë ¥ ì—†ìŒ (void)         |

### âœ… 7. ê¸°íƒ€ ìœ ìš©í•œ ì•Œê³ ë¦¬ì¦˜ ì˜ˆì‹œ

| ì´ë¦„                            | ê¸°ëŠ¥                                     |
| ------------------------------- | ---------------------------------------- |
| `std::reverse`                  | ë²”ìœ„ ë’¤ì§‘ê¸°                              |
| `std::copy`                     | ë³µì‚¬                                     |
| `std::count`                    | íŠ¹ì • ê°’ ë“±ì¥ íšŸìˆ˜ ì„¸ê¸°                   |
| `std::remove`                   | ì¡°ê±´ì— ë§ëŠ” ìš”ì†Œ ì œê±° (ì‹¤ì œ ì‚­ì œëŠ” ì•„ë‹˜) |
| `std::unique`                   | ì¤‘ë³µ ì œê±° (ì •ë ¬ í•„ìš”)                    |
| `std::accumulate` (`<numeric>`) | ëˆ„ì  í•©, ê³± ê³„ì‚°                         |

### ğŸ“Œ ì •ë¦¬ ìš”ì•½

| í•¨ìˆ˜             | í•µì‹¬ ê¸°ëŠ¥              | ì‚¬ìš© ì¡°ê±´                               |
| ---------------- | ---------------------- | --------------------------------------- |
| `std::sort`      | ì •ë ¬                   | RandomAccessIterator (vector, deque ë“±) |
| `std::find`      | íŠ¹ì • ê°’ ì°¾ê¸°           | ëª¨ë“  ì»¨í…Œì´ë„ˆ ì§€ì›                      |
| `std::transform` | í•¨ìˆ˜ ì ìš© í›„ ê²°ê³¼ ì €ì¥ | ì…ë ¥+ì¶œë ¥ ì»¨í…Œì´ë„ˆ í•„ìš”                 |
| `std::for_each`  | ê° ìš”ì†Œì— í•¨ìˆ˜ ì ìš©    | ë¶€ìˆ˜íš¨ê³¼ìš© (ì¶œë ¥, ì¹´ìš´íŠ¸ ë“±)            |

## í•¨ìˆ˜ ê°ì²´(functor)ì™€ ëŒë‹¤(lambda)

### âœ… 1. í•¨ìˆ˜ ê°ì²´(Functor)ë€?

**í•¨ìˆ˜ ê°ì²´(functor)**ëŠ” **í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œ ê°€ëŠ¥í•œ ê°ì²´**ë¥¼ ì˜ë¯¸í•œë‹¤.
 ì´ëŠ” **`operator()`ë¥¼ ì˜¤ë²„ë¡œë”©í•œ í´ë˜ìŠ¤ ë˜ëŠ” êµ¬ì¡°ì²´ì˜ ì¸ìŠ¤í„´ìŠ¤**ì´ë©°, ì¼ë°˜ í•¨ìˆ˜ë³´ë‹¤ ìƒíƒœë¥¼ ê°€ì§ˆ ìˆ˜ ìˆì–´ ìœ ì—°í•˜ë‹¤.

#### ğŸ“Œ íŠ¹ì§•

- ì¼ë°˜ í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œ (`f(x)`)
- **ìƒíƒœ(state)**ë¥¼ ì €ì¥ ê°€ëŠ¥
- **STL ì•Œê³ ë¦¬ì¦˜ì— ìì£¼ ì‚¬ìš©**

#### ğŸ“Œ ê¸°ë³¸ ì˜ˆì œ

```
struct MultiplyBy {
    int factor;
    MultiplyBy(int f) : factor(f) {}
    int operator()(int x) const {
        return x * factor;
    }
};

MultiplyBy times3(3);
int result = times3(5);  // result = 15
```

### âœ… 2. í•¨ìˆ˜ ê°ì²´ë¥¼ í™œìš©í•œ STL ì•Œê³ ë¦¬ì¦˜ ì˜ˆ

```
#include <vector>
#include <algorithm>

struct IsEven {
    bool operator()(int x) const {
        return x % 2 == 0;
    }
};

std::vector<int> v = {1, 2, 3, 4, 5};
int even_count = std::count_if(v.begin(), v.end(), IsEven());
```

- `count_if`ëŠ” ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìš”ì†Œì˜ ê°œìˆ˜ë¥¼ ì…ˆ
- `IsEven`ì€ `bool(int)`ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ ê°ì²´

### âœ… 3. ëŒë‹¤ í‘œí˜„ì‹ (Lambda Expression)

#### ğŸ“Œ ê°œìš”

ëŒë‹¤ëŠ” **ìµëª… í•¨ìˆ˜ ê°ì²´ë¥¼ ê°„ê²°í•˜ê²Œ ìƒì„±í•˜ëŠ” í‘œí˜„ì‹**ì´ë‹¤.
 ì¦‰ì„ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©°, ìº¡ì²˜(capture) ê¸°ëŠ¥ì„ í†µí•´ ì™¸ë¶€ ë³€ìˆ˜ ì°¸ì¡°ë„ ê°€ëŠ¥í•˜ë‹¤.

#### ğŸ“Œ ê¸°ë³¸ ë¬¸ë²•

```
[capture](parameters) -> return_type {
    // í•¨ìˆ˜ ë³¸ë¬¸
}
```

> `return_type`ì€ ìƒëµ ê°€ëŠ¥í•˜ë©°, ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ìë™ ì¶”ë¡ ë¨.

#### ğŸ“Œ ê°„ë‹¨í•œ ì˜ˆì œ

```
auto add = [](int a, int b) {
    return a + b;
};

int result = add(2, 3);  // result = 5
```

### âœ… 4. ëŒë‹¤ì˜ ìº¡ì²˜ ë°©ì‹

| ë¬¸ë²•      | ì„¤ëª…                           |
| --------- | ------------------------------ |
| `[=]`     | ëª¨ë“  ì™¸ë¶€ ë³€ìˆ˜ **ê°’ìœ¼ë¡œ ë³µì‚¬** |
| `[&]`     | ëª¨ë“  ì™¸ë¶€ ë³€ìˆ˜ **ì°¸ì¡°ë¡œ ìº¡ì²˜** |
| `[x]`     | ë³€ìˆ˜ xë§Œ ê°’ìœ¼ë¡œ ìº¡ì²˜           |
| `[&x]`    | ë³€ìˆ˜ xë§Œ ì°¸ì¡°ë¡œ ìº¡ì²˜           |
| `[=, &y]` | yëŠ” ì°¸ì¡°, ë‚˜ë¨¸ì§€ëŠ” ê°’          |

#### ì˜ˆì œ

```
int a = 10;
int b = 20;

auto sum = [=]() { return a + b; };     // ê°’ ë³µì‚¬
auto diff = [&]() { return a - b; };    // ì°¸ì¡° ìº¡ì²˜
```

> ìº¡ì²˜ëœ ë³€ìˆ˜ëŠ” ëŒë‹¤ê°€ ìƒì„±ë  ë‹¹ì‹œì˜ ê°’ì„ ê¸°ë°˜ìœ¼ë¡œ ë™ì‘

### âœ… 5. STLì—ì„œ ëŒë‹¤ í™œìš© ì˜ˆ

```
std::vector<int> v = {1, 2, 3, 4};

std::for_each(v.begin(), v.end(), [](int x) {
    std::cout << "ê°’: " << x << '\n';
});

std::transform(v.begin(), v.end(), v.begin(), [](int x) {
    return x * x;
});
```

- `for_each`: ê° ì›ì†Œ ì¶œë ¥
- `transform`: ê° ì›ì†Œ ì œê³±ìœ¼ë¡œ ë³€í™˜

### âœ… 6. í•¨ìˆ˜ ê°ì²´ vs ëŒë‹¤ ë¹„êµ

| í•­ëª©        | í•¨ìˆ˜ ê°ì²´ (Functor)       | ëŒë‹¤ (Lambda)                |
| ----------- | ------------------------- | ---------------------------- |
| ì„ ì–¸ ìœ„ì¹˜   | í´ë˜ìŠ¤/êµ¬ì¡°ì²´ë¡œ ì •ì˜ í•„ìš” | ì½”ë“œ ì¤‘ê°„ì— ì¦‰ì‹œ ì •ì˜ ê°€ëŠ¥   |
| ìº¡ì²˜ ê¸°ëŠ¥   | ëª…ì‹œì  ë©¤ë²„ë¡œë§Œ ê°€ëŠ¥      | ìº¡ì²˜ ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©             |
| ì¬ì‚¬ìš©ì„±    | ì¬ì‚¬ìš© ê°€ëŠ¥ (í´ë˜ìŠ¤ ë‹¨ìœ„) | ì£¼ë¡œ ì¼íšŒì„±                  |
| ë””ë²„ê¹…/ì¶”ì  | ëª…í™•í•¨ (í´ë˜ìŠ¤ ì´ë¦„ ì¡´ì¬) | ë””ë²„ê¹… ë„êµ¬ì— ë”°ë¼ ì´ë¦„ ì—†ìŒ |
| ì„±ëŠ¥        | ëŒ€ë¶€ë¶„ ë™ì¼ (ìµœì í™”ë¨)    | ë™ì¼ (C++14 ì´í›„ ë” ìš°ìˆ˜í•¨)  |

### âœ… 7. C++14/17 ì´í›„ ê°œì„ 

- C++14: **ì¼ë°˜í™”ëœ ë§¤ê°œë³€ìˆ˜** (`auto` ì‚¬ìš© ê°€ëŠ¥)

```
auto plus = [](auto a, auto b) { return a + b; };
```

- C++17: **ìº¡ì²˜ ì´ˆê¸°í™”** ì§€ì›

```
int x = 42;
auto f = [y = x + 1]() {
    return y * 2;
};
```

### âœ… ê²°ë¡  ìš”ì•½

| ê°œë…                     | ì„¤ëª…                                                      |
| ------------------------ | --------------------------------------------------------- |
| **í•¨ìˆ˜ ê°ì²´ (Functor)**  | `operator()`ë¥¼ ê°€ì§„ ê°ì²´, ìƒíƒœ ë³´ì¡´ ë° ì¬ì‚¬ìš©ì— ê°•ì       |
| **ëŒë‹¤ í‘œí˜„ì‹ (Lambda)** | ìµëª… í•¨ìˆ˜ ê°ì²´, ê°„ê²°í•˜ê³  í•¨ìˆ˜ ì¸ë¼ì¸ í‘œí˜„ì— ì í•©          |
| **ê³µí†µì **               | í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œ ê°€ëŠ¥ (`f(x)`), STL ì•Œê³ ë¦¬ì¦˜ê³¼ ê²°í•© ìš©ì´     |
| **ì„ íƒ ê¸°ì¤€**            | ì¬ì‚¬ìš©ì„± ë˜ëŠ” ë³µì¡í•œ ìƒíƒœ â†’ Functor, ê°„ë‹¨í•œ ì—°ì‚° â†’ Lambda |

## ì–´ëŒ‘í„°: stack, queue, priority_queue

### âœ… 1. ì»¨í…Œì´ë„ˆ ì–´ëŒ‘í„°ë€?

**ì»¨í…Œì´ë„ˆ ì–´ëŒ‘í„°(Container Adapter)**ëŠ” STLì˜ ì»¨í…Œì´ë„ˆ(`vector`, `deque`, `list`) ìœ„ì—
 **ì œí•œëœ ì ‘ê·¼ ê·œì¹™ì„ ê°•ì œí•œ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ëŠ” ë˜í¼(wrapper)**ì…ë‹ˆë‹¤.

> í•µì‹¬ íŠ¹ì§•:
>
> - ìì²´ êµ¬ì¡°ëŠ” ì—†ìŒ
> - **ë‚´ë¶€ ì»¨í…Œì´ë„ˆ(underlying container)**ë¥¼ í†µí•´ ê¸°ëŠ¥ êµ¬í˜„
> - **ì¸í„°í˜ì´ìŠ¤ë§Œ ì œí•œ** (ì˜ˆ: top(), push(), pop())

### âœ… 2. `std::stack` â€“ í›„ì…ì„ ì¶œ ìŠ¤íƒ (LIFO)

#### í—¤ë”:

```
#include <stack>
```

#### íŠ¹ì§•:

| í•­ëª©          | ì„¤ëª…                                    |
| ------------- | --------------------------------------- |
| ê¸°ë³¸ ë™ì‘     | ë§ˆì§€ë§‰ì— ë„£ì€ ì›ì†Œê°€ ë¨¼ì € ì œê±°ë¨ (LIFO) |
| ë‚´ë¶€ ì»¨í…Œì´ë„ˆ | ê¸°ë³¸: `deque<T>` (ë³€ê²½ ê°€ëŠ¥)            |
| ì ‘ê·¼ ë°©ì‹     | ê°€ì¥ ìœ„(top)ì—ë§Œ ì ‘ê·¼ ê°€ëŠ¥              |

#### ì£¼ìš” ë©¤ë²„ í•¨ìˆ˜:

| í•¨ìˆ˜        | ì„¤ëª…                |
| ----------- | ------------------- |
| `push(val)` | ìš”ì†Œ ì¶”ê°€           |
| `pop()`     | top ìš”ì†Œ ì œê±°       |
| `top()`     | ê°€ì¥ ìœ„ì˜ ìš”ì†Œ ë°˜í™˜ |
| `empty()`   | ë¹„ì—ˆëŠ”ì§€ í™•ì¸       |
| `size()`    | ìš”ì†Œ ìˆ˜ ë°˜í™˜        |

#### ì˜ˆì œ:

```
std::stack<int> s;
s.push(10);
s.push(20);
std::cout << s.top(); // 20
s.pop();              // 20 ì œê±°
```

### âœ… 3. `std::queue` â€“ ì„ ì…ì„ ì¶œ í (FIFO)

#### í—¤ë”:

```
#include <queue>
```

#### íŠ¹ì§•:

| í•­ëª©          | ì„¤ëª…                                |
| ------------- | ----------------------------------- |
| ê¸°ë³¸ ë™ì‘     | ë¨¼ì € ë“¤ì–´ì˜¨ ìš”ì†Œê°€ ë¨¼ì € ë‚˜ê° (FIFO) |
| ë‚´ë¶€ ì»¨í…Œì´ë„ˆ | ê¸°ë³¸: `deque<T>`                    |
| ì ‘ê·¼ ë°©ì‹     | front/backë§Œ ì ‘ê·¼ ê°€ëŠ¥              |

#### ì£¼ìš” ë©¤ë²„ í•¨ìˆ˜:

| í•¨ìˆ˜        | ì„¤ëª…              |
| ----------- | ----------------- |
| `push(val)` | ë’¤ì— ì‚½ì…         |
| `pop()`     | ì•ì—ì„œ ì œê±°       |
| `front()`   | ê°€ì¥ ì• ìš”ì†Œ ì°¸ì¡° |
| `back()`    | ê°€ì¥ ë’¤ ìš”ì†Œ ì°¸ì¡° |
| `empty()`   | ë¹„ì—ˆëŠ”ì§€ í™•ì¸     |
| `size()`    | ìš”ì†Œ ìˆ˜ ë°˜í™˜      |

#### ì˜ˆì œ:

```
std::queue<std::string> q;
q.push("A");
q.push("B");
std::cout << q.front();  // A
q.pop();                 // A ì œê±°
```

### âœ… 4. `std::priority_queue` â€“ ìš°ì„ ìˆœìœ„ í

#### í—¤ë”:

```
#include <queue>
```

#### íŠ¹ì§•:

| í•­ëª©          | ì„¤ëª…                                                         |
| ------------- | ------------------------------------------------------------ |
| ê¸°ë³¸ ë™ì‘     | ê°€ì¥ í° ê°’(ë˜ëŠ” ì‚¬ìš©ì ì •ì˜ ê¸°ì¤€ì— ê°€ì¥ ì•ì„  ê°’)ì´ ë¨¼ì € ë‚˜ê° |
| ë‚´ë¶€ ì»¨í…Œì´ë„ˆ | ê¸°ë³¸: `vector<T>`                                            |
| ë‚´ë¶€ êµ¬ì¡°     | **í™(heap)** êµ¬ì¡°ë¡œ êµ¬í˜„ (`std::make_heap` ë“± ì‚¬ìš©)          |
| ì •ë ¬ ê¸°ì¤€     | ê¸°ë³¸: `std::less<T>` (ìµœëŒ€ í™) â†’ `std::greater<T>`ë¡œ ìµœì†Œ í™ ê°€ëŠ¥ |

#### ì£¼ìš” ë©¤ë²„ í•¨ìˆ˜:

| í•¨ìˆ˜        | ì„¤ëª…              |
| ----------- | ----------------- |
| `push(val)` | ì‚½ì… í›„ ìë™ ì •ë ¬ |
| `pop()`     | ìµœìš°ì„  ìš”ì†Œ ì œê±°  |
| `top()`     | ìµœìš°ì„  ìš”ì†Œ í™•ì¸  |
| `empty()`   | ë¹„ì—ˆëŠ”ì§€ í™•ì¸     |
| `size()`    | ìš”ì†Œ ìˆ˜ ë°˜í™˜      |

#### ì˜ˆì œ: ìµœëŒ€ í™ (ê¸°ë³¸)

```
std::priority_queue<int> pq;
pq.push(3);
pq.push(5);
pq.push(1);
std::cout << pq.top(); // 5
pq.pop();              // 5 ì œê±°
```

#### ì˜ˆì œ: ìµœì†Œ í™

```
std::priority_queue<int, std::vector<int>, std::greater<>> min_pq;
min_pq.push(3);
min_pq.push(5);
min_pq.push(1);
std::cout << min_pq.top(); // 1
```

### âœ… 5. ì–´ëŒ‘í„° ê°„ ë¹„êµ

| ì–´ëŒ‘í„°           | ë™ì‘ ë°©ì‹     | ë‚´ë¶€ ì»¨í…Œì´ë„ˆ   | ì ‘ê·¼ ë°©ì‹           | ì‚½ì…/ì‚­ì œ ìœ„ì¹˜              |
| ---------------- | ------------- | --------------- | ------------------- | --------------------------- |
| `stack`          | LIFO          | `deque` (ê¸°ë³¸)  | `top()`             | push/pop at back            |
| `queue`          | FIFO          | `deque` (ê¸°ë³¸)  | `front()`, `back()` | push at back / pop at front |
| `priority_queue` | í™ (ìš°ì„ ìˆœìœ„) | `vector` (ê¸°ë³¸) | `top()`             | ì •ë ¬ëœ ìœ„ì¹˜ ì‚½ì…/ì‚­ì œ       |

### âœ… ì–´ëŒ‘í„° ìƒì„± ì‹œ ì»¨í…Œì´ë„ˆ ì§€ì •

```
std::stack<int, std::vector<int>> s1;        // vector ê¸°ë°˜ stack
std::queue<int, std::list<int>> q1;          // list ê¸°ë°˜ queue
std::priority_queue<int, std::deque<int>> pq1; // deque ê¸°ë°˜ heap
```

> ì¡°ê±´: ì§€ì •í•˜ëŠ” ë‚´ë¶€ ì»¨í…Œì´ë„ˆëŠ” í•´ë‹¹ ì–´ëŒ‘í„°ì˜ **í•„ìˆ˜ ì—°ì‚°ì„ ì§€ì›í•´ì•¼ í•¨**
>  (ì˜ˆ: `push_back`, `pop_back`, `front`, `back` ë“±)

### âœ… ì‹¤ì „ íŒ

- **ë‹¨ìˆœ LIFO/FIFO** êµ¬ì¡°ê°€ í•„ìš”í•  ë•Œ `stack`/`queue`ë¥¼ ì‚¬ìš©í•˜ë˜,
   **ë³µì¡í•œ ìˆœíšŒë‚˜ ì‚½ì… ì œì–´**ê°€ í•„ìš”í•˜ë©´ `deque`/`list`/`vector`ë¥¼ ì§ì ‘ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ìœ ì—°í•˜ë‹¤.
- `priority_queue`ëŠ” í™ ìë£Œêµ¬ì¡°ë¥¼ C++ì—ì„œ ê°„ë‹¨íˆ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•´ì£¼ë©°,
   ì‚¬ìš©ì ì •ì˜ ë¹„êµìì™€ í•¨ê»˜ ë§¤ìš° ê°•ë ¥í•œ ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.

## STLê³¼ ì‚¬ìš©ì ì •ì˜ íƒ€ì… ì—°ë™

### âœ… 1. ì‚¬ìš©ì ì •ì˜ íƒ€ì…ì„ STL ì»¨í…Œì´ë„ˆì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ê°€?

ì˜ˆ. C++ STL ì»¨í…Œì´ë„ˆëŠ” ê¸°ë³¸ íƒ€ì…ë¿ ì•„ë‹ˆë¼ **ì‚¬ìš©ì ì •ì˜ êµ¬ì¡°ì²´/í´ë˜ìŠ¤**ë„ ì €ì¥í•  ìˆ˜ ìˆë‹¤.

ë‹¨, ë‹¤ìŒê³¼ ê°™ì€ ì¡°ê±´ì´ í•„ìš”í•˜ë‹¤:

| ì»¨í…Œì´ë„ˆ ì¢…ë¥˜                              | í•„ìš”í•œ ì—°ì‚°                                         |
| ------------------------------------------ | --------------------------------------------------- |
| `std::vector`, `std::list`, `std::deque`   | ë³µì‚¬/ì´ë™ ìƒì„±ì, ëŒ€ì… ì—°ì‚°ì                       |
| `std::set`, `std::map`                     | `<` ë¹„êµ ì—°ì‚° ë˜ëŠ” ì»¤ìŠ¤í…€ ë¹„êµì                    |
| `std::unordered_set`, `std::unordered_map` | `==` ë¹„êµ, í•´ì‹œ í•¨ìˆ˜ (`std::hash` ë˜ëŠ” ì»¤ìŠ¤í…€ í•´ì‹œ) |

### âœ… 2. `std::vector`, `std::list` ë“± ìˆœì°¨ ì»¨í…Œì´ë„ˆ

ê°€ì¥ ê°„ë‹¨í•œ ê²½ìš°ë‹¤. êµ¬ì¡°ì²´ì— íŠ¹ë³„í•œ ì—°ì‚°ìê°€ ì—†ì–´ë„ ì €ì¥ ê°€ëŠ¥í•˜ë‹¤.

```
struct Point {
    int x, y;
};

std::vector<Point> points = {{1, 2}, {3, 4}};
```

ë‹¨, `std::sort(points.begin(), points.end())`ì„ í•˜ë ¤ë©´ `<` ì—°ì‚°ì ì •ì˜ê°€ í•„ìš”í•˜ë‹¤.

```
bool operator<(const Point& a, const Point& b) {
    return a.x < b.x;  // ì •ë ¬ ê¸°ì¤€ ì •ì˜
}
```

### âœ… 3. `std::set`, `std::map` â€“ í‚¤ ë¹„êµ ê¸°ì¤€ í•„ìš”

ì´ ì»¨í…Œì´ë„ˆëŠ” í‚¤ë¥¼ ì •ë ¬í•˜ì—¬ ì €ì¥í•˜ê¸° ë•Œë¬¸ì— **ì •ë ¬ ê¸°ì¤€**ì´ í•„ìš”í•˜ë‹¤.

#### ë°©ë²• 1: `<` ì—°ì‚°ì ì˜¤ë²„ë¡œë”©

```
struct Person {
    std::string name;
    int age;

    bool operator<(const Person& other) const {
        return name < other.name;  // ì´ë¦„ ê¸°ì¤€ ì •ë ¬
    }
};

std::set<Person> people;
people.insert({"Alice", 30});
```

#### ë°©ë²• 2: ì‚¬ìš©ì ì •ì˜ ë¹„êµì ì „ë‹¬

```
struct Person {
    std::string name;
    int age;
};

struct CompareByAge {
    bool operator()(const Person& a, const Person& b) const {
        return a.age < b.age;
    }
};

std::set<Person, CompareByAge> people;
```

`std::map<Key, Value, Compare>` ë„ ë™ì¼í•˜ê²Œ ì ìš©ë¨.

### âœ… 4. `std::unordered_set`, `std::unordered_map` â€“ í•´ì‹œ í•¨ìˆ˜ í•„ìš”

ì´ ì»¨í…Œì´ë„ˆëŠ” **í•´ì‹œ ê¸°ë°˜**ì´ë¯€ë¡œ ë‹¤ìŒ ë‘ ê°€ì§€ê°€ í•„ìš”í•˜ë‹¤:

- `==` ë¹„êµ ì—°ì‚°ì
- `std::hash<T>` íŠ¹ìˆ˜í™” or ì‚¬ìš©ì í•´ì‹œ í•¨ìˆ˜ ê°ì²´

#### ë°©ë²• 1: `==` ì˜¤ë²„ë¡œë”©

```
struct Coord {
    int x, y;

    bool operator==(const Coord& other) const {
        return x == other.x && y == other.y;
    }
};
```

#### ë°©ë²• 2: ì‚¬ìš©ì ì •ì˜ í•´ì‹œ í•¨ìˆ˜

```
struct CoordHash {
    std::size_t operator()(const Coord& c) const {
        return std::hash<int>()(c.x) ^ (std::hash<int>()(c.y) << 1);
    }
};

#include <unordered_set>
std::unordered_set<Coord, CoordHash> grid;
```

> `std::hash<CustomType>`ì„ **íŠ¹ìˆ˜í™”í•˜ì—¬ ì „ì—­ ì •ì˜**í•  ìˆ˜ë„ ìˆìŒ

```
namespace std {
    template<>
    struct hash<Coord> {
        size_t operator()(const Coord& c) const {
            return hash<int>()(c.x) ^ (hash<int>()(c.y) << 1);
        }
    };
}
```

### âœ… 5. STL + ì‚¬ìš©ì íƒ€ì… ì˜ˆì œ ì¢…í•©

```
struct Student {
    std::string name;
    int grade;

    bool operator==(const Student& other) const {
        return name == other.name && grade == other.grade;
    }

    bool operator<(const Student& other) const {
        return grade < other.grade;
    }
};

struct HashStudent {
    std::size_t operator()(const Student& s) const {
        return std::hash<std::string>()(s.name) ^ std::hash<int>()(s.grade);
    }
};

// ì‚¬ìš© ì˜ˆì‹œ
std::set<Student> ordered_students;
std::unordered_set<Student, HashStudent> hashed_students;
```

### âœ… ìš”ì•½ ë¹„êµí‘œ

| ì»¨í…Œì´ë„ˆ                         | ìš”êµ¬ ì¡°ê±´                        | ë¹„ê³                   |
| -------------------------------- | -------------------------------- | --------------------- |
| `vector`, `list`                 | ì—†ìŒ (ë‹¨, ë³µì‚¬/ì´ë™ ê°€ëŠ¥í•´ì•¼ í•¨) | ì •ë ¬ ì‹œ `<` í•„ìš”      |
| `set`, `map`                     | `operator<` ë˜ëŠ” ì»¤ìŠ¤í…€ ë¹„êµì   | í‚¤ëŠ” ìœ ì¼í•´ì•¼ í•¨      |
| `unordered_set`, `unordered_map` | `operator==` + í•´ì‹œ í•¨ìˆ˜         | í•´ì‹œ ì¶©ëŒ ìµœì†Œí™” í•„ìš” |

### ğŸ“Œ ì‹¤ì „ íŒ

- **ì •ë ¬ ê¸°ì¤€ì´ ë³µì¡í•œ ê²½ìš°**ì—ëŠ” `operator<`ë³´ë‹¤ **ë¹„êµì ì „ë‹¬**ì´ ë” ëª…ì‹œì ì´ê³  ìœ ì—°í•˜ë‹¤.
- `unordered_*` ê³„ì—´ì—ì„œëŠ” **í•´ì‹œ í•¨ìˆ˜ í’ˆì§ˆì´ ì„±ëŠ¥ì— ì§ì ‘ ì˜í–¥**ì„ ë¯¸ì¹œë‹¤.
- `std::pair`, `std::tuple`ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë¹„êµ/í•´ì‹œê°€ ì •ì˜ë˜ì–´ ìˆì–´ ì‚¬ìš©ì ì •ì˜ ì—†ì´ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤.