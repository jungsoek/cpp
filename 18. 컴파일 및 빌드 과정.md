# 18. 컴파일 및 빌드 과정

## 전처리, 컴파일, 어셈블, 링크 단계

### 1. 전체 흐름 요약

C++ 프로그램이 실행 가능한 바이너리로 생성되기까지는 다음과 같은 **단계적 변환 과정**을 거친다:

```
source.cpp
   ↓  (1) 전처리: #include, #define, 조건부 컴파일 처리
source.i
   ↓  (2) 컴파일: C++ 코드 → 중간 어셈블리 코드
source.s
   ↓  (3) 어셈블: 어셈블리 → 목적 코드 (.o, .obj)
source.o
   ↓  (4) 링크: 여러 목적 파일 + 라이브러리 → 실행 파일
a.out / main.exe
```

### ✅ 1. 전처리 단계 (Preprocessing)

#### 수행 명령: `g++ -E source.cpp -o source.i`

#### 역할:

- `#include`로 삽입된 헤더 파일을 **코드에 그대로 복사**
- `#define`, `#ifdef`, `#ifndef` 등의 **전처리 지시문 처리**
- `#pragma` 처리
- 코드 수준에서 아직 **타입 검사나 문법 분석은 수행하지 않음**

#### 예시:

```
#include <iostream>
#define PI 3.14

int main() {
    std::cout << PI << std::endl;
}
```

→ 전처리 후에는 `iostream`의 전체 코드가 삽입되고 `PI`는 `3.14`로 치환됨.

### ✅ 2. 컴파일 단계 (Compilation)

#### 수행 명령: `g++ -S source.i -o source.s`

#### 역할:

- 전처리된 코드를 기반으로 **구문 분석 (parsing), 의미 분석 (semantic analysis)** 수행
- C++ 소스 코드를 **중간 표현(IR)** 또는 **어셈블리 코드(.s)**로 변환
- 변수 타입, 범위, 클래스 구조, 오버로딩 등 **언어 규칙 위반 여부 검사**

#### 출력: **어셈블리 코드**

```
mov eax, 0x4000
call printf
```

- 이 단계에서 구체적인 **명령어 수준 처리**는 하지 않으며, 대상 CPU에 맞는 명령어로 번역됨

### ✅ 3. 어셈블 단계 (Assembly)

#### 수행 명령: `g++ -c source.s -o source.o`

#### 역할:

- 어셈블리 코드를 **목적 코드(object code)**로 변환
- **기계어(machine code)**로 이루어진 바이너리 코드 생성
- `.o`, `.obj`, `.lib` 등의 **중간 산출물 생성**

#### 특징:

- 아직 함수의 정의가 완전하지 않음 (ex: 외부 함수 참조 존재)
- 독립 실행 불가

### ✅ 4. 링크 단계 (Linking)

#### 수행 명령: `g++ source.o -o main`

#### 역할:

- 여러 개의 **목적 파일(.o)** 및 **라이브러리(.a, .so, .dll)**를 하나로 연결
- 외부 참조(external symbol) 해결: `main()`, `printf()` 등의 정의 위치 연결
- **중복 정의, 누락된 심볼 등의 오류 탐지**

#### 결과:

- 실행 가능한 바이너리 파일 생성 (예: `a.out`, `main.exe`)

### ✅ 요약 비교표

| 단계   | 명령어 예시 | 입력              | 출력      | 주요 작업                     |
| ------ | ----------- | ----------------- | --------- | ----------------------------- |
| 전처리 | `g++ -E`    | `.cpp`            | `.i`      | `#include`, `#define` 해석    |
| 컴파일 | `g++ -S`    | `.i`              | `.s`      | 문법/의미 분석, 어셈블리 생성 |
| 어셈블 | `g++ -c`    | `.s`              | `.o`      | 기계어 바이너리로 변환        |
| 링크   | `g++`       | `.o`, `.a`, `.so` | 실행 파일 | 심볼 연결, 라이브러리 포함    |

### 🧩 참고: 컴파일러 옵션 한눈에 보기 (GCC 기준)

| 단계               | 명령어                      | 설명                   |
| ------------------ | --------------------------- | ---------------------- |
| 전처리만 수행      | `g++ -E main.cpp -o main.i` | 헤더 포함 결과 확인    |
| 어셈블리 코드 출력 | `g++ -S main.cpp -o main.s` | 어셈블리 파일 확인     |
| 목적 파일만 생성   | `g++ -c main.cpp -o main.o` | 링크 생략, 개별 컴파일 |
| 전체 빌드 수행     | `g++ main.cpp -o main`      | 실행 파일 완성         |

#### 📌 링크 오류 예시

```
undefined reference to `MyFunction()`
```

- 링크 단계에서 **외부 함수의 정의를 찾을 수 없을 때 발생**
- 원인: `.cpp`는 존재하지만 `.o` 파일을 링크하지 않았거나, `static` 선언 누락 등

### ✅ 결론 요약

- C++의 빌드 과정은 전처리 → 컴파일 → 어셈블 → 링크의 4단계로 구성된다.
- 각 단계는 **명확한 목적과 출력물을 가지며**, 일부는 분리 실행하여 디버깅이나 분석에 활용할 수 있다.
- 컴파일 오류는 **전처리/컴파일 단계**, 링크 오류는 **링크 단계**에서 발생한다.
- **대형 프로젝트**에서는 CMake, Makefile 등의 빌드 시스템을 통해 이 과정을 자동화한다.

## 헤더 파일과 소스 파일의 분리

### 1. 개요

C++에서 코드를 작성할 때는 **선언(declaration)**과 **정의(definition)**를 분리하는 것이 일반적인 설계 방식이다.

- **헤더 파일 (.h, .hpp)**: 클래스, 함수, 상수 등의 선언 및 인터페이스 제공
- **소스 파일 (.cpp)**: 선언된 요소의 구현(정의)을 포함

이러한 분리는 **코드 재사용**, **컴파일 시간 단축**, **링크 오류 방지**, **인터페이스와 구현의 분리** 등의 이점을 제공한다.

### 2. 기본 구조 예시

#### 🔹 2.1 헤더 파일 (`math_utils.h`)

```
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

namespace math {
    int add(int a, int b);
    int subtract(int a, int b);
}

#endif
```

- **함수 선언만 존재**하며, 구현은 포함하지 않는다.
- `#ifndef` ~ `#endif`는 **다중 포함 방지(Include Guard)** 역할을 한다.

#### 🔹 2.2 소스 파일 (`math_utils.cpp`)

```
#include "math_utils.h"

namespace math {
    int add(int a, int b) {
        return a + b;
    }

    int subtract(int a, int b) {
        return a - b;
    }
}
```

- `.h` 파일을 `#include`하여 선언과 정의를 연결함
- 실제 구현은 소스 파일 내부에 포함

#### 🔹 2.3 메인 파일 (`main.cpp`)

```
#include <iostream>
#include "math_utils.h"

int main() {
    std::cout << math::add(2, 3) << '\n';
    return 0;
}
```

- 헤더 파일을 통해 **함수 인터페이스만 참조**
- 구현은 **링크 단계에서 `math_utils.o`를 통해 연결**

### 3. 분리의 목적과 장점

| 목적                     | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| **컴파일 속도 향상**     | 구현을 변경해도 헤더가 바뀌지 않으면 의존 파일 재컴파일 필요 없음 |
| **인터페이스-구현 분리** | 외부 사용자에게 구현 세부사항을 노출하지 않음                |
| **재사용성**             | 동일한 헤더를 여러 `.cpp` 파일에서 참조 가능                 |
| **링크 최적화**          | 오브젝트 파일 단위로 관리 가능 (build system 효율화)         |
| **단위 테스트 용이**     | 인터페이스만 독립적으로 테스트 가능                          |

### 4. 규칙과 관행

| 항목                | 관행                                                         |
| ------------------- | ------------------------------------------------------------ |
| 헤더 포함 순서      | C++ 표준 → 외부 라이브러리 → 자체 헤더                       |
| 함수 정의는 어디에? | 반드시 `.cpp` 파일에 위치시킴                                |
| 템플릿 함수/클래스  | 예외적으로 헤더에 정의까지 포함해야 함 (컴파일 시 인스턴스화 필요) |
| 네임스페이스 사용   | 헤더 및 소스에서 일관되게 적용                               |
| `#pragma once`      | Include Guard 대체 가능 (비표준 확장, 대부분 컴파일러 지원)  |

### 5. 빌드 시 처리 순서

```
main.cpp → main.o
math_utils.cpp → math_utils.o
↓
링커가 main.o + math_utils.o를 연결
→ 실행 파일 생성
```

- 헤더 파일은 **컴파일 시 참조되지만 링크 대상은 아님**
- 따라서 헤더 파일에 함수 정의가 존재하면 **중복 정의 오류(link error)** 발생 가능

### 6. 클래스 구조 예시

#### `person.h`

```
#ifndef PERSON_H
#define PERSON_H

#include <string>

class Person {
public:
    Person(const std::string& name);
    void greet() const;

private:
    std::string name_;
};

#endif
```

#### `person.cpp`

```
#include "person.h"
#include <iostream>

Person::Person(const std::string& name) : name_(name) {}

void Person::greet() const {
    std::cout << "Hello, I am " << name_ << '\n';
}
```

### ✅ 결론 요약

| 항목        | 헤더 파일 (.h)                       | 소스 파일 (.cpp)                 |
| ----------- | ------------------------------------ | -------------------------------- |
| 포함 위치   | `#include`로 참조됨                  | 독립 컴파일 단위                 |
| 포함 내용   | 선언 (함수, 클래스, 상수 등)         | 정의 (함수 구현, 변수 초기화 등) |
| 목적        | 인터페이스 제공                      | 기능 구현                        |
| 템플릿 예외 | 선언과 정의를 동시에 헤더에 위치시킴 | -                                |

## static, extern 키워드

### 1. 개요

| 키워드   | 의미                             | 주요 사용 대상                       |
| -------- | -------------------------------- | ------------------------------------ |
| `static` | **정적 수명 또는 내부 연결성**   | 전역/지역 변수, 함수, 클래스 멤버 등 |
| `extern` | **외부 정의 참조 (링커에 위임)** | 전역 변수, 함수 선언 등              |

이 두 키워드는 주로 **링커의 심볼 해석 및 연결 단계**에서 **심볼의 가시성(linkage scope)**을 제어하기 위해 사용된다.

### ✅ 2. `static` 키워드

#### 2.1 지역 변수에서의 의미 (정적 수명)

```
void counter() {
    static int count = 0;
    ++count;
    std::cout << "Count: " << count << '\n';
}
```

- `static` 지역 변수는 함수가 종료되어도 **메모리에서 소멸되지 않고 값이 유지됨**
- 최초 한 번만 초기화됨 (`정적 수명`)

#### 2.2 전역 변수/함수에서의 의미 (내부 연결성, internal linkage)

```
// file1.cpp
static int internal_value = 10;

static void helper() {
    // 이 함수는 file1.cpp 내에서만 사용 가능
}
```

- `static` 전역 변수나 함수는 **정의된 번역 단위(.cpp 파일)에서만 접근 가능**
- 다른 소스 파일에서 참조 불가능 → **링커 심볼 충돌 방지**

#### 2.3 클래스 멤버에서의 의미 (정적 멤버 변수/함수)

```
class Logger {
public:
    static int log_count;
    static void log(const std::string& msg);
};
```

- `static` 멤버는 **객체가 아닌 클래스 자체에 속함**
- 공유 데이터/유틸리티 함수 정의에 사용

### ✅ 3. `extern` 키워드

#### 3.1 전역 변수의 외부 선언

```
// file1.cpp
int global_value = 42;
```

```
// file2.cpp
extern int global_value;  // file1.cpp에 정의된 변수 참조
```

- `extern`은 **정의가 다른 번역 단위에 있다는 것을 컴파일러에 알림**
- **링커가 해당 심볼을 연결**하여 참조를 해소

#### 3.2 함수의 외부 선언

```
// file1.cpp
void do_work() {
    // ...
}
```

```
// file2.cpp
extern void do_work();  // 생략 가능 (기본 extern)
```

- 함수 선언에는 기본적으로 `extern`이 암시됨
- 명시해도 문제는 없지만 일반적으로 생략됨

#### 3.3 `extern`과 초기화

```
extern int x = 5;  // 초기화 포함 → 정의됨 (실제 메모리 공간 생성)
```

- 초기화가 포함되면 해당 위치가 **정의(definition)**가 되므로, **중복 정의 오류 가능성** 주의

#### 📌 static vs extern 비교표

| 구분         | `static`                         | `extern`                       |
| ------------ | -------------------------------- | ------------------------------ |
| 기본 의미    | 내부 연결성 (internal linkage)   | 외부 연결성 (external linkage) |
| 사용 위치    | 함수 내부/외부, 클래스 멤버      | 전역 변수, 함수                |
| 변수 수명    | 정적 (프로그램 종료 시까지 유지) | 참조 대상에 따라 결정          |
| 가시성       | 현재 소스 파일(번역 단위)로 제한 | 다른 파일에서도 참조 가능      |
| 다중 정의    | 허용됨 (다른 파일과 충돌 없음)   | 다중 정의 시 링크 오류 발생    |
| 주 사용 목적 | 파일 내부 제한, 값 유지          | 외부 심볼 참조, 모듈 간 연결   |

### 4. 예시 시나리오

#### ✅ 전역 변수 숨기기 (Encapsulation)

```
// logger.cpp
static int log_count = 0; // 다른 파일에서 접근 불가
```

- 외부에 노출되지 않아 **전역 변수 충돌 위험 없음**

#### ✅ 모듈 간 변수 공유

```
// config.h
extern int config_flag;

// config.cpp
int config_flag = 1;
```

- 헤더에서는 `extern` 선언, `.cpp` 한 곳에서 정의 → **모듈 간 연결 가능**

### ✅ 결론 요약

| 키워드   | 의미                 | 요약                               |
| -------- | -------------------- | ---------------------------------- |
| `static` | 내부 연결, 정적 수명 | 외부 접근 차단, 수명 유지          |
| `extern` | 외부 정의 참조       | 선언만 하고, 정의는 다른 곳에 위임 |

## 전역 변수와 내부 연결성

### ✅ 1. 전역 변수란?

**전역 변수(global variable)**는 함수나 클래스 외부, 즉 **파일의 전역 범위(global scope)**에 선언된 변수로서,
 해당 변수는 **선언된 소스 파일 내 모든 함수에서 접근 가능**하다.

```
int count = 0;  // 전역 변수
```

전역 변수는 프로그램이 시작될 때 초기화되며, 프로그램이 종료될 때까지 메모리에 상주한다.
 **기본적으로 외부 연결성(external linkage)**을 갖는다.

### ✅ 2. 연결성(Linkage)이란?

링커는 각 소스 파일(.cpp)을 컴파일한 **오브젝트 파일(.o)**의 심볼을 기반으로
 **외부 참조(외부 변수/함수 등)를 해결**한다.

- **external linkage**: 다른 번역 단위(소스 파일)에서도 심볼을 참조할 수 있음
- **internal linkage**: 정의된 번역 단위 내부에서만 사용 가능

### ✅ 3. 내부 연결성 (Internal Linkage)

#### 정의

**해당 식별자가 선언된 번역 단위 내에서만 유효하며, 외부에서 참조할 수 없는 상태**

#### C++에서 내부 연결성을 부여하는 방법

```
static int counter = 0;
```

- `static` 키워드를 전역 변수나 전역 함수에 적용하면 **링커 수준에서 해당 심볼을 파일 내부로 제한**
- 동일한 이름의 `counter` 변수가 다른 소스 파일에 있어도 **충돌이 발생하지 않음**

#### 예시

**📂 logger.cpp**

```
static int log_count = 0;  // 내부 연결성

void log_message(const std::string& msg) {
    ++log_count;
    std::cout << "[" << log_count << "] " << msg << '\n';
}
```

**📂 main.cpp**

```
extern void log_message(const std::string&);
int main() {
    log_message("Start");
    // log_count = 10;  // 오류! 접근 불가 (internal linkage)
}
```

### ✅ 4. 왜 내부 연결성이 필요한가?

| 이유                           | 설명                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| **전역 심볼 충돌 방지**        | 동일한 이름의 전역 변수가 여러 파일에 있을 경우에도 충돌 없음 |
| **은닉성(encapsulation)** 확보 | 외부에서 접근할 수 없도록 제한하여 **모듈 내부 구현 보호**   |
| **컴파일 단위별 독립성 유지**  | 소스 파일 간의 종속성을 최소화함                             |

### ✅ 5. 전역 변수와 연결성의 기본 규칙

| 선언 방식       | 연결성      | 예시             | 설명                    |
| --------------- | ----------- | ---------------- | ----------------------- |
| `int x;`        | 외부 연결성 | 전역 변수 (기본) | 다른 파일에서 참조 가능 |
| `extern int x;` | 외부 연결성 | 참조 전용 선언   | 정의는 다른 파일에 존재 |
| `static int x;` | 내부 연결성 | 파일 내부 전용   | 외부에서 참조 불가      |

### 📌 실전 비교 예시

#### file1.cpp

```
static int counter = 0;  // 내부 연결성
int shared = 100;        // 외부 연결성
```

#### file2.cpp

```
extern int shared;       // OK
// extern int counter;   // 오류: counter는 내부 연결성으로 외부 접근 불가
```

### ✅ 결론 요약

| 항목        | 전역 변수                      | 내부 연결성 (`static`)           |
| ----------- | ------------------------------ | -------------------------------- |
| 기본 상태   | 외부 연결성 (external linkage) | 내부 연결성으로 제한             |
| 접근 범위   | 다른 파일에서도 접근 가능      | 선언된 파일 내부에서만 접근 가능 |
| 사용 목적   | 공유 데이터                    | 구현 은닉, 심볼 충돌 방지        |
| 선언 키워드 | 없음 (기본 global)             | `static`                         |

## One Definition Rule (ODR)

### ✅ 1. 개요

**ODR(One Definition Rule)**은 C++ 표준에서 정의된 규칙으로,
 **하나의 프로그램 전체에서 하나의 정의만 허용되는 엔터티(Entity)**에 대해 **정의가 오직 하나만 존재해야 한다**는 원칙이다.

> 동일한 엔터티(변수, 함수, 클래스 등)에 대해 **중복된 정의가 여러 번 등장하면 컴파일 오류 또는 링크 오류**가 발생한다.

### ✅ 2. ODR이 적용되는 대상

| 항목                                           | ODR 적용 여부 | 설명                                            |
| ---------------------------------------------- | ------------- | ----------------------------------------------- |
| **전역 변수**                                  | O             | 한 번만 정의 가능 (`int x = 0;`)                |
| **함수 정의**                                  | O             | 정의는 하나만, 선언은 여러 번 가능              |
| **클래스 정의**                                | O             | 동일한 구조로만 여러 번 정의 가능               |
| **`inline` 함수**                              | O             | 예외적 중복 정의 허용 (정의 내용이 동일해야 함) |
| **`const` 전역 변수 (기본적으로 내부 연결성)** | 예외          | 파일마다 정의 가능하지만 외부 접근 시 주의      |

### ✅ 3. 예시: ODR 위반 사례

#### ❌ 전역 변수 중복 정의

```
// file1.cpp
int shared = 100;

// file2.cpp
int shared = 100;  // ODR 위반 → 링크 오류 (multiple definition)
```

➡ 해결: 한 곳에서만 정의하고, 나머지 파일에서는 `extern` 선언

```
// shared.h
extern int shared;

// file1.cpp
#include "shared.h"
int shared = 100;

// file2.cpp
#include "shared.h"
```

#### ❌ 함수 중복 정의

```
// file1.cpp
int add(int a, int b) {
    return a + b;
}

// file2.cpp
int add(int a, int b) {  // ODR 위반
    return a + b;
}
```

➡ 함수 정의는 반드시 **한 곳에서만** 수행

#### ✅ `inline` 함수 예외 (허용됨)

```
// header.h
inline int max(int a, int b) {
    return (a > b) ? a : b;
}
```

- `inline` 함수는 여러 번 정의되더라도, **내용이 정확히 동일하면 허용**
- 하지만 **정의가 다르면 링크 오류 발생**

### ✅ 4. 동일한 클래스 정의: ODR 준수 조건

```
// A.h
struct A {
    int x;
};
```

- 이 구조체는 여러 번 정의되어도 **모든 정의가 동일하면 허용**
- 그러나 아래처럼 정의가 다르면 ODR 위반

```
// file1.cpp
struct A { int x; };

// file2.cpp
struct A { float x; };  // 오류: 정의 불일치
```

### ✅ 5. 링크 오류 사례

```
multiple definition of `foo`
first defined here...
```

- 링커가 두 개 이상의 오브젝트 파일에서 **동일한 이름을 가진 함수나 변수를 찾을 때** 발생
- 대부분은 **ODR 위반으로 인한 중복 정의**

### ✅ 6. 올바른 헤더 구성 패턴

#### 📂 `config.h`

```
#ifndef CONFIG_H
#define CONFIG_H

extern int flag;  // 선언만 제공

#endif
```

#### 📂 `config.cpp`

```
#include "config.h"

int flag = 1;  // 정의는 한 번만
```

- 선언(`extern`)은 여러 곳에서, 정의는 정확히 **하나만 존재해야 함**

### ✅ 요약 정리

| 개념                             | 설명                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| **ODR(One Definition Rule)**     | 정의 가능한 모든 엔터티(함수, 변수 등)는 프로그램 전체에서 한 번만 정의되어야 한다 |
| **ODR 위반 시점**                | 컴파일(클래스 구조 위반) 또는 링크 단계(함수/변수 중복 정의) |
| **헤더에서 정의하면 안 되는 것** | 전역 변수, 일반 함수 정의                                    |
| **헤더에서 정의 가능한 것**      | `inline` 함수, `constexpr`, 템플릿 정의 등 (단, 내용 동일해야 함) |

### 📌 실전 팁

- **`.h` 파일에는 선언만, `.cpp` 파일에 정의**
- 전역 변수는 반드시 `extern`과 함께 관리
- 템플릿/`inline`/`constexpr` 함수는 헤더에 정의 가능 (ODR 예외)
- 동일한 클래스 정의라도 구조가 다르면 ODR 위반